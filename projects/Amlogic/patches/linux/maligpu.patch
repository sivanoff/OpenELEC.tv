diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/aml.dtd linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/aml.dtd
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/aml.dtd	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/aml.dtd	2016-04-04 16:25:31.578527000 +0300
@@ -0,0 +1,27 @@
+/// ***************************************************************************************
+///	-	MALI
+//$$ MODULE="MALI"
+//$$ DEVICE="mali"
+//$$ L2 PROP_STR = "status"
+ mali{
+	compatible = "arm,mali";
+	dev_name = "mali";
+	status = "ok";
+		
+//$$ L2 PROP_U32 = "dvfs_id"
+//$$ L2 PROP_U32 = "recorde_number"
+//$$ L2 PROP_U32 = "dvfs_table"
+	cfg {
+		shared_memory = <1024>;  /** Mbyte **/
+		dvfs_size = <5>;                                 /** must be correct count for dvfs_table */
+		dvfs_table  = <
+		/* NOTE: frequent in this table must be ascending order */
+		/* freq_idx volage_index min max */
+			0  0  0 	200
+			1  1  152	205
+			2  2  180	212
+			3  3  205	236
+			4  4  230	256
+		>;
+	};
+};
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_broadcast.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_broadcast.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_broadcast.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_broadcast.c	2016-04-04 16:25:31.588527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_broadcast.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_broadcast.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_broadcast.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_broadcast.h	2016-04-04 16:25:31.598527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_control_timer.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_control_timer.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_control_timer.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_control_timer.c	2016-04-04 16:25:31.608527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012, 2014-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2012, 2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -33,10 +33,9 @@
 	if (mali_utilization_enabled()) {
 		struct mali_gpu_utilization_data *util_data = NULL;
 		u64 time_period = 0;
-		mali_bool need_add_timer = MALI_TRUE;
 
 		/* Calculate gpu utilization */
-		util_data = mali_utilization_calculate(&period_start_time, &time_period, &need_add_timer);
+		util_data = mali_utilization_calculate(&period_start_time, &time_period);
 
 		if (util_data) {
 #if defined(CONFIG_MALI_DVFS)
@@ -44,10 +43,10 @@
 #else
 			mali_utilization_platform_realize(util_data);
 #endif
+		}
 
-			if (MALI_TRUE == need_add_timer) {
-				mali_control_timer_add(mali_control_timeout);
-			}
+		if (MALI_TRUE == timer_running) {
+			mali_control_timer_add(mali_control_timeout);
 		}
 	}
 }
@@ -86,8 +85,6 @@
 
 mali_bool mali_control_timer_resume(u64 time_now)
 {
-	mali_utilization_data_assert_locked();
-
 	if (timer_running != MALI_TRUE) {
 		timer_running = MALI_TRUE;
 
@@ -101,14 +98,6 @@
 	return MALI_FALSE;
 }
 
-void mali_control_timer_pause(void)
-{
-	mali_utilization_data_assert_locked();
-	if (timer_running == MALI_TRUE) {
-		timer_running = MALI_FALSE;
-	}
-}
-
 void mali_control_timer_suspend(mali_bool suspend)
 {
 	mali_utilization_data_lock();
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_control_timer.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_control_timer.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_control_timer.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_control_timer.h	2016-04-04 16:25:31.608527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012, 2014-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2012, 2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -20,7 +20,6 @@
 mali_bool mali_control_timer_resume(u64 time_now);
 
 void mali_control_timer_suspend(mali_bool suspend);
-void mali_control_timer_pause(void);
 
 void mali_control_timer_add(u32 timeout);
 
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dlbu.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dlbu.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dlbu.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dlbu.c	2016-04-04 16:25:31.618527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dlbu.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dlbu.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dlbu.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dlbu.h	2016-04-04 16:25:31.638527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dma.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dma.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dma.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dma.c	2016-04-04 16:25:31.638527000 +0300
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
+ * 
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ * 
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "mali_kernel_common.h"
+#include "mali_osk.h"
+#include "mali_hw_core.h"
+#include "mali_dma.h"
+
+/**
+ * Size of the Mali-450 DMA unit registers in bytes.
+ */
+#define MALI450_DMA_REG_SIZE 0x08
+
+/**
+ * Value that appears in MEMSIZE if an error occurs when reading the command list.
+ */
+#define MALI450_DMA_BUS_ERR_VAL 0xffffffff
+
+/**
+ * Mali DMA registers
+ * Used in the register read/write routines.
+ * See the hardware documentation for more information about each register.
+ */
+typedef enum mali_dma_register {
+
+	MALI450_DMA_REG_SOURCE_ADDRESS = 0x0000,
+	MALI450_DMA_REG_SOURCE_SIZE = 0x0004,
+} mali_dma_register;
+
+struct mali_dma_core {
+	struct mali_hw_core  hw_core;      /**< Common for all HW cores */
+	_mali_osk_spinlock_t *lock;            /**< Lock protecting access to DMA core */
+	mali_dma_pool pool;                /**< Memory pool for command buffers */
+};
+
+static struct mali_dma_core *mali_global_dma_core = NULL;
+
+struct mali_dma_core *mali_dma_create(_mali_osk_resource_t *resource)
+{
+	struct mali_dma_core* dma;
+	_mali_osk_errcode_t err;
+
+	MALI_DEBUG_ASSERT(NULL == mali_global_dma_core);
+
+	dma = _mali_osk_malloc(sizeof(struct mali_dma_core));
+	if (dma == NULL) goto alloc_failed;
+
+	dma->lock = _mali_osk_spinlock_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_DMA_COMMAND);
+	if (NULL == dma->lock) goto lock_init_failed;
+
+	dma->pool = mali_dma_pool_create(MALI_DMA_CMD_BUF_SIZE, 4, 0);
+	if (NULL == dma->pool) goto dma_pool_failed;
+
+	err = mali_hw_core_create(&dma->hw_core, resource, MALI450_DMA_REG_SIZE);
+	if (_MALI_OSK_ERR_OK != err) goto hw_core_failed;
+
+	mali_global_dma_core = dma;
+	MALI_DEBUG_PRINT(2, ("Mali DMA: Created Mali APB DMA unit\n"));
+	return dma;
+
+	/* Error handling */
+
+hw_core_failed:
+	mali_dma_pool_destroy(dma->pool);
+dma_pool_failed:
+	_mali_osk_spinlock_term(dma->lock);
+lock_init_failed:
+	_mali_osk_free(dma);
+alloc_failed:
+	MALI_DEBUG_PRINT(2, ("Mali DMA: Failed to create APB DMA unit\n"));
+	return NULL;
+}
+
+void mali_dma_delete(struct mali_dma_core *dma)
+{
+	MALI_DEBUG_ASSERT_POINTER(dma);
+
+	MALI_DEBUG_PRINT(2, ("Mali DMA: Deleted Mali APB DMA unit\n"));
+
+	mali_hw_core_delete(&dma->hw_core);
+	_mali_osk_spinlock_term(dma->lock);
+	mali_dma_pool_destroy(dma->pool);
+	_mali_osk_free(dma);
+}
+
+static void mali_dma_bus_error(struct mali_dma_core *dma)
+{
+	u32 addr = mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_ADDRESS);
+
+	MALI_PRINT_ERROR(("Mali DMA: Bus error when reading command list from 0x%lx\n", addr));
+
+	/* Clear the bus error */
+	mali_hw_core_register_write(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE, 0);
+}
+
+static mali_bool mali_dma_is_busy(struct mali_dma_core *dma)
+{
+	u32 val;
+	mali_bool dma_busy_flag = MALI_FALSE;
+
+	MALI_DEBUG_ASSERT_POINTER(dma);
+
+	val = mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE);
+
+	if (MALI450_DMA_BUS_ERR_VAL == val) {
+		/* Bus error reading command list */
+		mali_dma_bus_error(dma);
+		return MALI_FALSE;
+	}
+	if (val > 0) {
+		dma_busy_flag = MALI_TRUE;
+	}
+
+	return dma_busy_flag;
+}
+
+static void mali_dma_start_transfer(struct mali_dma_core* dma, mali_dma_cmd_buf *buf)
+{
+	u32 memsize = buf->size * 4;
+	u32 addr = buf->phys_addr;
+
+	MALI_DEBUG_ASSERT_POINTER(dma);
+	MALI_DEBUG_ASSERT(memsize < (1 << 16));
+	MALI_DEBUG_ASSERT(0 == (memsize & 0x3)); /* 4 byte aligned */
+
+	MALI_DEBUG_ASSERT(!mali_dma_is_busy(dma));
+
+	/* Writes the physical source memory address of chunk containing command headers and data */
+	mali_hw_core_register_write(&dma->hw_core, MALI450_DMA_REG_SOURCE_ADDRESS, addr);
+
+	/* Writes the length of transfer */
+	mali_hw_core_register_write(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE, memsize);
+}
+
+_mali_osk_errcode_t mali_dma_get_cmd_buf(mali_dma_cmd_buf *buf)
+{
+	MALI_DEBUG_ASSERT_POINTER(buf);
+
+	buf->virt_addr = (u32*)mali_dma_pool_alloc(mali_global_dma_core->pool, &buf->phys_addr);
+	if (NULL == buf->virt_addr) {
+		return _MALI_OSK_ERR_NOMEM;
+	}
+
+	/* size contains the number of words in the buffer and is incremented
+	 * as commands are added to the buffer. */
+	buf->size = 0;
+
+	return _MALI_OSK_ERR_OK;
+}
+
+void mali_dma_put_cmd_buf(mali_dma_cmd_buf *buf)
+{
+	MALI_DEBUG_ASSERT_POINTER(buf);
+
+	if (NULL == buf->virt_addr) return;
+
+	mali_dma_pool_free(mali_global_dma_core->pool, buf->virt_addr, buf->phys_addr);
+
+	buf->virt_addr = NULL;
+}
+
+_mali_osk_errcode_t mali_dma_start(struct mali_dma_core* dma, mali_dma_cmd_buf *buf)
+{
+	_mali_osk_errcode_t err = _MALI_OSK_ERR_OK;
+
+	_mali_osk_spinlock_lock(dma->lock);
+
+	if (mali_dma_is_busy(dma)) {
+		err = _MALI_OSK_ERR_BUSY;
+		goto out;
+	}
+
+	mali_dma_start_transfer(dma, buf);
+
+out:
+	_mali_osk_spinlock_unlock(dma->lock);
+	return err;
+}
+
+void mali_dma_debug(struct mali_dma_core *dma)
+{
+	MALI_DEBUG_ASSERT_POINTER(dma);
+	MALI_DEBUG_PRINT(1, ("DMA unit registers:\n\t%08x, %08x\n",
+	                     mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_ADDRESS),
+	                     mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE)
+	                    ));
+
+}
+
+struct mali_dma_core *mali_dma_get_global_dma_core(void)
+{
+	/* Returns the global dma core object */
+	return mali_global_dma_core;
+}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dma.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dma.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dma.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dma.h	2016-04-04 16:25:31.648527000 +0300
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
+ * 
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ * 
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __MALI_DMA_H__
+#define __MALI_DMA_H__
+
+#include "mali_osk.h"
+#include "mali_osk_mali.h"
+#include "mali_hw_core.h"
+
+#define MALI_DMA_CMD_BUF_SIZE 1024
+
+typedef struct mali_dma_cmd_buf {
+	u32 *virt_addr;           /**< CPU address of command buffer */
+	u32 phys_addr;            /**< Physical address of command buffer */
+	u32 size;                 /**< Number of prepared words in command buffer */
+} mali_dma_cmd_buf;
+
+/** @brief Create a new DMA unit
+ *
+ * This is called from entry point of the driver in order to create and
+ * intialize the DMA resource
+ *
+ * @param resource it will be a pointer to a DMA resource
+ * @return DMA object on success, NULL on failure
+ */
+struct mali_dma_core *mali_dma_create(_mali_osk_resource_t *resource);
+
+/** @brief Delete DMA unit
+ *
+ * This is called on entry point of driver if the driver initialization fails
+ * after initialization of the DMA unit. It is also called on the exit of the
+ * driver to delete the DMA resource
+ *
+ * @param dma Pointer to DMA unit object
+ */
+void mali_dma_delete(struct mali_dma_core *dma);
+
+/** @brief Retrieves the MALI DMA core object (if there is)
+ *
+ * @return The Mali DMA object otherwise NULL
+ */
+struct mali_dma_core *mali_dma_get_global_dma_core(void);
+
+/**
+ * @brief Run a command buffer on the DMA unit
+ *
+ * @param dma Pointer to the DMA unit to use
+ * @param buf Pointer to the command buffer to use
+ * @return _MALI_OSK_ERR_OK if the buffer was started successfully,
+ *         _MALI_OSK_ERR_BUSY if the DMA unit is busy.
+ */
+_mali_osk_errcode_t mali_dma_start(struct mali_dma_core* dma, mali_dma_cmd_buf *buf);
+
+/**
+ * @brief Create a DMA command
+ *
+ * @param core Mali core
+ * @param reg offset to register of core
+ * @param n number of registers to write
+ */
+MALI_STATIC_INLINE u32 mali_dma_command_write(struct mali_hw_core *core, u32 reg, u32 n)
+{
+	u32 core_offset = core->phys_offset;
+
+	MALI_DEBUG_ASSERT(reg < 0x2000);
+	MALI_DEBUG_ASSERT(n < 0x800);
+	MALI_DEBUG_ASSERT(core_offset < 0x30000);
+	MALI_DEBUG_ASSERT(0 == ((core_offset + reg) & ~0x7FFFF));
+
+	return (n << 20) | (core_offset + reg);
+}
+
+/**
+ * @brief Add a array write to DMA command buffer
+ *
+ * @param buf DMA command buffer to fill in
+ * @param core Core to do DMA to
+ * @param reg Register on core to start writing to
+ * @param data Pointer to data to write
+ * @param count Number of 4 byte words to write
+ */
+MALI_STATIC_INLINE void mali_dma_write_array(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
+        u32 reg, u32 *data, u32 count)
+{
+	MALI_DEBUG_ASSERT((buf->size + 1 + count ) < MALI_DMA_CMD_BUF_SIZE / 4);
+
+	buf->virt_addr[buf->size++] = mali_dma_command_write(core, reg, count);
+
+	_mali_osk_memcpy(buf->virt_addr + buf->size, data, count * sizeof(*buf->virt_addr));
+
+	buf->size += count;
+}
+
+/**
+ * @brief Add a conditional array write to DMA command buffer
+ *
+ * @param buf DMA command buffer to fill in
+ * @param core Core to do DMA to
+ * @param reg Register on core to start writing to
+ * @param data Pointer to data to write
+ * @param count Number of 4 byte words to write
+ * @param ref Pointer to referance data that can be skipped if equal
+ */
+MALI_STATIC_INLINE void mali_dma_write_array_conditional(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
+        u32 reg, u32 *data, u32 count, const u32 *ref)
+{
+	/* Do conditional array writes are not yet implemented, fallback to a
+	 * normal array write. */
+	mali_dma_write_array(buf, core, reg, data, count);
+}
+
+/**
+ * @brief Add a conditional register write to the DMA command buffer
+ *
+ * If the data matches the reference the command will be skipped.
+ *
+ * @param buf DMA command buffer to fill in
+ * @param core Core to do DMA to
+ * @param reg Register on core to start writing to
+ * @param data Pointer to data to write
+ * @param ref Pointer to referance data that can be skipped if equal
+ */
+MALI_STATIC_INLINE void mali_dma_write_conditional(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
+        u32 reg, u32 data, const u32 ref)
+{
+	/* Skip write if reference value is equal to data. */
+	if (data == ref) return;
+
+	buf->virt_addr[buf->size++] = mali_dma_command_write(core, reg, 1);
+
+	buf->virt_addr[buf->size++] = data;
+
+	MALI_DEBUG_ASSERT(buf->size < MALI_DMA_CMD_BUF_SIZE / 4);
+}
+
+/**
+ * @brief Add a register write to the DMA command buffer
+ *
+ * @param buf DMA command buffer to fill in
+ * @param core Core to do DMA to
+ * @param reg Register on core to start writing to
+ * @param data Pointer to data to write
+ */
+MALI_STATIC_INLINE void mali_dma_write(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
+                                       u32 reg, u32 data)
+{
+	buf->virt_addr[buf->size++] = mali_dma_command_write(core, reg, 1);
+
+	buf->virt_addr[buf->size++] = data;
+
+	MALI_DEBUG_ASSERT(buf->size < MALI_DMA_CMD_BUF_SIZE / 4);
+}
+
+/**
+ * @brief Prepare DMA command buffer for use
+ *
+ * This function allocates the DMA buffer itself.
+ *
+ * @param buf The mali_dma_cmd_buf to prepare
+ * @return _MALI_OSK_ERR_OK if the \a buf is ready to use
+ */
+_mali_osk_errcode_t mali_dma_get_cmd_buf(mali_dma_cmd_buf *buf);
+
+/**
+ * @brief Check if a DMA command buffer is ready for use
+ *
+ * @param buf The mali_dma_cmd_buf to check
+ * @return MALI_TRUE if buffer is usable, MALI_FALSE otherwise
+ */
+MALI_STATIC_INLINE mali_bool mali_dma_cmd_buf_is_valid(mali_dma_cmd_buf *buf)
+{
+	return NULL != buf->virt_addr;
+}
+
+/**
+ * @brief Return a DMA command buffer
+ *
+ * @param buf Pointer to DMA command buffer to return
+ */
+void mali_dma_put_cmd_buf(mali_dma_cmd_buf *buf);
+
+#endif /* __MALI_DMA_H__ */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dvfs_policy.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dvfs_policy.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dvfs_policy.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dvfs_policy.c	2016-04-04 16:25:31.648527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012, 2014-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2012, 2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dvfs_policy.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dvfs_policy.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_dvfs_policy.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_dvfs_policy.h	2016-04-04 16:25:31.658527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012, 2014-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2012, 2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_executor.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_executor.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_executor.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_executor.c	2016-04-04 16:25:31.668527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -938,20 +938,11 @@
 	MALI_DEBUG_PRINT(3, ("Executor: powering down %u groups\n", num_groups));
 
 	for (i = 0; i < num_groups; i++) {
-		/* Groups must be either disabled or inactive. while for virtual group,
-		 * it maybe in empty state, because when we meet pm_runtime_suspend,
-		 * virtual group could be powered off, and before we acquire mali_executor_lock,
-		 * we must release mali_pm_state_lock, if there is a new physical job was queued,
-		 * all of physical groups in virtual group could be pulled out, so we only can
-		 * powered down an empty virtual group. Those physical groups will be powered
-		 * up in following pm_runtime_resume callback function.
-		 */
+		/* Groups must be either disabled or inactive */
 		MALI_DEBUG_ASSERT(mali_executor_group_is_in_state(groups[i],
 				  EXEC_STATE_DISABLED) ||
 				  mali_executor_group_is_in_state(groups[i],
-						  EXEC_STATE_INACTIVE) ||
-				  mali_executor_group_is_in_state(groups[i],
-						  EXEC_STATE_EMPTY));
+						  EXEC_STATE_INACTIVE));
 
 		MALI_DEBUG_PRINT(3, ("Executor: powering down group %s\n",
 				     mali_group_core_description(groups[i])));
@@ -1690,20 +1681,7 @@
 		}
 	}
 
-
-	/* 3. Deactivate idle pp group , must put deactive here before active vitual group
-	 *    for cover case first only has physical job in normal queue but group inactive,
-	 *    so delay the job start go to active group, when group activated,
-	 *    call scheduler again, but now if we get high queue virtual job,
-	 *    we will do nothing in schedule cause executor schedule stop
-	 */
-
-	if (MALI_TRUE == mali_executor_deactivate_list_idle(deactivate_idle_group
-			&& (!mali_timeline_has_physical_pp_job()))) {
-		trigger_pm_update = MALI_TRUE;
-	}
-
-	/* 4. Activate virtual group, if needed */
+	/* 3. Activate virtual group, if needed */
 
 	if (EXEC_STATE_INACTIVE == virtual_group_state &&
 	    0 < mali_scheduler_job_next_is_virtual()) {
@@ -1717,13 +1695,20 @@
 		}
 	}
 
-	/* 5. To power up group asap, we trigger pm update here. */
+	/* 4. To power up group asap, we trigger pm update here. */
 
 	if (MALI_TRUE == trigger_pm_update) {
 		trigger_pm_update = MALI_FALSE;
 		mali_pm_update_async();
 	}
 
+	/* 5. Deactivate idle pp group */
+
+	if (MALI_TRUE == mali_executor_deactivate_list_idle(deactivate_idle_group
+			&& (!mali_timeline_has_physical_pp_job()))) {
+		trigger_pm_update = MALI_TRUE;
+	}
+
 	/* 6. Assign jobs to idle virtual group (or deactivate if no job) */
 
 	if (EXEC_STATE_IDLE == virtual_group_state) {
@@ -2295,6 +2280,7 @@
 {
 	int current_core_scaling_mask[MALI_MAX_NUMBER_OF_DOMAINS] = { 0 };
 	int target_core_scaling_mask[MALI_MAX_NUMBER_OF_DOMAINS] = { 0 };
+	mali_bool update_global_core_scaling_mask = MALI_FALSE;
 	int i;
 
 	MALI_DEBUG_ASSERT(0 < target_core_nr);
@@ -2357,6 +2343,7 @@
 			struct mali_pm_domain *domain;
 
 			if (num_physical_pp_cores_enabled >= target_core_nr) {
+				update_global_core_scaling_mask = MALI_TRUE;
 				break;
 			}
 
@@ -2386,9 +2373,11 @@
 	 * Here, we may still have some pp cores not been enabled because of some
 	 * pp cores need to be disabled are still in working state.
 	 */
-	for (i = 0; i < MALI_MAX_NUMBER_OF_DOMAINS; i++) {
-		if (0 < target_core_scaling_mask[i]) {
-			core_scaling_delay_up_mask[i] = target_core_scaling_mask[i];
+	if (update_global_core_scaling_mask) {
+		for (i = 0; i < MALI_MAX_NUMBER_OF_DOMAINS; i++) {
+			if (0 < target_core_scaling_mask[i]) {
+				core_scaling_delay_up_mask[i] = target_core_scaling_mask[i];
+			}
 		}
 	}
 
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_executor.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_executor.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_executor.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_executor.h	2016-04-04 16:25:31.688527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012, 2014-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012, 2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp.c	2016-04-04 16:25:31.698527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -19,8 +19,6 @@
 #include "mali_osk_profiling.h"
 #endif
 
-#include <mali_platform.h>
-
 static struct mali_gp_core *mali_global_gp_core = NULL;
 
 /* Interrupt handlers */
@@ -111,8 +109,6 @@
 
 	if (MALI_REG_POLL_COUNT_SLOW == i) {
 		MALI_PRINT_ERROR(("Mali GP: Failed to stop bus on %s\n", core->hw_core.description));
-		if (mali_gp_reset_fail < 65533)
-			mali_gp_reset_fail++;
 		return _MALI_OSK_ERR_FAULT;
 	}
 	return _MALI_OSK_ERR_OK;
@@ -180,8 +176,6 @@
 	if (i == MALI_REG_POLL_COUNT_FAST) {
 		MALI_PRINT_ERROR(("Mali GP: Failed to reset core %s, rawstat: 0x%08x\n",
 				  core->hw_core.description, rawstat));
-		if (mali_gp_reset_fail < 65533)
-			mali_gp_reset_fail++;
 		return _MALI_OSK_ERR_FAULT;
 	}
 
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp.h	2016-04-04 16:25:31.708527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -61,7 +61,7 @@
 MALI_STATIC_INLINE enum mali_interrupt_result mali_gp_get_interrupt_result(struct mali_gp_core *core)
 {
 	u32 stat_used = mali_hw_core_register_read(&core->hw_core, MALIGP2_REG_ADDR_MGMT_INT_STAT) &
-			MALIGP2_REG_VAL_IRQ_MASK_USED;
+			   MALIGP2_REG_VAL_IRQ_MASK_USED;
 
 	if (0 == stat_used) {
 		return MALI_INTERRUPT_RESULT_NONE;
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp_job.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp_job.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp_job.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp_job.c	2016-04-04 16:25:31.718527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp_job.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp_job.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp_job.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp_job.h	2016-04-04 16:25:31.728527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp_scheduler.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp_scheduler.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp_scheduler.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp_scheduler.c	2016-04-04 16:25:31.738527000 +0300
@@ -0,0 +1,701 @@
+/*
+ * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
+ * 
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ * 
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "mali_gp_scheduler.h"
+#include "mali_kernel_common.h"
+#include "mali_osk.h"
+#include "mali_osk_list.h"
+#include "mali_scheduler.h"
+#include "mali_gp.h"
+#include "mali_gp_job.h"
+#include "mali_group.h"
+#include "mali_timeline.h"
+#include "mali_osk_profiling.h"
+#include "mali_kernel_utilization.h"
+#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
+#include <linux/sched.h>
+#include <trace/events/gpu.h>
+#endif
+
+enum mali_gp_slot_state {
+	MALI_GP_SLOT_STATE_IDLE,
+	MALI_GP_SLOT_STATE_WORKING,
+	MALI_GP_SLOT_STATE_DISABLED,
+};
+
+/* A render slot is an entity which jobs can be scheduled onto */
+struct mali_gp_slot {
+	struct mali_group *group;
+	/*
+	 * We keep track of the state here as well as in the group object
+	 * so we don't need to take the group lock so often (and also avoid clutter with the working lock)
+	 */
+	enum mali_gp_slot_state state;
+	u32 returned_cookie;
+};
+
+static u32 gp_version = 0;
+static _MALI_OSK_LIST_HEAD_STATIC_INIT(job_queue);      /* List of unscheduled jobs. */
+static _MALI_OSK_LIST_HEAD_STATIC_INIT(job_queue_high); /* List of unscheduled high priority jobs. */
+static struct mali_gp_slot slot;
+
+/* Variables to allow safe pausing of the scheduler */
+static _mali_osk_wait_queue_t *gp_scheduler_working_wait_queue = NULL;
+static u32 pause_count = 0;
+
+static mali_bool mali_gp_scheduler_is_suspended(void *data);
+static void mali_gp_scheduler_job_queued(void);
+static void mali_gp_scheduler_job_completed(void);
+
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+static _mali_osk_spinlock_irq_t *gp_scheduler_lock = NULL;
+#else
+static _mali_osk_spinlock_t *gp_scheduler_lock = NULL;
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+
+_mali_osk_errcode_t mali_gp_scheduler_initialize(void)
+{
+	u32 num_groups;
+	u32 i;
+	_mali_osk_errcode_t ret = _MALI_OSK_ERR_OK;
+
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+	gp_scheduler_lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER);
+#else
+	gp_scheduler_lock = _mali_osk_spinlock_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+	if (NULL == gp_scheduler_lock) {
+		ret = _MALI_OSK_ERR_NOMEM;
+		goto cleanup;
+	}
+
+	gp_scheduler_working_wait_queue = _mali_osk_wait_queue_init();
+	if (NULL == gp_scheduler_working_wait_queue) {
+		ret = _MALI_OSK_ERR_NOMEM;
+		goto cleanup;
+	}
+
+	/* Find all the available GP cores */
+	num_groups = mali_group_get_glob_num_groups();
+	for (i = 0; i < num_groups; i++) {
+		struct mali_group *group = mali_group_get_glob_group(i);
+		MALI_DEBUG_ASSERT(NULL != group);
+		if (NULL != group) {
+			struct mali_gp_core *gp_core = mali_group_get_gp_core(group);
+			if (NULL != gp_core) {
+				if (0 == gp_version) {
+					/* Retrieve GP version */
+					gp_version = mali_gp_core_get_version(gp_core);
+				}
+				slot.group = group;
+				slot.state = MALI_GP_SLOT_STATE_IDLE;
+				break; /* There is only one GP, no point in looking for more */
+			}
+		} else {
+			ret = _MALI_OSK_ERR_ITEM_NOT_FOUND;
+			goto cleanup;
+		}
+	}
+
+	return _MALI_OSK_ERR_OK;
+
+cleanup:
+	if (NULL != gp_scheduler_working_wait_queue) {
+		_mali_osk_wait_queue_term(gp_scheduler_working_wait_queue);
+		gp_scheduler_working_wait_queue = NULL;
+	}
+
+	if (NULL != gp_scheduler_lock) {
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+		_mali_osk_spinlock_irq_term(gp_scheduler_lock);
+#else
+		_mali_osk_spinlock_term(gp_scheduler_lock);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+		gp_scheduler_lock = NULL;
+	}
+
+	return ret;
+}
+
+void mali_gp_scheduler_terminate(void)
+{
+	MALI_DEBUG_ASSERT(   MALI_GP_SLOT_STATE_IDLE     == slot.state
+	                     || MALI_GP_SLOT_STATE_DISABLED == slot.state);
+	MALI_DEBUG_ASSERT_POINTER(slot.group);
+	mali_group_delete(slot.group);
+
+	_mali_osk_wait_queue_term(gp_scheduler_working_wait_queue);
+
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+	_mali_osk_spinlock_irq_term(gp_scheduler_lock);
+#else
+	_mali_osk_spinlock_term(gp_scheduler_lock);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+}
+
+MALI_STATIC_INLINE void mali_gp_scheduler_lock(void)
+{
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+	_mali_osk_spinlock_irq_lock(gp_scheduler_lock);
+#else
+	_mali_osk_spinlock_lock(gp_scheduler_lock);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+	MALI_DEBUG_PRINT(5, ("Mali GP scheduler: GP scheduler lock taken\n"));
+}
+
+MALI_STATIC_INLINE void mali_gp_scheduler_unlock(void)
+{
+	MALI_DEBUG_PRINT(5, ("Mali GP scheduler: Releasing GP scheduler lock\n"));
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+	_mali_osk_spinlock_irq_unlock(gp_scheduler_lock);
+#else
+	_mali_osk_spinlock_unlock(gp_scheduler_lock);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+}
+
+#if defined(DEBUG)
+#define MALI_ASSERT_GP_SCHEDULER_LOCKED() MALI_DEBUG_ASSERT_LOCK_HELD(gp_scheduler_lock)
+#else
+#define MALI_ASSERT_GP_SCHEDULER_LOCKED() do {} while (0)
+#endif /* defined(DEBUG) */
+
+/* Group and scheduler must be locked when entering this function.  Both will be unlocked before
+ * exiting. */
+static void mali_gp_scheduler_schedule_internal_and_unlock(void)
+{
+	struct mali_gp_job *job = NULL;
+
+	MALI_DEBUG_ASSERT_LOCK_HELD(slot.group->lock);
+	MALI_DEBUG_ASSERT_LOCK_HELD(gp_scheduler_lock);
+
+	if (0 < pause_count || MALI_GP_SLOT_STATE_IDLE != slot.state ||
+	    (_mali_osk_list_empty(&job_queue) && _mali_osk_list_empty(&job_queue_high))) {
+		mali_gp_scheduler_unlock();
+		mali_group_unlock(slot.group);
+		MALI_DEBUG_PRINT(4, ("Mali GP scheduler: Nothing to schedule (paused=%u, idle slots=%u)\n",
+		                     pause_count, MALI_GP_SLOT_STATE_IDLE == slot.state ? 1 : 0));
+#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
+		trace_gpu_sched_switch(mali_gp_get_hw_core_desc(group->gp_core), sched_clock(), 0, 0, 0);
+#endif
+		return; /* Nothing to do, so early out */
+	}
+
+	/* Get next job in queue */
+	if (!_mali_osk_list_empty(&job_queue_high)) {
+		job = _MALI_OSK_LIST_ENTRY(job_queue_high.next, struct mali_gp_job, list);
+	} else {
+		MALI_DEBUG_ASSERT(!_mali_osk_list_empty(&job_queue));
+		job = _MALI_OSK_LIST_ENTRY(job_queue.next, struct mali_gp_job, list);
+	}
+
+	MALI_DEBUG_ASSERT_POINTER(job);
+
+	/* Remove the job from queue */
+	_mali_osk_list_del(&job->list);
+
+	/* Mark slot as busy */
+	slot.state = MALI_GP_SLOT_STATE_WORKING;
+
+	mali_gp_scheduler_unlock();
+
+	MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Starting job %u (0x%08X)\n", mali_gp_job_get_id(job), job));
+
+	mali_group_start_gp_job(slot.group, job);
+	mali_group_unlock(slot.group);
+}
+
+void mali_gp_scheduler_schedule(void)
+{
+	mali_group_lock(slot.group);
+	mali_gp_scheduler_lock();
+
+	mali_gp_scheduler_schedule_internal_and_unlock();
+}
+
+static void mali_gp_scheduler_return_job_to_user(struct mali_gp_job *job, mali_bool success)
+{
+	_mali_uk_gp_job_finished_s *jobres = job->finished_notification->result_buffer;
+	_mali_osk_memset(jobres, 0, sizeof(_mali_uk_gp_job_finished_s)); /* @@@@ can be removed once we initialize all members in this struct */
+	jobres->user_job_ptr = mali_gp_job_get_user_id(job);
+	if (MALI_TRUE == success) {
+		jobres->status = _MALI_UK_JOB_STATUS_END_SUCCESS;
+	} else {
+		jobres->status = _MALI_UK_JOB_STATUS_END_UNKNOWN_ERR;
+	}
+
+	jobres->heap_current_addr = mali_gp_job_get_current_heap_addr(job);
+	jobres->perf_counter0 = mali_gp_job_get_perf_counter_value0(job);
+	jobres->perf_counter1 = mali_gp_job_get_perf_counter_value1(job);
+
+	mali_session_send_notification(mali_gp_job_get_session(job), job->finished_notification);
+	job->finished_notification = NULL;
+
+	mali_gp_job_delete(job);
+	mali_gp_scheduler_job_completed();
+}
+
+/* Group must be locked when entering this function.  Will be unlocked before exiting. */
+void mali_gp_scheduler_job_done(struct mali_group *group, struct mali_gp_job *job, mali_bool success)
+{
+	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
+
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(job);
+
+	MALI_DEBUG_ASSERT_LOCK_HELD(group->lock);
+	MALI_DEBUG_ASSERT(slot.group == group);
+
+	MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Job %u (0x%08X) completed (%s)\n", mali_gp_job_get_id(job), job, success ? "success" : "failure"));
+
+	/* Release tracker. */
+	schedule_mask |= mali_timeline_tracker_release(&job->tracker);
+
+	/* Signal PP job. */
+	schedule_mask |= mali_gp_job_signal_pp_tracker(job, success);
+
+	mali_gp_scheduler_lock();
+
+	/* Mark slot as idle again */
+	slot.state = MALI_GP_SLOT_STATE_IDLE;
+
+	/* If paused, then this was the last job, so wake up sleeping workers */
+	if (pause_count > 0) {
+		_mali_osk_wait_queue_wake_up(gp_scheduler_working_wait_queue);
+	}
+
+	/* Schedule any queued GP jobs on this group. */
+	mali_gp_scheduler_schedule_internal_and_unlock();
+
+	/* GP is now scheduled, removing it from the mask. */
+	schedule_mask &= ~MALI_SCHEDULER_MASK_GP;
+
+	if (MALI_SCHEDULER_MASK_EMPTY != schedule_mask) {
+		/* Releasing the tracker activated other jobs that need scheduling. */
+		mali_scheduler_schedule_from_mask(schedule_mask, MALI_FALSE);
+	}
+
+	/* Sends the job end message to user space and free the job object */
+	mali_gp_scheduler_return_job_to_user(job, success);
+}
+
+void mali_gp_scheduler_oom(struct mali_group *group, struct mali_gp_job *job)
+{
+	_mali_uk_gp_job_suspended_s * jobres;
+	_mali_osk_notification_t * notification;
+
+	mali_gp_scheduler_lock();
+
+	notification = job->oom_notification;
+	job->oom_notification = NULL;
+	slot.returned_cookie = mali_gp_job_get_id(job);
+
+	jobres = (_mali_uk_gp_job_suspended_s *)notification->result_buffer;
+	jobres->user_job_ptr = mali_gp_job_get_user_id(job);
+	jobres->cookie = mali_gp_job_get_id(job);
+
+	mali_gp_scheduler_unlock();
+
+	mali_session_send_notification(mali_gp_job_get_session(job), notification);
+
+	/*
+	* If this function failed, then we could return the job to user space right away,
+	* but there is a job timer anyway that will do that eventually.
+	* This is not exactly a common case anyway.
+	*/
+}
+
+void mali_gp_scheduler_suspend(void)
+{
+	mali_gp_scheduler_lock();
+	pause_count++; /* Increment the pause_count so that no more jobs will be scheduled */
+	mali_gp_scheduler_unlock();
+
+	_mali_osk_wait_queue_wait_event(gp_scheduler_working_wait_queue, mali_gp_scheduler_is_suspended, NULL);
+}
+
+void mali_gp_scheduler_resume(void)
+{
+	mali_gp_scheduler_lock();
+	pause_count--; /* Decrement pause_count to allow scheduling again (if it reaches 0) */
+	mali_gp_scheduler_unlock();
+	if (0 == pause_count) {
+		mali_gp_scheduler_schedule();
+	}
+}
+
+mali_timeline_point mali_gp_scheduler_submit_job(struct mali_session_data *session, struct mali_gp_job *job)
+{
+	mali_timeline_point point;
+
+	MALI_DEBUG_ASSERT_POINTER(session);
+	MALI_DEBUG_ASSERT_POINTER(job);
+
+	mali_gp_scheduler_job_queued();
+
+	/* Add job to Timeline system. */
+	point = mali_timeline_system_add_tracker(session->timeline_system, &job->tracker, MALI_TIMELINE_GP);
+
+	return point;
+}
+
+_mali_osk_errcode_t _mali_ukk_gp_start_job(void *ctx, _mali_uk_gp_start_job_s *uargs)
+{
+	struct mali_session_data *session;
+	struct mali_gp_job *job;
+	mali_timeline_point point;
+	u32 __user *timeline_point_ptr = NULL;
+
+	MALI_DEBUG_ASSERT_POINTER(uargs);
+	MALI_DEBUG_ASSERT_POINTER(ctx);
+
+	session = (struct mali_session_data*)ctx;
+
+	job = mali_gp_job_create(session, uargs, mali_scheduler_get_new_id(), NULL);
+	if (NULL == job) {
+		MALI_PRINT_ERROR(("Failed to create GP job.\n"));
+		return _MALI_OSK_ERR_NOMEM;
+	}
+
+	timeline_point_ptr = (u32 __user *) job->uargs.timeline_point_ptr;
+
+	point = mali_gp_scheduler_submit_job(session, job);
+
+	if (0 != _mali_osk_put_user(((u32) point), timeline_point_ptr)) {
+		/* Let user space know that something failed after the job was started. */
+		return _MALI_OSK_ERR_ITEM_NOT_FOUND;
+	}
+
+	return _MALI_OSK_ERR_OK;
+}
+
+_mali_osk_errcode_t _mali_ukk_get_gp_number_of_cores(_mali_uk_get_gp_number_of_cores_s *args)
+{
+	MALI_DEBUG_ASSERT_POINTER(args);
+	MALI_CHECK_NON_NULL(args->ctx, _MALI_OSK_ERR_INVALID_ARGS);
+	args->number_of_cores = 1;
+	return _MALI_OSK_ERR_OK;
+}
+
+_mali_osk_errcode_t _mali_ukk_get_gp_core_version(_mali_uk_get_gp_core_version_s *args)
+{
+	MALI_DEBUG_ASSERT_POINTER(args);
+	MALI_CHECK_NON_NULL(args->ctx, _MALI_OSK_ERR_INVALID_ARGS);
+	args->version = gp_version;
+	return _MALI_OSK_ERR_OK;
+}
+
+_mali_osk_errcode_t _mali_ukk_gp_suspend_response(_mali_uk_gp_suspend_response_s *args)
+{
+	struct mali_session_data *session;
+	struct mali_gp_job *resumed_job;
+	_mali_osk_notification_t *new_notification = 0;
+
+	MALI_DEBUG_ASSERT_POINTER(args);
+
+	if (NULL == args->ctx) {
+		return _MALI_OSK_ERR_INVALID_ARGS;
+	}
+
+	session = (struct mali_session_data*)args->ctx;
+	if (NULL == session) {
+		return _MALI_OSK_ERR_FAULT;
+	}
+
+	if (_MALIGP_JOB_RESUME_WITH_NEW_HEAP == args->code) {
+		new_notification = _mali_osk_notification_create(_MALI_NOTIFICATION_GP_STALLED, sizeof(_mali_uk_gp_job_suspended_s));
+
+		if (NULL == new_notification) {
+			MALI_PRINT_ERROR(("Mali GP scheduler: Failed to allocate notification object. Will abort GP job.\n"));
+			mali_group_lock(slot.group);
+			mali_group_abort_gp_job(slot.group, args->cookie);
+			mali_group_unlock(slot.group);
+			return _MALI_OSK_ERR_FAULT;
+		}
+	}
+
+	mali_group_lock(slot.group);
+
+	if (_MALIGP_JOB_RESUME_WITH_NEW_HEAP == args->code) {
+		MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Resuming job %u with new heap; 0x%08X - 0x%08X\n", args->cookie, args->arguments[0], args->arguments[1]));
+
+		resumed_job = mali_group_resume_gp_with_new_heap(slot.group, args->cookie, args->arguments[0], args->arguments[1]);
+		if (NULL != resumed_job) {
+			resumed_job->oom_notification = new_notification;
+			mali_group_unlock(slot.group);
+			return _MALI_OSK_ERR_OK;
+		} else {
+			mali_group_unlock(slot.group);
+			_mali_osk_notification_delete(new_notification);
+			return _MALI_OSK_ERR_FAULT;
+		}
+	}
+
+	MALI_DEBUG_PRINT(2, ("Mali GP scheduler: Aborting job %u, no new heap provided\n", args->cookie));
+	mali_group_abort_gp_job(slot.group, args->cookie);
+	mali_group_unlock(slot.group);
+	return _MALI_OSK_ERR_OK;
+}
+
+void mali_gp_scheduler_abort_session(struct mali_session_data *session)
+{
+	struct mali_gp_job *job, *tmp;
+	_MALI_OSK_LIST_HEAD_STATIC_INIT(removed_jobs);
+
+	MALI_DEBUG_ASSERT_POINTER(session);
+	MALI_DEBUG_ASSERT(session->is_aborting);
+
+	MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Aborting all jobs from session 0x%08X.\n", session));
+
+	mali_gp_scheduler_lock();
+
+	/* Find all jobs from the aborting session. */
+	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &job_queue, struct mali_gp_job, list) {
+		if (job->session == session) {
+			MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Removing job %u (0x%08X) from queue.\n", mali_gp_job_get_id(job), job));
+			_mali_osk_list_move(&job->list, &removed_jobs);
+		}
+	}
+
+	/* Find all high priority jobs from the aborting session. */
+	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &job_queue_high, struct mali_gp_job, list) {
+		if (job->session == session) {
+			MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Removing job %u (0x%08X) from queue.\n", mali_gp_job_get_id(job), job));
+			_mali_osk_list_move(&job->list, &removed_jobs);
+		}
+	}
+
+	mali_gp_scheduler_unlock();
+
+	/* Release and delete all found jobs from the aborting session. */
+	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &removed_jobs, struct mali_gp_job, list) {
+		mali_timeline_tracker_release(&job->tracker);
+		mali_gp_job_signal_pp_tracker(job, MALI_FALSE);
+		mali_gp_job_delete(job);
+		mali_gp_scheduler_job_completed();
+	}
+
+	/* Abort any running jobs from the session. */
+	mali_group_abort_session(slot.group, session);
+}
+
+static mali_bool mali_gp_scheduler_is_suspended(void *data)
+{
+	mali_bool ret;
+
+	/* This callback does not use the data pointer. */
+	MALI_IGNORE(data);
+
+	mali_gp_scheduler_lock();
+	ret = pause_count > 0 && (slot.state == MALI_GP_SLOT_STATE_IDLE || slot.state == MALI_GP_SLOT_STATE_DISABLED);
+	mali_gp_scheduler_unlock();
+
+	return ret;
+}
+
+
+#if MALI_STATE_TRACKING
+u32 mali_gp_scheduler_dump_state(char *buf, u32 size)
+{
+	int n = 0;
+
+	n += _mali_osk_snprintf(buf + n, size - n, "GP\n");
+	n += _mali_osk_snprintf(buf + n, size - n, "\tQueue is %s\n", _mali_osk_list_empty(&job_queue) ? "empty" : "not empty");
+	n += _mali_osk_snprintf(buf + n, size - n, "\tHigh priority queue is %s\n", _mali_osk_list_empty(&job_queue_high) ? "empty" : "not empty");
+
+	n += mali_group_dump_state(slot.group, buf + n, size - n);
+	n += _mali_osk_snprintf(buf + n, size - n, "\n");
+
+	return n;
+}
+#endif
+
+void mali_gp_scheduler_reset_all_groups(void)
+{
+	if (NULL != slot.group) {
+		mali_group_lock(slot.group);
+		mali_group_reset(slot.group);
+		mali_group_unlock(slot.group);
+	}
+}
+
+void mali_gp_scheduler_zap_all_active(struct mali_session_data *session)
+{
+	if (NULL != slot.group) {
+		mali_group_zap_session(slot.group, session);
+	}
+}
+
+void mali_gp_scheduler_enable_group(struct mali_group *group)
+{
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT(slot.group == group);
+	MALI_DEBUG_PRINT(2, ("Mali GP scheduler: enabling gp group %p\n", group));
+
+	mali_group_lock(group);
+
+	if (MALI_GROUP_STATE_DISABLED != group->state) {
+		mali_group_unlock(group);
+		MALI_DEBUG_PRINT(2, ("Mali GP scheduler: gp group %p already enabled\n", group));
+		return;
+	}
+
+	mali_gp_scheduler_lock();
+
+	MALI_DEBUG_ASSERT(MALI_GROUP_STATE_DISABLED == group->state);
+	MALI_DEBUG_ASSERT(MALI_GP_SLOT_STATE_DISABLED == slot.state);
+	slot.state = MALI_GP_SLOT_STATE_IDLE;
+	group->state = MALI_GROUP_STATE_IDLE;
+
+	mali_group_power_on_group(group);
+	mali_group_reset(group);
+
+	/* Pick up any jobs that might have been queued while the GP group was disabled. */
+	mali_gp_scheduler_schedule_internal_and_unlock();
+}
+
+void mali_gp_scheduler_disable_group(struct mali_group *group)
+{
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT(slot.group == group);
+	MALI_DEBUG_PRINT(2, ("Mali GP scheduler: disabling gp group %p\n", group));
+
+	mali_gp_scheduler_suspend();
+	mali_group_lock(group);
+	mali_gp_scheduler_lock();
+
+	MALI_DEBUG_ASSERT(   MALI_GROUP_STATE_IDLE     == group->state
+	                     || MALI_GROUP_STATE_DISABLED == group->state);
+
+	if (MALI_GROUP_STATE_DISABLED == group->state) {
+		MALI_DEBUG_ASSERT(MALI_GP_SLOT_STATE_DISABLED == slot.state);
+		MALI_DEBUG_PRINT(2, ("Mali GP scheduler: gp group %p already disabled\n", group));
+	} else {
+		MALI_DEBUG_ASSERT(MALI_GP_SLOT_STATE_IDLE == slot.state);
+		slot.state = MALI_GP_SLOT_STATE_DISABLED;
+		group->state = MALI_GROUP_STATE_DISABLED;
+
+		mali_group_power_off_group(group, MALI_TRUE);
+	}
+
+	mali_gp_scheduler_unlock();
+	mali_group_unlock(group);
+	mali_gp_scheduler_resume();
+}
+
+static mali_scheduler_mask mali_gp_scheduler_queue_job(struct mali_gp_job *job)
+{
+	_mali_osk_list_t *queue = NULL;
+	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
+	struct mali_gp_job *iter, *tmp;
+
+	MALI_DEBUG_ASSERT_POINTER(job);
+	MALI_DEBUG_ASSERT_POINTER(job->session);
+
+	MALI_DEBUG_ASSERT_LOCK_HELD(gp_scheduler_lock);
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE | MALI_PROFILING_EVENT_CHANNEL_SOFTWARE | MALI_PROFILING_EVENT_REASON_SINGLE_SW_GP_ENQUEUE, job->pid, job->tid, job->uargs.frame_builder_id, job->uargs.flush_id, 0);
+
+	job->cache_order = mali_scheduler_get_new_cache_order();
+
+	/* Determine which queue the job should be added to. */
+	if (job->session->use_high_priority_job_queue) {
+		queue = &job_queue_high;
+	} else {
+		queue = &job_queue;
+	}
+
+	/* Find position in queue where job should be added. */
+	_MALI_OSK_LIST_FOREACHENTRY_REVERSE(iter, tmp, queue, struct mali_gp_job, list) {
+		if (mali_gp_job_is_after(job, iter)) {
+			break;
+		}
+	}
+
+	/* Add job to queue. */
+	_mali_osk_list_add(&job->list, &iter->list);
+
+	/* Set schedule bitmask if the GP core is idle. */
+	if (MALI_GP_SLOT_STATE_IDLE == slot.state) {
+		schedule_mask |= MALI_SCHEDULER_MASK_GP;
+	}
+
+#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
+	trace_gpu_job_enqueue(mali_gp_job_get_tid(job), mali_gp_job_get_id(job), "GP");
+#endif
+
+	MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Job %u (0x%08X) queued\n", mali_gp_job_get_id(job), job));
+
+	return schedule_mask;
+}
+
+mali_scheduler_mask mali_gp_scheduler_activate_job(struct mali_gp_job *job)
+{
+	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
+
+	MALI_DEBUG_ASSERT_POINTER(job);
+	MALI_DEBUG_ASSERT_POINTER(job->session);
+
+	MALI_DEBUG_PRINT(4, ("Mali GP scheduler: Timeline activation for job %u (0x%08X).\n", mali_gp_job_get_id(job), job));
+
+	mali_gp_scheduler_lock();
+
+	if (unlikely(job->session->is_aborting)) {
+		/* Before checking if the session is aborting, the scheduler must be locked. */
+		MALI_DEBUG_ASSERT_LOCK_HELD(gp_scheduler_lock);
+
+		MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Job %u (0x%08X) activated while session is aborting.\n", mali_gp_job_get_id(job), job));
+
+		/* This job should not be on any list. */
+		MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
+
+		mali_gp_scheduler_unlock();
+
+		/* Release tracker and delete job. */
+		mali_timeline_tracker_release(&job->tracker);
+		mali_gp_job_signal_pp_tracker(job, MALI_FALSE);
+		mali_gp_job_delete(job);
+		mali_gp_scheduler_job_completed();
+
+		/* Since we are aborting we ignore the scheduler mask. */
+		return MALI_SCHEDULER_MASK_EMPTY;
+	}
+
+	/* GP job is ready to run, queue it. */
+	schedule_mask = mali_gp_scheduler_queue_job(job);
+
+	mali_gp_scheduler_unlock();
+
+	return schedule_mask;
+}
+
+static void mali_gp_scheduler_job_queued(void)
+{
+	/* We hold a PM reference for every job we hold queued (and running) */
+	_mali_osk_pm_dev_ref_add();
+
+	if (mali_utilization_enabled()) {
+		/*
+		 * We cheat a little bit by counting the PP as busy from the time a GP job is queued.
+		 * This will be fine because we only loose the tiny idle gap between jobs, but
+		 * we will instead get less utilization work to do (less locks taken)
+		 */
+		mali_utilization_gp_start();
+	}
+}
+
+static void mali_gp_scheduler_job_completed(void)
+{
+	/* Release the PM reference we got in the mali_gp_scheduler_job_queued() function */
+	_mali_osk_pm_dev_ref_dec();
+
+	if (mali_utilization_enabled()) {
+		mali_utilization_gp_end();
+	}
+}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp_scheduler.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp_scheduler.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_gp_scheduler.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_gp_scheduler.h	2016-04-04 16:25:31.738527000 +0300
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
+ * 
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ * 
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __MALI_GP_SCHEDULER_H__
+#define __MALI_GP_SCHEDULER_H__
+
+#include "mali_osk.h"
+#include "mali_gp_job.h"
+#include "mali_group.h"
+
+_mali_osk_errcode_t mali_gp_scheduler_initialize(void);
+void mali_gp_scheduler_terminate(void);
+
+void mali_gp_scheduler_job_done(struct mali_group *group, struct mali_gp_job *job, mali_bool success);
+void mali_gp_scheduler_oom(struct mali_group *group, struct mali_gp_job *job);
+u32 mali_gp_scheduler_dump_state(char *buf, u32 size);
+
+void mali_gp_scheduler_suspend(void);
+void mali_gp_scheduler_resume(void);
+
+/**
+ * @brief Abort all running and queued GP jobs from session.
+ *
+* This functions aborts all GP jobs from the specified session. Queued jobs are removed from the
+* queue and jobs currently running on a core will be aborted.
+ *
+ * @param session Session that is aborting.
+ */
+void mali_gp_scheduler_abort_session(struct mali_session_data *session);
+
+/**
+ * @brief Reset all groups
+ *
+ * This function resets all groups known by the GP scheuduler. This must be
+ * called after the Mali HW has been powered on in order to reset the HW.
+ */
+void mali_gp_scheduler_reset_all_groups(void);
+
+/**
+ * @brief Zap TLB on all groups with \a session active
+ *
+ * The scheculer will zap the session on all groups it owns.
+ */
+void mali_gp_scheduler_zap_all_active(struct mali_session_data *session);
+
+/**
+ * @brief Re-enable a group that has been disabled with mali_gp_scheduler_disable_group
+ *
+ * If a Mali PMU is present, the group will be powered back on and added back
+ * into the GP scheduler.
+ *
+ * @param group Pointer to the group to enable
+ */
+void mali_gp_scheduler_enable_group(struct mali_group *group);
+
+/**
+ * @brief Disable a group
+ *
+ * The group will be taken out of the GP scheduler and powered off, if a Mali
+ * PMU is present.
+ *
+ * @param group Pointer to the group to disable
+ */
+void mali_gp_scheduler_disable_group(struct mali_group *group);
+
+/**
+ * @brief Used by the Timeline system to queue a GP job.
+ *
+ * @note @ref mali_scheduler_schedule_from_mask() should be called if this function returns non-zero.
+ *
+ * @param job The GP job that is being activated.
+ *
+ * @return A scheduling bitmask that can be used to decide if scheduling is necessary after this
+ * call.
+ */
+mali_scheduler_mask mali_gp_scheduler_activate_job(struct mali_gp_job *job);
+
+/**
+ * @brief Schedule queued jobs on idle cores.
+ */
+void mali_gp_scheduler_schedule(void);
+
+/**
+ * @brief Submit a GP job to the GP scheduler.
+ *
+ * This will add the GP job to the Timeline system.
+ *
+ * @param session Session this job belongs to.
+ * @param job GP job that will be submitted
+ * @return Point on GP timeline for job.
+ */
+mali_timeline_point mali_gp_scheduler_submit_job(struct mali_session_data *session, struct mali_gp_job *job);
+
+#endif /* __MALI_GP_SCHEDULER_H__ */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_group.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_group.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_group.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_group.c	2016-04-04 16:25:31.738527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -7,9 +7,6 @@
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
-
-#include <linux/types.h>
-#include <mach/cpu.h>
 #include "mali_kernel_common.h"
 #include "mali_group.h"
 #include "mali_osk.h"
@@ -24,7 +21,6 @@
 #include "mali_pm_domain.h"
 #include "mali_pm.h"
 #include "mali_executor.h"
-#include <mali_platform.h>
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
 #include <linux/sched.h>
@@ -56,598 +52,598 @@
 static void mali_group_recovery_reset(struct mali_group *group);
 
 struct mali_group *mali_group_create(struct mali_l2_cache_core *core,
-        struct mali_dlbu_core *dlbu,
-        struct mali_bcast_unit *bcast,
-        u32 domain_index)
-{
-    struct mali_group *group = NULL;
-
-    if (mali_global_num_groups >= MALI_MAX_NUMBER_OF_GROUPS) {
-        MALI_PRINT_ERROR(("Mali group: Too many group objects created\n"));
-        return NULL;
-    }
-
-    group = _mali_osk_calloc(1, sizeof(struct mali_group));
-    if (NULL != group) {
-        group->timeout_timer = _mali_osk_timer_init();
-        if (NULL != group->timeout_timer) {
-            _mali_osk_timer_setcallback(group->timeout_timer, mali_group_timeout, (void *)group);
-
-            group->l2_cache_core[0] = core;
-            _mali_osk_list_init(&group->group_list);
-            _mali_osk_list_init(&group->executor_list);
-            _mali_osk_list_init(&group->pm_domain_list);
-            group->bcast_core = bcast;
-            group->dlbu_core = dlbu;
-
-            /* register this object as a part of the correct power domain */
-            if ((NULL != core) || (NULL != dlbu) || (NULL != bcast))
-                group->pm_domain = mali_pm_register_group(domain_index, group);
-
-            mali_global_groups[mali_global_num_groups] = group;
-            mali_global_num_groups++;
-
-            return group;
-        }
-        _mali_osk_free(group);
-    }
+				     struct mali_dlbu_core *dlbu,
+				     struct mali_bcast_unit *bcast,
+				     u32 domain_index)
+{
+	struct mali_group *group = NULL;
+
+	if (mali_global_num_groups >= MALI_MAX_NUMBER_OF_GROUPS) {
+		MALI_PRINT_ERROR(("Mali group: Too many group objects created\n"));
+		return NULL;
+	}
+
+	group = _mali_osk_calloc(1, sizeof(struct mali_group));
+	if (NULL != group) {
+		group->timeout_timer = _mali_osk_timer_init();
+		if (NULL != group->timeout_timer) {
+			_mali_osk_timer_setcallback(group->timeout_timer, mali_group_timeout, (void *)group);
+
+			group->l2_cache_core[0] = core;
+			_mali_osk_list_init(&group->group_list);
+			_mali_osk_list_init(&group->executor_list);
+			_mali_osk_list_init(&group->pm_domain_list);
+			group->bcast_core = bcast;
+			group->dlbu_core = dlbu;
+
+			/* register this object as a part of the correct power domain */
+			if ((NULL != core) || (NULL != dlbu) || (NULL != bcast))
+				group->pm_domain = mali_pm_register_group(domain_index, group);
+
+			mali_global_groups[mali_global_num_groups] = group;
+			mali_global_num_groups++;
+
+			return group;
+		}
+		_mali_osk_free(group);
+	}
 
-    return NULL;
+	return NULL;
 }
 
 void mali_group_delete(struct mali_group *group)
 {
-    u32 i;
+	u32 i;
 
-    MALI_DEBUG_PRINT(4, ("Deleting group %s\n",
-                mali_group_core_description(group)));
+	MALI_DEBUG_PRINT(4, ("Deleting group %s\n",
+			     mali_group_core_description(group)));
 
-    MALI_DEBUG_ASSERT(NULL == group->parent_group);
-    MALI_DEBUG_ASSERT((MALI_GROUP_STATE_INACTIVE == group->state) || ((MALI_GROUP_STATE_ACTIVATION_PENDING == group->state)));
+	MALI_DEBUG_ASSERT(NULL == group->parent_group);
+	MALI_DEBUG_ASSERT((MALI_GROUP_STATE_INACTIVE == group->state) || ((MALI_GROUP_STATE_ACTIVATION_PENDING == group->state)));
 
-    /* Delete the resources that this group owns */
-    if (NULL != group->gp_core) {
-        mali_gp_delete(group->gp_core);
-    }
-
-    if (NULL != group->pp_core) {
-        mali_pp_delete(group->pp_core);
-    }
-
-    if (NULL != group->mmu) {
-        mali_mmu_delete(group->mmu);
-    }
-
-    if (mali_group_is_virtual(group)) {
-        /* Remove all groups from virtual group */
-        struct mali_group *child;
-        struct mali_group *temp;
-
-        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-            child->parent_group = NULL;
-            mali_group_delete(child);
-        }
-
-        mali_dlbu_delete(group->dlbu_core);
-
-        if (NULL != group->bcast_core) {
-            mali_bcast_unit_delete(group->bcast_core);
-        }
-    }
-
-    for (i = 0; i < mali_global_num_groups; i++) {
-        if (mali_global_groups[i] == group) {
-            mali_global_groups[i] = NULL;
-            mali_global_num_groups--;
-
-            if (i != mali_global_num_groups) {
-                /* We removed a group from the middle of the array -- move the last
-                 * group to the current position to close the gap */
-                mali_global_groups[i] = mali_global_groups[mali_global_num_groups];
-                mali_global_groups[mali_global_num_groups] = NULL;
-            }
-
-            break;
-        }
-    }
-
-    if (NULL != group->timeout_timer) {
-        _mali_osk_timer_del(group->timeout_timer);
-        _mali_osk_timer_term(group->timeout_timer);
-    }
-
-    if (NULL != group->bottom_half_work_mmu) {
-        _mali_osk_wq_delete_work(group->bottom_half_work_mmu);
-    }
-
-    if (NULL != group->bottom_half_work_gp) {
-        _mali_osk_wq_delete_work(group->bottom_half_work_gp);
-    }
-
-    if (NULL != group->bottom_half_work_pp) {
-        _mali_osk_wq_delete_work(group->bottom_half_work_pp);
-    }
+	/* Delete the resources that this group owns */
+	if (NULL != group->gp_core) {
+		mali_gp_delete(group->gp_core);
+	}
+
+	if (NULL != group->pp_core) {
+		mali_pp_delete(group->pp_core);
+	}
+
+	if (NULL != group->mmu) {
+		mali_mmu_delete(group->mmu);
+	}
+
+	if (mali_group_is_virtual(group)) {
+		/* Remove all groups from virtual group */
+		struct mali_group *child;
+		struct mali_group *temp;
+
+		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+			child->parent_group = NULL;
+			mali_group_delete(child);
+		}
+
+		mali_dlbu_delete(group->dlbu_core);
+
+		if (NULL != group->bcast_core) {
+			mali_bcast_unit_delete(group->bcast_core);
+		}
+	}
+
+	for (i = 0; i < mali_global_num_groups; i++) {
+		if (mali_global_groups[i] == group) {
+			mali_global_groups[i] = NULL;
+			mali_global_num_groups--;
+
+			if (i != mali_global_num_groups) {
+				/* We removed a group from the middle of the array -- move the last
+				 * group to the current position to close the gap */
+				mali_global_groups[i] = mali_global_groups[mali_global_num_groups];
+				mali_global_groups[mali_global_num_groups] = NULL;
+			}
+
+			break;
+		}
+	}
+
+	if (NULL != group->timeout_timer) {
+		_mali_osk_timer_del(group->timeout_timer);
+		_mali_osk_timer_term(group->timeout_timer);
+	}
+
+	if (NULL != group->bottom_half_work_mmu) {
+		_mali_osk_wq_delete_work(group->bottom_half_work_mmu);
+	}
+
+	if (NULL != group->bottom_half_work_gp) {
+		_mali_osk_wq_delete_work(group->bottom_half_work_gp);
+	}
+
+	if (NULL != group->bottom_half_work_pp) {
+		_mali_osk_wq_delete_work(group->bottom_half_work_pp);
+	}
 
-    _mali_osk_free(group);
+	_mali_osk_free(group);
 }
 
 _mali_osk_errcode_t mali_group_add_mmu_core(struct mali_group *group, struct mali_mmu_core *mmu_core)
 {
-    /* This group object now owns the MMU core object */
-    group->mmu = mmu_core;
-    group->bottom_half_work_mmu = _mali_osk_wq_create_work(mali_group_bottom_half_mmu, group);
-    if (NULL == group->bottom_half_work_mmu) {
-        return _MALI_OSK_ERR_FAULT;
-    }
-    return _MALI_OSK_ERR_OK;
+	/* This group object now owns the MMU core object */
+	group->mmu = mmu_core;
+	group->bottom_half_work_mmu = _mali_osk_wq_create_work(mali_group_bottom_half_mmu, group);
+	if (NULL == group->bottom_half_work_mmu) {
+		return _MALI_OSK_ERR_FAULT;
+	}
+	return _MALI_OSK_ERR_OK;
 }
 
 void mali_group_remove_mmu_core(struct mali_group *group)
 {
-    /* This group object no longer owns the MMU core object */
-    group->mmu = NULL;
-    if (NULL != group->bottom_half_work_mmu) {
-        _mali_osk_wq_delete_work(group->bottom_half_work_mmu);
-    }
+	/* This group object no longer owns the MMU core object */
+	group->mmu = NULL;
+	if (NULL != group->bottom_half_work_mmu) {
+		_mali_osk_wq_delete_work(group->bottom_half_work_mmu);
+	}
 }
 
 _mali_osk_errcode_t mali_group_add_gp_core(struct mali_group *group, struct mali_gp_core *gp_core)
 {
-    /* This group object now owns the GP core object */
-    group->gp_core = gp_core;
-    group->bottom_half_work_gp = _mali_osk_wq_create_work(mali_group_bottom_half_gp, group);
-    if (NULL == group->bottom_half_work_gp) {
-        return _MALI_OSK_ERR_FAULT;
-    }
-    return _MALI_OSK_ERR_OK;
+	/* This group object now owns the GP core object */
+	group->gp_core = gp_core;
+	group->bottom_half_work_gp = _mali_osk_wq_create_work(mali_group_bottom_half_gp, group);
+	if (NULL == group->bottom_half_work_gp) {
+		return _MALI_OSK_ERR_FAULT;
+	}
+	return _MALI_OSK_ERR_OK;
 }
 
 void mali_group_remove_gp_core(struct mali_group *group)
 {
-    /* This group object no longer owns the GP core object */
-    group->gp_core = NULL;
-    if (NULL != group->bottom_half_work_gp) {
-        _mali_osk_wq_delete_work(group->bottom_half_work_gp);
-    }
+	/* This group object no longer owns the GP core object */
+	group->gp_core = NULL;
+	if (NULL != group->bottom_half_work_gp) {
+		_mali_osk_wq_delete_work(group->bottom_half_work_gp);
+	}
 }
 
 _mali_osk_errcode_t mali_group_add_pp_core(struct mali_group *group, struct mali_pp_core *pp_core)
 {
-    /* This group object now owns the PP core object */
-    group->pp_core = pp_core;
-    group->bottom_half_work_pp = _mali_osk_wq_create_work(mali_group_bottom_half_pp, group);
-    if (NULL == group->bottom_half_work_pp) {
-        return _MALI_OSK_ERR_FAULT;
-    }
-    return _MALI_OSK_ERR_OK;
+	/* This group object now owns the PP core object */
+	group->pp_core = pp_core;
+	group->bottom_half_work_pp = _mali_osk_wq_create_work(mali_group_bottom_half_pp, group);
+	if (NULL == group->bottom_half_work_pp) {
+		return _MALI_OSK_ERR_FAULT;
+	}
+	return _MALI_OSK_ERR_OK;
 }
 
 void mali_group_remove_pp_core(struct mali_group *group)
 {
-    /* This group object no longer owns the PP core object */
-    group->pp_core = NULL;
-    if (NULL != group->bottom_half_work_pp) {
-        _mali_osk_wq_delete_work(group->bottom_half_work_pp);
-    }
+	/* This group object no longer owns the PP core object */
+	group->pp_core = NULL;
+	if (NULL != group->bottom_half_work_pp) {
+		_mali_osk_wq_delete_work(group->bottom_half_work_pp);
+	}
 }
 
 enum mali_group_state mali_group_activate(struct mali_group *group)
 {
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
 
-    MALI_DEBUG_PRINT(4, ("Group: Activating group %s\n",
-                mali_group_core_description(group)));
+	MALI_DEBUG_PRINT(4, ("Group: Activating group %s\n",
+			     mali_group_core_description(group)));
 
-    if (MALI_GROUP_STATE_INACTIVE == group->state) {
-        /* Group is inactive, get PM refs in order to power up */
+	if (MALI_GROUP_STATE_INACTIVE == group->state) {
+		/* Group is inactive, get PM refs in order to power up */
 
-        /*
-         * We'll take a maximum of 2 power domain references pr group,
-         * one for the group itself, and one for it's L2 cache.
-         */
-        struct mali_pm_domain *domains[MALI_MAX_NUM_DOMAIN_REFS];
-        struct mali_group *groups[MALI_MAX_NUM_DOMAIN_REFS];
-        u32 num_domains = 0;
-        mali_bool all_groups_on;
-
-        /* Deal with child groups first */
-        if (mali_group_is_virtual(group)) {
-            /*
-             * The virtual group might have 0, 1 or 2 L2s in
-             * its l2_cache_core array, but we ignore these and
-             * let the child groups take the needed L2 cache ref
-             * on behalf of the virtual group.
-             * In other words; The L2 refs are taken in pair with
-             * the physical group which the L2 is attached to.
-             */
-            struct mali_group *child;
-            struct mali_group *temp;
-
-            /*
-             * Child group is inactive, get PM
-             * refs in order to power up.
-             */
-            _MALI_OSK_LIST_FOREACHENTRY(child, temp,
-                    &group->group_list,
-                    struct mali_group, group_list) {
-                MALI_DEBUG_ASSERT(MALI_GROUP_STATE_INACTIVE
-                        == child->state);
-
-                child->state = MALI_GROUP_STATE_ACTIVATION_PENDING;
-
-                MALI_DEBUG_ASSERT_POINTER(
-                        child->pm_domain);
-                domains[num_domains] = child->pm_domain;
-                groups[num_domains] = child;
-                num_domains++;
-
-                /*
-                 * Take L2 domain ref for child group.
-                 */
-                MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS
-                        > num_domains);
-                domains[num_domains] = mali_l2_cache_get_pm_domain(
-                        child->l2_cache_core[0]);
-                groups[num_domains] = NULL;
-                MALI_DEBUG_ASSERT(NULL ==
-                        child->l2_cache_core[1]);
-                num_domains++;
-            }
-        } else {
-            /* Take L2 domain ref for physical groups. */
-            MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
-                    num_domains);
-
-            domains[num_domains] = mali_l2_cache_get_pm_domain(
-                    group->l2_cache_core[0]);
-            groups[num_domains] = NULL;
-            MALI_DEBUG_ASSERT(NULL == group->l2_cache_core[1]);
-            num_domains++;
-        }
-
-        /* Do the group itself last (it's dependencies first) */
-
-        group->state = MALI_GROUP_STATE_ACTIVATION_PENDING;
-
-        MALI_DEBUG_ASSERT_POINTER(group->pm_domain);
-        domains[num_domains] = group->pm_domain;
-        groups[num_domains] = group;
-        num_domains++;
-
-        all_groups_on = mali_pm_get_domain_refs(domains, groups,
-                num_domains);
-
-        /*
-         * Complete activation for group, include
-         * virtual group or physical group.
-         */
-        if (MALI_TRUE == all_groups_on) {
-
-            mali_group_set_active(group);
-        }
-    } else if (MALI_GROUP_STATE_ACTIVE == group->state) {
-        /* Already active */
-        MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
-    } else {
-        /*
-         * Activation already pending, group->power_is_on could
-         * be both true or false. We need to wait for power up
-         * notification anyway.
-         */
-        MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVATION_PENDING
-                == group->state);
-    }
-
-    MALI_DEBUG_PRINT(4, ("Group: group %s activation result: %s\n",
-                mali_group_core_description(group),
-                MALI_GROUP_STATE_ACTIVE == group->state ?
-                "ACTIVE" : "PENDING"));
+		/*
+		 * We'll take a maximum of 2 power domain references pr group,
+		 * one for the group itself, and one for it's L2 cache.
+		 */
+		struct mali_pm_domain *domains[MALI_MAX_NUM_DOMAIN_REFS];
+		struct mali_group *groups[MALI_MAX_NUM_DOMAIN_REFS];
+		u32 num_domains = 0;
+		mali_bool all_groups_on;
+
+		/* Deal with child groups first */
+		if (mali_group_is_virtual(group)) {
+			/*
+			 * The virtual group might have 0, 1 or 2 L2s in
+			 * its l2_cache_core array, but we ignore these and
+			 * let the child groups take the needed L2 cache ref
+			 * on behalf of the virtual group.
+			 * In other words; The L2 refs are taken in pair with
+			 * the physical group which the L2 is attached to.
+			 */
+			struct mali_group *child;
+			struct mali_group *temp;
+
+			/*
+			 * Child group is inactive, get PM
+			 * refs in order to power up.
+			 */
+			_MALI_OSK_LIST_FOREACHENTRY(child, temp,
+						    &group->group_list,
+						    struct mali_group, group_list) {
+				MALI_DEBUG_ASSERT(MALI_GROUP_STATE_INACTIVE
+						  == child->state);
+
+				child->state = MALI_GROUP_STATE_ACTIVATION_PENDING;
+
+				MALI_DEBUG_ASSERT_POINTER(
+					child->pm_domain);
+				domains[num_domains] = child->pm_domain;
+				groups[num_domains] = child;
+				num_domains++;
+
+				/*
+				 * Take L2 domain ref for child group.
+				 */
+				MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS
+						  > num_domains);
+				domains[num_domains] = mali_l2_cache_get_pm_domain(
+							       child->l2_cache_core[0]);
+				groups[num_domains] = NULL;
+				MALI_DEBUG_ASSERT(NULL ==
+						  child->l2_cache_core[1]);
+				num_domains++;
+			}
+		} else {
+			/* Take L2 domain ref for physical groups. */
+			MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
+					  num_domains);
+
+			domains[num_domains] = mali_l2_cache_get_pm_domain(
+						       group->l2_cache_core[0]);
+			groups[num_domains] = NULL;
+			MALI_DEBUG_ASSERT(NULL == group->l2_cache_core[1]);
+			num_domains++;
+		}
+
+		/* Do the group itself last (it's dependencies first) */
+
+		group->state = MALI_GROUP_STATE_ACTIVATION_PENDING;
+
+		MALI_DEBUG_ASSERT_POINTER(group->pm_domain);
+		domains[num_domains] = group->pm_domain;
+		groups[num_domains] = group;
+		num_domains++;
+
+		all_groups_on = mali_pm_get_domain_refs(domains, groups,
+							num_domains);
+
+		/*
+		 * Complete activation for group, include
+		 * virtual group or physical group.
+		 */
+		if (MALI_TRUE == all_groups_on) {
+
+			mali_group_set_active(group);
+		}
+	} else if (MALI_GROUP_STATE_ACTIVE == group->state) {
+		/* Already active */
+		MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
+	} else {
+		/*
+		 * Activation already pending, group->power_is_on could
+		 * be both true or false. We need to wait for power up
+		 * notification anyway.
+		 */
+		MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVATION_PENDING
+				  == group->state);
+	}
+
+	MALI_DEBUG_PRINT(4, ("Group: group %s activation result: %s\n",
+			     mali_group_core_description(group),
+			     MALI_GROUP_STATE_ACTIVE == group->state ?
+			     "ACTIVE" : "PENDING"));
 
-    return group->state;
+	return group->state;
 }
 
 mali_bool mali_group_set_active(struct mali_group *group)
 {
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-    MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVATION_PENDING == group->state);
-    MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
-
-    MALI_DEBUG_PRINT(4, ("Group: Activation completed for %s\n",
-                mali_group_core_description(group)));
-
-    if (mali_group_is_virtual(group)) {
-        struct mali_group *child;
-        struct mali_group *temp;
-
-        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list,
-                struct mali_group, group_list) {
-            if (MALI_TRUE != child->power_is_on) {
-                return MALI_FALSE;
-            }
-
-            child->state = MALI_GROUP_STATE_ACTIVE;
-        }
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVATION_PENDING == group->state);
+	MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
+
+	MALI_DEBUG_PRINT(4, ("Group: Activation completed for %s\n",
+			     mali_group_core_description(group)));
+
+	if (mali_group_is_virtual(group)) {
+		struct mali_group *child;
+		struct mali_group *temp;
+
+		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list,
+					    struct mali_group, group_list) {
+			if (MALI_TRUE != child->power_is_on) {
+				return MALI_FALSE;
+			}
+
+			child->state = MALI_GROUP_STATE_ACTIVE;
+		}
 
-        mali_group_reset(group);
-    }
+		mali_group_reset(group);
+	}
 
-    /* Go to ACTIVE state */
-    group->state = MALI_GROUP_STATE_ACTIVE;
+	/* Go to ACTIVE state */
+	group->state = MALI_GROUP_STATE_ACTIVE;
 
-    return MALI_TRUE;
+	return MALI_TRUE;
 }
 
 mali_bool mali_group_deactivate(struct mali_group *group)
 {
-    struct mali_pm_domain *domains[MALI_MAX_NUM_DOMAIN_REFS];
-    u32 num_domains = 0;
-    mali_bool power_down = MALI_FALSE;
-
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-    MALI_DEBUG_ASSERT(MALI_GROUP_STATE_INACTIVE != group->state);
-
-    MALI_DEBUG_PRINT(3, ("Group: Deactivating group %s\n",
-                mali_group_core_description(group)));
-
-    group->state = MALI_GROUP_STATE_INACTIVE;
-
-    MALI_DEBUG_ASSERT_POINTER(group->pm_domain);
-    domains[num_domains] = group->pm_domain;
-    num_domains++;
-
-    if (mali_group_is_virtual(group)) {
-        /* Release refs for all child groups */
-        struct mali_group *child;
-        struct mali_group *temp;
-
-        _MALI_OSK_LIST_FOREACHENTRY(child, temp,
-                &group->group_list,
-                struct mali_group, group_list) {
-            child->state = MALI_GROUP_STATE_INACTIVE;
-
-            MALI_DEBUG_ASSERT_POINTER(child->pm_domain);
-            domains[num_domains] = child->pm_domain;
-            num_domains++;
-
-            /* Release L2 cache domain for child groups */
-            MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
-                    num_domains);
-            domains[num_domains] = mali_l2_cache_get_pm_domain(
-                    child->l2_cache_core[0]);
-            MALI_DEBUG_ASSERT(NULL == child->l2_cache_core[1]);
-            num_domains++;
-        }
-
-        /*
-         * Must do mali_group_power_down() steps right here for
-         * virtual group, because virtual group itself is likely to
-         * stay powered on, however child groups are now very likely
-         * to be powered off (and thus lose their state).
-         */
-
-        mali_group_clear_session(group);
-        /*
-         * Disable the broadcast unit (clear it's mask).
-         * This is needed in case the GPU isn't actually
-         * powered down at this point and groups are
-         * removed from an inactive virtual group.
-         * If not, then the broadcast unit will intercept
-         * their interrupts!
-         */
-        mali_bcast_disable(group->bcast_core);
-    } else {
-        /* Release L2 cache domain for physical groups */
-        MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
-                num_domains);
-        domains[num_domains] = mali_l2_cache_get_pm_domain(
-                group->l2_cache_core[0]);
-        MALI_DEBUG_ASSERT(NULL == group->l2_cache_core[1]);
-        num_domains++;
-    }
+	struct mali_pm_domain *domains[MALI_MAX_NUM_DOMAIN_REFS];
+	u32 num_domains = 0;
+	mali_bool power_down = MALI_FALSE;
+
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT(MALI_GROUP_STATE_INACTIVE != group->state);
+
+	MALI_DEBUG_PRINT(3, ("Group: Deactivating group %s\n",
+			     mali_group_core_description(group)));
+
+	group->state = MALI_GROUP_STATE_INACTIVE;
+
+	MALI_DEBUG_ASSERT_POINTER(group->pm_domain);
+	domains[num_domains] = group->pm_domain;
+	num_domains++;
+
+	if (mali_group_is_virtual(group)) {
+		/* Release refs for all child groups */
+		struct mali_group *child;
+		struct mali_group *temp;
+
+		_MALI_OSK_LIST_FOREACHENTRY(child, temp,
+					    &group->group_list,
+					    struct mali_group, group_list) {
+			child->state = MALI_GROUP_STATE_INACTIVE;
+
+			MALI_DEBUG_ASSERT_POINTER(child->pm_domain);
+			domains[num_domains] = child->pm_domain;
+			num_domains++;
+
+			/* Release L2 cache domain for child groups */
+			MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
+					  num_domains);
+			domains[num_domains] = mali_l2_cache_get_pm_domain(
+						       child->l2_cache_core[0]);
+			MALI_DEBUG_ASSERT(NULL == child->l2_cache_core[1]);
+			num_domains++;
+		}
+
+		/*
+		 * Must do mali_group_power_down() steps right here for
+		 * virtual group, because virtual group itself is likely to
+		 * stay powered on, however child groups are now very likely
+		 * to be powered off (and thus lose their state).
+		 */
+
+		mali_group_clear_session(group);
+		/*
+		 * Disable the broadcast unit (clear it's mask).
+		 * This is needed in case the GPU isn't actually
+		 * powered down at this point and groups are
+		 * removed from an inactive virtual group.
+		 * If not, then the broadcast unit will intercept
+		 * their interrupts!
+		 */
+		mali_bcast_disable(group->bcast_core);
+	} else {
+		/* Release L2 cache domain for physical groups */
+		MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
+				  num_domains);
+		domains[num_domains] = mali_l2_cache_get_pm_domain(
+					       group->l2_cache_core[0]);
+		MALI_DEBUG_ASSERT(NULL == group->l2_cache_core[1]);
+		num_domains++;
+	}
 
-    power_down = mali_pm_put_domain_refs(domains, num_domains);
+	power_down = mali_pm_put_domain_refs(domains, num_domains);
 
-    return power_down;
+	return power_down;
 }
 
 void mali_group_power_up(struct mali_group *group)
 {
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
 
-    MALI_DEBUG_PRINT(3, ("Group: Power up for %s\n",
-                mali_group_core_description(group)));
+	MALI_DEBUG_PRINT(3, ("Group: Power up for %s\n",
+			     mali_group_core_description(group)));
 
-    group->power_is_on = MALI_TRUE;
+	group->power_is_on = MALI_TRUE;
 
-    if (MALI_FALSE == mali_group_is_virtual(group)
-            && MALI_FALSE == mali_group_is_in_virtual(group)) {
-        mali_group_reset(group);
-    }
-
-    /*
-     * When we just acquire only one physical group form virt group,
-     * we should remove the bcast&dlbu mask from virt group and
-     * reset bcast and dlbu core, although part of pp cores in virt
-     * group maybe not be powered on.
-     */
-    if (MALI_TRUE == mali_group_is_virtual(group)) {
-        mali_bcast_reset(group->bcast_core);
-        mali_dlbu_update_mask(group->dlbu_core);
-    }
+	if (MALI_FALSE == mali_group_is_virtual(group)
+			&& MALI_FALSE == mali_group_is_in_virtual(group)) {
+		mali_group_reset(group);
+	}
+
+	/*
+	 * When we just acquire only one physical group form virt group,
+	 * we should remove the bcast&dlbu mask from virt group and
+	 * reset bcast and dlbu core, although part of pp cores in virt
+	 * group maybe not be powered on.
+	 */
+	if (MALI_TRUE == mali_group_is_virtual(group)) {
+		mali_bcast_reset(group->bcast_core);
+		mali_dlbu_update_mask(group->dlbu_core);
+	}
 }
 
 void mali_group_power_down(struct mali_group *group)
 {
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-    MALI_DEBUG_PRINT(3, ("Group: Power down for %s\n",
-                mali_group_core_description(group)));
-
-    group->power_is_on = MALI_FALSE;
-
-    if (mali_group_is_virtual(group)) {
-        /*
-         * What we do for physical jobs in this function should
-         * already have been done in mali_group_deactivate()
-         * for virtual group.
-         */
-        MALI_DEBUG_ASSERT(NULL == group->session);
-    } else {
-        mali_group_clear_session(group);
-    }
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+	MALI_DEBUG_PRINT(3, ("Group: Power down for %s\n",
+			     mali_group_core_description(group)));
+
+	group->power_is_on = MALI_FALSE;
+
+	if (mali_group_is_virtual(group)) {
+		/*
+		 * What we do for physical jobs in this function should
+		 * already have been done in mali_group_deactivate()
+		 * for virtual group.
+		 */
+		MALI_DEBUG_ASSERT(NULL == group->session);
+	} else {
+		mali_group_clear_session(group);
+	}
 }
 
 MALI_DEBUG_CODE(static void mali_group_print_virtual(struct mali_group *vgroup)
-        {
-        u32 i;
-        struct mali_group *group;
-        struct mali_group *temp;
-
-        MALI_DEBUG_PRINT(4, ("Virtual group %s (%p)\n",
-                mali_group_core_description(vgroup),
-                vgroup));
-        MALI_DEBUG_PRINT(4, ("l2_cache_core[0] = %p, ref = %d\n", vgroup->l2_cache_core[0], vgroup->l2_cache_core_ref_count[0]));
-        MALI_DEBUG_PRINT(4, ("l2_cache_core[1] = %p, ref = %d\n", vgroup->l2_cache_core[1], vgroup->l2_cache_core_ref_count[1]));
-
-        i = 0;
-        _MALI_OSK_LIST_FOREACHENTRY(group, temp, &vgroup->group_list, struct mali_group, group_list) {
-        MALI_DEBUG_PRINT(4, ("[%d] %s (%p), l2_cache_core[0] = %p\n",
-                i, mali_group_core_description(group),
-                group, group->l2_cache_core[0]));
-        i++;
-        }
-        })
+{
+	u32 i;
+	struct mali_group *group;
+	struct mali_group *temp;
+
+	MALI_DEBUG_PRINT(4, ("Virtual group %s (%p)\n",
+			     mali_group_core_description(vgroup),
+			     vgroup));
+	MALI_DEBUG_PRINT(4, ("l2_cache_core[0] = %p, ref = %d\n", vgroup->l2_cache_core[0], vgroup->l2_cache_core_ref_count[0]));
+	MALI_DEBUG_PRINT(4, ("l2_cache_core[1] = %p, ref = %d\n", vgroup->l2_cache_core[1], vgroup->l2_cache_core_ref_count[1]));
+
+	i = 0;
+	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &vgroup->group_list, struct mali_group, group_list) {
+		MALI_DEBUG_PRINT(4, ("[%d] %s (%p), l2_cache_core[0] = %p\n",
+				     i, mali_group_core_description(group),
+				     group, group->l2_cache_core[0]));
+		i++;
+	}
+})
 
 /**
  * @brief Add child group to virtual group parent
  */
 void mali_group_add_group(struct mali_group *parent, struct mali_group *child)
 {
-    mali_bool found;
-    u32 i;
+	mali_bool found;
+	u32 i;
 
-    MALI_DEBUG_PRINT(3, ("Adding group %s to virtual group %s\n",
-                mali_group_core_description(child),
-                mali_group_core_description(parent)));
-
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-    MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
-    MALI_DEBUG_ASSERT(!mali_group_is_virtual(child));
-    MALI_DEBUG_ASSERT(NULL == child->parent_group);
-
-    _mali_osk_list_addtail(&child->group_list, &parent->group_list);
-
-    child->parent_group = parent;
-
-    MALI_DEBUG_ASSERT_POINTER(child->l2_cache_core[0]);
-
-    MALI_DEBUG_PRINT(4, ("parent->l2_cache_core: [0] = %p, [1] = %p\n", parent->l2_cache_core[0], parent->l2_cache_core[1]));
-    MALI_DEBUG_PRINT(4, ("child->l2_cache_core: [0] = %p, [1] = %p\n", child->l2_cache_core[0], child->l2_cache_core[1]));
-
-    /* Keep track of the L2 cache cores of child groups */
-    found = MALI_FALSE;
-    for (i = 0; i < 2; i++) {
-        if (parent->l2_cache_core[i] == child->l2_cache_core[0]) {
-            MALI_DEBUG_ASSERT(parent->l2_cache_core_ref_count[i] > 0);
-            parent->l2_cache_core_ref_count[i]++;
-            found = MALI_TRUE;
-        }
-    }
-
-    if (!found) {
-        /* First time we see this L2 cache, add it to our list */
-        i = (NULL == parent->l2_cache_core[0]) ? 0 : 1;
-
-        MALI_DEBUG_PRINT(4, ("First time we see l2_cache %p. Adding to [%d] = %p\n", child->l2_cache_core[0], i, parent->l2_cache_core[i]));
-
-        MALI_DEBUG_ASSERT(NULL == parent->l2_cache_core[i]);
-
-        parent->l2_cache_core[i] = child->l2_cache_core[0];
-        parent->l2_cache_core_ref_count[i]++;
-    }
-
-    /* Update Broadcast Unit and DLBU */
-    mali_bcast_add_group(parent->bcast_core, child);
-    mali_dlbu_add_group(parent->dlbu_core, child);
-
-    if (MALI_TRUE == parent->power_is_on) {
-        mali_bcast_reset(parent->bcast_core);
-        mali_dlbu_update_mask(parent->dlbu_core);
-    }
-
-    if (MALI_TRUE == child->power_is_on) {
-        if (NULL == parent->session) {
-            if (NULL != child->session) {
-                /*
-                 * Parent has no session, so clear
-                 * child session as well.
-                 */
-                mali_mmu_activate_empty_page_directory(child->mmu);
-            }
-        } else {
-            if (parent->session == child->session) {
-                /* We already have same session as parent,
-                 * so a simple zap should be enough.
-                 */
-                mali_mmu_zap_tlb(child->mmu);
-            } else {
-                /*
-                 * Parent has a different session, so we must
-                 * switch to that sessions page table
-                 */
-                mali_mmu_activate_page_directory(child->mmu, mali_session_get_page_directory(parent->session));
-            }
-
-            /* It is the parent which keeps the session from now on */
-            child->session = NULL;
-        }
-    } else {
-        /* should have been cleared when child was powered down */
-        MALI_DEBUG_ASSERT(NULL == child->session);
-    }
-
-    /* Start job on child when parent is active */
-    if (NULL != parent->pp_running_job) {
-        struct mali_pp_job *job = parent->pp_running_job;
-
-        MALI_DEBUG_PRINT(3, ("Group %x joining running job %d on virtual group %x\n",
-                    child, mali_pp_job_get_id(job), parent));
-
-        /* Only allowed to add active child to an active parent */
-        MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVE == parent->state);
-        MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVE == child->state);
-
-        mali_pp_job_start(child->pp_core, job, mali_pp_core_get_id(child->pp_core), MALI_TRUE);
-
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-                MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-                MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
-                mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
-
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-                MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-                MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
-                mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
+	MALI_DEBUG_PRINT(3, ("Adding group %s to virtual group %s\n",
+			     mali_group_core_description(child),
+			     mali_group_core_description(parent)));
+
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
+	MALI_DEBUG_ASSERT(!mali_group_is_virtual(child));
+	MALI_DEBUG_ASSERT(NULL == child->parent_group);
+
+	_mali_osk_list_addtail(&child->group_list, &parent->group_list);
+
+	child->parent_group = parent;
+
+	MALI_DEBUG_ASSERT_POINTER(child->l2_cache_core[0]);
+
+	MALI_DEBUG_PRINT(4, ("parent->l2_cache_core: [0] = %p, [1] = %p\n", parent->l2_cache_core[0], parent->l2_cache_core[1]));
+	MALI_DEBUG_PRINT(4, ("child->l2_cache_core: [0] = %p, [1] = %p\n", child->l2_cache_core[0], child->l2_cache_core[1]));
+
+	/* Keep track of the L2 cache cores of child groups */
+	found = MALI_FALSE;
+	for (i = 0; i < 2; i++) {
+		if (parent->l2_cache_core[i] == child->l2_cache_core[0]) {
+			MALI_DEBUG_ASSERT(parent->l2_cache_core_ref_count[i] > 0);
+			parent->l2_cache_core_ref_count[i]++;
+			found = MALI_TRUE;
+		}
+	}
+
+	if (!found) {
+		/* First time we see this L2 cache, add it to our list */
+		i = (NULL == parent->l2_cache_core[0]) ? 0 : 1;
+
+		MALI_DEBUG_PRINT(4, ("First time we see l2_cache %p. Adding to [%d] = %p\n", child->l2_cache_core[0], i, parent->l2_cache_core[i]));
+
+		MALI_DEBUG_ASSERT(NULL == parent->l2_cache_core[i]);
+
+		parent->l2_cache_core[i] = child->l2_cache_core[0];
+		parent->l2_cache_core_ref_count[i]++;
+	}
+
+	/* Update Broadcast Unit and DLBU */
+	mali_bcast_add_group(parent->bcast_core, child);
+	mali_dlbu_add_group(parent->dlbu_core, child);
+
+	if (MALI_TRUE == parent->power_is_on) {
+		mali_bcast_reset(parent->bcast_core);
+		mali_dlbu_update_mask(parent->dlbu_core);
+	}
+
+	if (MALI_TRUE == child->power_is_on) {
+		if (NULL == parent->session) {
+			if (NULL != child->session) {
+				/*
+				 * Parent has no session, so clear
+				 * child session as well.
+				 */
+				mali_mmu_activate_empty_page_directory(child->mmu);
+			}
+		} else {
+			if (parent->session == child->session) {
+				/* We already have same session as parent,
+				 * so a simple zap should be enough.
+				 */
+				mali_mmu_zap_tlb(child->mmu);
+			} else {
+				/*
+				 * Parent has a different session, so we must
+				 * switch to that sessions page table
+				 */
+				mali_mmu_activate_page_directory(child->mmu, mali_session_get_page_directory(parent->session));
+			}
+
+			/* It is the parent which keeps the session from now on */
+			child->session = NULL;
+		}
+	} else {
+		/* should have been cleared when child was powered down */
+		MALI_DEBUG_ASSERT(NULL == child->session);
+	}
+
+	/* Start job on child when parent is active */
+	if (NULL != parent->pp_running_job) {
+		struct mali_pp_job *job = parent->pp_running_job;
+
+		MALI_DEBUG_PRINT(3, ("Group %x joining running job %d on virtual group %x\n",
+				     child, mali_pp_job_get_id(job), parent));
+
+		/* Only allowed to add active child to an active parent */
+		MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVE == parent->state);
+		MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVE == child->state);
+
+		mali_pp_job_start(child->pp_core, job, mali_pp_core_get_id(child->pp_core), MALI_TRUE);
+
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+					      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+					      MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
+					      mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
+
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+					      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
+					      mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-        trace_gpu_sched_switch(
-                mali_pp_core_description(group->pp_core),
-                sched_clock(), mali_pp_job_get_tid(job),
-                0, mali_pp_job_get_id(job));
+		trace_gpu_sched_switch(
+			mali_pp_core_description(group->pp_core),
+			sched_clock(), mali_pp_job_get_tid(job),
+			0, mali_pp_job_get_id(job));
 #endif
 
 #if defined(CONFIG_MALI400_PROFILING)
-        trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
-                mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
+		trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
+				       mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
 #endif
-    }
+	}
 
-    MALI_DEBUG_CODE(mali_group_print_virtual(parent);)
+	MALI_DEBUG_CODE(mali_group_print_virtual(parent);)
 }
 
 /**
@@ -655,155 +651,155 @@
  */
 void mali_group_remove_group(struct mali_group *parent, struct mali_group *child)
 {
-    u32 i;
+	u32 i;
 
-    MALI_DEBUG_PRINT(3, ("Removing group %s from virtual group %s\n",
-                mali_group_core_description(child),
-                mali_group_core_description(parent)));
+	MALI_DEBUG_PRINT(3, ("Removing group %s from virtual group %s\n",
+			     mali_group_core_description(child),
+			     mali_group_core_description(parent)));
 
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-    MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
-    MALI_DEBUG_ASSERT(!mali_group_is_virtual(child));
-    MALI_DEBUG_ASSERT(parent == child->parent_group);
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
+	MALI_DEBUG_ASSERT(!mali_group_is_virtual(child));
+	MALI_DEBUG_ASSERT(parent == child->parent_group);
 
-    /* Update Broadcast Unit and DLBU */
-    mali_bcast_remove_group(parent->bcast_core, child);
-    mali_dlbu_remove_group(parent->dlbu_core, child);
+	/* Update Broadcast Unit and DLBU */
+	mali_bcast_remove_group(parent->bcast_core, child);
+	mali_dlbu_remove_group(parent->dlbu_core, child);
 
-    if (MALI_TRUE == parent->power_is_on) {
-        mali_bcast_reset(parent->bcast_core);
-        mali_dlbu_update_mask(parent->dlbu_core);
-    }
+	if (MALI_TRUE == parent->power_is_on) {
+		mali_bcast_reset(parent->bcast_core);
+		mali_dlbu_update_mask(parent->dlbu_core);
+	}
 
-    child->session = parent->session;
-    child->parent_group = NULL;
+	child->session = parent->session;
+	child->parent_group = NULL;
 
-    _mali_osk_list_delinit(&child->group_list);
-    if (_mali_osk_list_empty(&parent->group_list)) {
-        parent->session = NULL;
-    }
+	_mali_osk_list_delinit(&child->group_list);
+	if (_mali_osk_list_empty(&parent->group_list)) {
+		parent->session = NULL;
+	}
 
-    /* Keep track of the L2 cache cores of child groups */
-    i = (child->l2_cache_core[0] == parent->l2_cache_core[0]) ? 0 : 1;
+	/* Keep track of the L2 cache cores of child groups */
+	i = (child->l2_cache_core[0] == parent->l2_cache_core[0]) ? 0 : 1;
 
-    MALI_DEBUG_ASSERT(child->l2_cache_core[0] == parent->l2_cache_core[i]);
+	MALI_DEBUG_ASSERT(child->l2_cache_core[0] == parent->l2_cache_core[i]);
 
-    parent->l2_cache_core_ref_count[i]--;
-    if (parent->l2_cache_core_ref_count[i] == 0) {
-        parent->l2_cache_core[i] = NULL;
-    }
+	parent->l2_cache_core_ref_count[i]--;
+	if (parent->l2_cache_core_ref_count[i] == 0) {
+		parent->l2_cache_core[i] = NULL;
+	}
 
-    MALI_DEBUG_CODE(mali_group_print_virtual(parent));
+	MALI_DEBUG_CODE(mali_group_print_virtual(parent));
 }
 
 struct mali_group *mali_group_acquire_group(struct mali_group *parent)
 {
-    struct mali_group *child = NULL;
+	struct mali_group *child = NULL;
 
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-    MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
 
-    if (!_mali_osk_list_empty(&parent->group_list)) {
-        child = _MALI_OSK_LIST_ENTRY(parent->group_list.prev, struct mali_group, group_list);
-        mali_group_remove_group(parent, child);
-    }
-
-    if (NULL != child) {
-        if (MALI_GROUP_STATE_ACTIVE != parent->state
-                && MALI_TRUE == child->power_is_on) {
-            mali_group_reset(child);
-        }
-    }
+	if (!_mali_osk_list_empty(&parent->group_list)) {
+		child = _MALI_OSK_LIST_ENTRY(parent->group_list.prev, struct mali_group, group_list);
+		mali_group_remove_group(parent, child);
+	}
+
+	if (NULL != child) {
+		if (MALI_GROUP_STATE_ACTIVE != parent->state
+		    && MALI_TRUE == child->power_is_on) {
+			mali_group_reset(child);
+		}
+	}
 
-    return child;
+	return child;
 }
 
 void mali_group_reset(struct mali_group *group)
 {
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-    MALI_DEBUG_ASSERT(NULL == group->gp_running_job);
-    MALI_DEBUG_ASSERT(NULL == group->pp_running_job);
-    MALI_DEBUG_ASSERT(NULL == group->session);
-
-    MALI_DEBUG_PRINT(3, ("Group: reset of %s\n",
-                mali_group_core_description(group)));
-
-    if (NULL != group->dlbu_core) {
-        mali_dlbu_reset(group->dlbu_core);
-    }
-
-    if (NULL != group->bcast_core) {
-        mali_bcast_reset(group->bcast_core);
-    }
-
-    MALI_DEBUG_ASSERT(NULL != group->mmu);
-    mali_group_reset_mmu(group);
-
-    if (NULL != group->gp_core) {
-        MALI_DEBUG_ASSERT(NULL == group->pp_core);
-        mali_gp_reset(group->gp_core);
-    } else {
-        MALI_DEBUG_ASSERT(NULL != group->pp_core);
-        mali_group_reset_pp(group);
-    }
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT(NULL == group->gp_running_job);
+	MALI_DEBUG_ASSERT(NULL == group->pp_running_job);
+	MALI_DEBUG_ASSERT(NULL == group->session);
+
+	MALI_DEBUG_PRINT(3, ("Group: reset of %s\n",
+			     mali_group_core_description(group)));
+
+	if (NULL != group->dlbu_core) {
+		mali_dlbu_reset(group->dlbu_core);
+	}
+
+	if (NULL != group->bcast_core) {
+		mali_bcast_reset(group->bcast_core);
+	}
+
+	MALI_DEBUG_ASSERT(NULL != group->mmu);
+	mali_group_reset_mmu(group);
+
+	if (NULL != group->gp_core) {
+		MALI_DEBUG_ASSERT(NULL == group->pp_core);
+		mali_gp_reset(group->gp_core);
+	} else {
+		MALI_DEBUG_ASSERT(NULL != group->pp_core);
+		mali_group_reset_pp(group);
+	}
 }
 
 void mali_group_start_gp_job(struct mali_group *group, struct mali_gp_job *job)
 {
-    struct mali_session_data *session;
+	struct mali_session_data *session;
 
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
 
-    MALI_DEBUG_PRINT(3, ("Group: Starting GP job 0x%08X on group %s\n",
-                job,
-                mali_group_core_description(group)));
+	MALI_DEBUG_PRINT(3, ("Group: Starting GP job 0x%08X on group %s\n",
+			     job,
+			     mali_group_core_description(group)));
 
-    session = mali_gp_job_get_session(job);
+	session = mali_gp_job_get_session(job);
 
-    MALI_DEBUG_ASSERT_POINTER(group->l2_cache_core[0]);
-    mali_l2_cache_invalidate_conditional(group->l2_cache_core[0], mali_gp_job_get_cache_order(job));
+	MALI_DEBUG_ASSERT_POINTER(group->l2_cache_core[0]);
+	mali_l2_cache_invalidate_conditional(group->l2_cache_core[0], mali_gp_job_get_cache_order(job));
 
-    mali_group_activate_page_directory(group, session);
+	mali_group_activate_page_directory(group, session);
 
-    mali_gp_job_start(group->gp_core, job);
+	mali_gp_job_start(group->gp_core, job);
 
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-            MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0) |
-            MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
-            mali_gp_job_get_frame_builder_id(job), mali_gp_job_get_flush_id(job), 0, 0, 0);
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-            MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
-            mali_gp_job_get_pid(job), mali_gp_job_get_tid(job), 0, 0, 0);
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+				      MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0) |
+				      MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
+				      mali_gp_job_get_frame_builder_id(job), mali_gp_job_get_flush_id(job), 0, 0, 0);
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+				      MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
+				      mali_gp_job_get_pid(job), mali_gp_job_get_tid(job), 0, 0, 0);
 
 #if defined(CONFIG_MALI400_PROFILING)
-    trace_mali_core_active(mali_gp_job_get_pid(job), 1 /* active */, 1 /* GP */,  0 /* core */,
-            mali_gp_job_get_frame_builder_id(job), mali_gp_job_get_flush_id(job));
+	trace_mali_core_active(mali_gp_job_get_pid(job), 1 /* active */, 1 /* GP */,  0 /* core */,
+			       mali_gp_job_get_frame_builder_id(job), mali_gp_job_get_flush_id(job));
 #endif
 
 #if defined(CONFIG_MALI400_PROFILING)
-    if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-            (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-        mali_group_report_l2_cache_counters_per_core(group, 0);
-    }
+	if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+	    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+		mali_group_report_l2_cache_counters_per_core(group, 0);
+	}
 #endif /* #if defined(CONFIG_MALI400_PROFILING) */
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-    trace_gpu_sched_switch(mali_gp_core_description(group->gp_core),
-            sched_clock(), mali_gp_job_get_tid(job),
-            0, mali_gp_job_get_id(job));
-#endif
-
-    group->gp_running_job = job;
-    group->is_working = MALI_TRUE;
-
-    /* Setup SW timer and record start time */
-    group->start_time = _mali_osk_time_tickcount();
-    _mali_osk_timer_mod(group->timeout_timer, _mali_osk_time_mstoticks(mali_max_job_runtime));
-
-    MALI_DEBUG_PRINT(4, ("Group: Started GP job 0x%08X on group %s at %u\n",
-                job,
-                mali_group_core_description(group),
-                group->start_time));
+	trace_gpu_sched_switch(mali_gp_core_description(group->gp_core),
+			       sched_clock(), mali_gp_job_get_tid(job),
+			       0, mali_gp_job_get_id(job));
+#endif
+
+	group->gp_running_job = job;
+	group->is_working = MALI_TRUE;
+
+	/* Setup SW timer and record start time */
+	group->start_time = _mali_osk_time_tickcount();
+	_mali_osk_timer_mod(group->timeout_timer, _mali_osk_time_mstoticks(mali_max_job_runtime));
+
+	MALI_DEBUG_PRINT(4, ("Group: Started GP job 0x%08X on group %s at %u\n",
+			     job,
+			     mali_group_core_description(group),
+			     group->start_time));
 }
 
 /* Used to set all the registers except frame renderer list address and fragment shader stack address
@@ -811,925 +807,847 @@
  */
 void mali_group_start_pp_job(struct mali_group *group, struct mali_pp_job *job, u32 sub_job)
 {
-    struct mali_session_data *session;
+	struct mali_session_data *session;
 
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
 
-    MALI_DEBUG_PRINT(3, ("Group: Starting PP job 0x%08X part %u/%u on group %s\n",
-                job, sub_job + 1,
-                mali_pp_job_get_sub_job_count(job),
-                mali_group_core_description(group)));
-
-    session = mali_pp_job_get_session(job);
-
-    if (NULL != group->l2_cache_core[0]) {
-        mali_l2_cache_invalidate_conditional(group->l2_cache_core[0], mali_pp_job_get_cache_order(job));
-    }
-
-    if (NULL != group->l2_cache_core[1]) {
-        mali_l2_cache_invalidate_conditional(group->l2_cache_core[1], mali_pp_job_get_cache_order(job));
-    }
-
-    mali_group_activate_page_directory(group, session);
-
-    if (mali_group_is_virtual(group)) {
-        struct mali_group *child;
-        struct mali_group *temp;
-        u32 core_num = 0;
-
-        MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(job));
-
-        /* Configure DLBU for the job */
-        mali_dlbu_config_job(group->dlbu_core, job);
-
-        /* Write stack address for each child group */
-        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-            mali_pp_write_addr_stack(child->pp_core, job);
-            core_num++;
-        }
-
-        mali_pp_job_start(group->pp_core, job, sub_job, MALI_FALSE);
-    } else {
-        mali_pp_job_start(group->pp_core, job, sub_job, MALI_FALSE);
-    }
-
-    /* if the group is virtual, loop through physical groups which belong to this group
-     * and call profiling events for its cores as virtual */
-    if (MALI_TRUE == mali_group_is_virtual(group)) {
-        struct mali_group *child;
-        struct mali_group *temp;
-
-        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-            _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-                    MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-                    MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
-                    mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
-
-            _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-                    MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-                    MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
-                    mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
+	MALI_DEBUG_PRINT(3, ("Group: Starting PP job 0x%08X part %u/%u on group %s\n",
+			     job, sub_job + 1,
+			     mali_pp_job_get_sub_job_count(job),
+			     mali_group_core_description(group)));
+
+	session = mali_pp_job_get_session(job);
+
+	if (NULL != group->l2_cache_core[0]) {
+		mali_l2_cache_invalidate_conditional(group->l2_cache_core[0], mali_pp_job_get_cache_order(job));
+	}
+
+	if (NULL != group->l2_cache_core[1]) {
+		mali_l2_cache_invalidate_conditional(group->l2_cache_core[1], mali_pp_job_get_cache_order(job));
+	}
+
+	mali_group_activate_page_directory(group, session);
+
+	if (mali_group_is_virtual(group)) {
+		struct mali_group *child;
+		struct mali_group *temp;
+		u32 core_num = 0;
+
+		MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(job));
+
+		/* Configure DLBU for the job */
+		mali_dlbu_config_job(group->dlbu_core, job);
+
+		/* Write stack address for each child group */
+		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+			mali_pp_write_addr_stack(child->pp_core, job);
+			core_num++;
+		}
+
+		mali_pp_job_start(group->pp_core, job, sub_job, MALI_FALSE);
+	} else {
+		mali_pp_job_start(group->pp_core, job, sub_job, MALI_FALSE);
+	}
+
+	/* if the group is virtual, loop through physical groups which belong to this group
+	 * and call profiling events for its cores as virtual */
+	if (MALI_TRUE == mali_group_is_virtual(group)) {
+		struct mali_group *child;
+		struct mali_group *temp;
+
+		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+			_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+						      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+						      MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
+						      mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
+
+			_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+						      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+						      MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
+						      mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
 
 #if defined(CONFIG_MALI400_PROFILING)
-            trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
-                    mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
+			trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
+					       mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
 #endif
-        }
+		}
 
 #if defined(CONFIG_MALI400_PROFILING)
-        if (0 != group->l2_cache_core_ref_count[0]) {
-            if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-                    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-                mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
-            }
-        }
-        if (0 != group->l2_cache_core_ref_count[1]) {
-            if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[1])) &&
-                    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[1]))) {
-                mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[1]));
-            }
-        }
+		if (0 != group->l2_cache_core_ref_count[0]) {
+			if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+			    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+				mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
+			}
+		}
+		if (0 != group->l2_cache_core_ref_count[1]) {
+			if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[1])) &&
+			    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[1]))) {
+				mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[1]));
+			}
+		}
 #endif /* #if defined(CONFIG_MALI400_PROFILING) */
 
-    } else { /* group is physical - call profiling events for physical cores */
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-                MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
-                MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
-                mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
-
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-                MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
-                MALI_PROFILING_EVENT_REASON_START_STOP_HW_PHYSICAL,
-                mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
+	} else { /* group is physical - call profiling events for physical cores */
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+					      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
+					      MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
+					      mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
+
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+					      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_HW_PHYSICAL,
+					      mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
 
 #if defined(CONFIG_MALI400_PROFILING)
-        trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(group->pp_core),
-                mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
+		trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(group->pp_core),
+				       mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
 #endif
 
 #if defined(CONFIG_MALI400_PROFILING)
-        if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-                (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-            mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
-        }
+		if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+		    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+			mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
+		}
 #endif /* #if defined(CONFIG_MALI400_PROFILING) */
-    }
+	}
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-    trace_gpu_sched_switch(mali_pp_core_description(group->pp_core),
-            sched_clock(), mali_pp_job_get_tid(job),
-            0, mali_pp_job_get_id(job));
-#endif
-
-    group->pp_running_job = job;
-    group->pp_running_sub_job = sub_job;
-    group->is_working = MALI_TRUE;
-
-    /* Setup SW timer and record start time */
-    group->start_time = _mali_osk_time_tickcount();
-    _mali_osk_timer_mod(group->timeout_timer, _mali_osk_time_mstoticks(mali_max_job_runtime));
-
-    MALI_DEBUG_PRINT(4, ("Group: Started PP job 0x%08X part %u/%u on group %s at %u\n",
-                job, sub_job + 1,
-                mali_pp_job_get_sub_job_count(job),
-                mali_group_core_description(group),
-                group->start_time));
+	trace_gpu_sched_switch(mali_pp_core_description(group->pp_core),
+			       sched_clock(), mali_pp_job_get_tid(job),
+			       0, mali_pp_job_get_id(job));
+#endif
+
+	group->pp_running_job = job;
+	group->pp_running_sub_job = sub_job;
+	group->is_working = MALI_TRUE;
+
+	/* Setup SW timer and record start time */
+	group->start_time = _mali_osk_time_tickcount();
+	_mali_osk_timer_mod(group->timeout_timer, _mali_osk_time_mstoticks(mali_max_job_runtime));
+
+	MALI_DEBUG_PRINT(4, ("Group: Started PP job 0x%08X part %u/%u on group %s at %u\n",
+			     job, sub_job + 1,
+			     mali_pp_job_get_sub_job_count(job),
+			     mali_group_core_description(group),
+			     group->start_time));
 
 }
 
 void mali_group_resume_gp_with_new_heap(struct mali_group *group, u32 job_id, u32 start_addr, u32 end_addr)
 {
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
 
-    MALI_DEBUG_ASSERT_POINTER(group->l2_cache_core[0]);
-    mali_l2_cache_invalidate(group->l2_cache_core[0]);
+	MALI_DEBUG_ASSERT_POINTER(group->l2_cache_core[0]);
+	mali_l2_cache_invalidate(group->l2_cache_core[0]);
 
-    mali_mmu_zap_tlb_without_stall(group->mmu);
+	mali_mmu_zap_tlb_without_stall(group->mmu);
 
-    mali_gp_resume_with_new_heap(group->gp_core, start_addr, end_addr);
+	mali_gp_resume_with_new_heap(group->gp_core, start_addr, end_addr);
 
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_RESUME |
-            MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
-            0, 0, 0, 0, 0);
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_RESUME |
+				      MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
+				      0, 0, 0, 0, 0);
 
 #if defined(CONFIG_MALI400_PROFILING)
-    trace_mali_core_active(mali_gp_job_get_pid(group->gp_running_job), 1 /* active */, 1 /* GP */,  0 /* core */,
-            mali_gp_job_get_frame_builder_id(group->gp_running_job), mali_gp_job_get_flush_id(group->gp_running_job));
+	trace_mali_core_active(mali_gp_job_get_pid(group->gp_running_job), 1 /* active */, 1 /* GP */,  0 /* core */,
+			       mali_gp_job_get_frame_builder_id(group->gp_running_job), mali_gp_job_get_flush_id(group->gp_running_job));
 #endif
 }
 
 static void mali_group_reset_mmu(struct mali_group *group)
 {
-    struct mali_group *child;
-    struct mali_group *temp;
-    _mali_osk_errcode_t err;
-
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-    if (!mali_group_is_virtual(group)) {
-        /* This is a physical group or an idle virtual group -- simply wait for
-         * the reset to complete. */
-        err = mali_mmu_reset(group->mmu);
-        MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
-    } else { /* virtual group */
-        /* Loop through all members of this virtual group and wait
-         * until they are done resetting.
-         */
-        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-            err = mali_mmu_reset(child->mmu);
-            MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
-        }
-    }
+	struct mali_group *child;
+	struct mali_group *temp;
+	_mali_osk_errcode_t err;
+
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+	if (!mali_group_is_virtual(group)) {
+		/* This is a physical group or an idle virtual group -- simply wait for
+		 * the reset to complete. */
+		err = mali_mmu_reset(group->mmu);
+		MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
+	} else { /* virtual group */
+		/* Loop through all members of this virtual group and wait
+		 * until they are done resetting.
+		 */
+		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+			err = mali_mmu_reset(child->mmu);
+			MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
+		}
+	}
 }
 
 static void mali_group_reset_pp(struct mali_group *group)
 {
-    struct mali_group *child;
-    struct mali_group *temp;
+	struct mali_group *child;
+	struct mali_group *temp;
 
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
 
-    mali_pp_reset_async(group->pp_core);
+	mali_pp_reset_async(group->pp_core);
 
-    if (!mali_group_is_virtual(group) || NULL == group->pp_running_job) {
-        /* This is a physical group or an idle virtual group -- simply wait for
-         * the reset to complete. */
-        mali_pp_reset_wait(group->pp_core);
-    } else {
-        /* Loop through all members of this virtual group and wait until they
-         * are done resetting.
-         */
-        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-            mali_pp_reset_wait(child->pp_core);
-        }
-    }
+	if (!mali_group_is_virtual(group) || NULL == group->pp_running_job) {
+		/* This is a physical group or an idle virtual group -- simply wait for
+		 * the reset to complete. */
+		mali_pp_reset_wait(group->pp_core);
+	} else {
+		/* Loop through all members of this virtual group and wait until they
+		 * are done resetting.
+		 */
+		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+			mali_pp_reset_wait(child->pp_core);
+		}
+	}
 }
 
 struct mali_pp_job *mali_group_complete_pp(struct mali_group *group, mali_bool success, u32 *sub_job)
 {
-    struct mali_pp_job *pp_job_to_return;
+	struct mali_pp_job *pp_job_to_return;
 
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-    MALI_DEBUG_ASSERT_POINTER(group->pp_running_job);
-    MALI_DEBUG_ASSERT_POINTER(sub_job);
-    MALI_DEBUG_ASSERT(MALI_TRUE == group->is_working);
-
-    /* Stop/clear the timeout timer. */
-    _mali_osk_timer_del_async(group->timeout_timer);
-
-    if (NULL != group->pp_running_job) {
-
-        /* Deal with HW counters and profiling */
-
-        if (MALI_TRUE == mali_group_is_virtual(group)) {
-            struct mali_group *child;
-            struct mali_group *temp;
-
-            /* update performance counters from each physical pp core within this virtual group */
-            _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-                mali_pp_update_performance_counters(group->pp_core, child->pp_core, group->pp_running_job, mali_pp_core_get_id(child->pp_core));
-            }
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+	MALI_DEBUG_ASSERT_POINTER(group->pp_running_job);
+	MALI_DEBUG_ASSERT_POINTER(sub_job);
+	MALI_DEBUG_ASSERT(MALI_TRUE == group->is_working);
+
+	/* Stop/clear the timeout timer. */
+	_mali_osk_timer_del_async(group->timeout_timer);
+
+	if (NULL != group->pp_running_job) {
+
+		/* Deal with HW counters and profiling */
+
+		if (MALI_TRUE == mali_group_is_virtual(group)) {
+			struct mali_group *child;
+			struct mali_group *temp;
+
+			/* update performance counters from each physical pp core within this virtual group */
+			_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+				mali_pp_update_performance_counters(group->pp_core, child->pp_core, group->pp_running_job, mali_pp_core_get_id(child->pp_core));
+			}
 
 #if defined(CONFIG_MALI400_PROFILING)
-            /* send profiling data per physical core */
-            _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-                _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-                        MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-                        MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
-                        mali_pp_job_get_perf_counter_value0(group->pp_running_job, mali_pp_core_get_id(child->pp_core)),
-                        mali_pp_job_get_perf_counter_value1(group->pp_running_job, mali_pp_core_get_id(child->pp_core)),
-                        mali_pp_job_get_perf_counter_src0(group->pp_running_job, group->pp_running_sub_job) | (mali_pp_job_get_perf_counter_src1(group->pp_running_job, group->pp_running_sub_job) << 8),
-                        0, 0);
-
-                trace_mali_core_active(mali_pp_job_get_pid(group->pp_running_job),
-                        0 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
-                        mali_pp_job_get_frame_builder_id(group->pp_running_job),
-                        mali_pp_job_get_flush_id(group->pp_running_job));
-            }
-            if (0 != group->l2_cache_core_ref_count[0]) {
-                if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-                        (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-                    mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
-                }
-            }
-            if (0 != group->l2_cache_core_ref_count[1]) {
-                if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[1])) &&
-                        (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[1]))) {
-                    mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[1]));
-                }
-            }
-
-#endif
-        } else {
-            /* update performance counters for a physical group's pp core */
-            mali_pp_update_performance_counters(group->pp_core, group->pp_core, group->pp_running_job, group->pp_running_sub_job);
+			/* send profiling data per physical core */
+			_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+				_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+							      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+							      MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
+							      mali_pp_job_get_perf_counter_value0(group->pp_running_job, mali_pp_core_get_id(child->pp_core)),
+							      mali_pp_job_get_perf_counter_value1(group->pp_running_job, mali_pp_core_get_id(child->pp_core)),
+							      mali_pp_job_get_perf_counter_src0(group->pp_running_job, group->pp_running_sub_job) | (mali_pp_job_get_perf_counter_src1(group->pp_running_job, group->pp_running_sub_job) << 8),
+							      0, 0);
+
+				trace_mali_core_active(mali_pp_job_get_pid(group->pp_running_job),
+						       0 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
+						       mali_pp_job_get_frame_builder_id(group->pp_running_job),
+						       mali_pp_job_get_flush_id(group->pp_running_job));
+			}
+			if (0 != group->l2_cache_core_ref_count[0]) {
+				if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+				    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+					mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
+				}
+			}
+			if (0 != group->l2_cache_core_ref_count[1]) {
+				if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[1])) &&
+				    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[1]))) {
+					mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[1]));
+				}
+			}
+
+#endif
+		} else {
+			/* update performance counters for a physical group's pp core */
+			mali_pp_update_performance_counters(group->pp_core, group->pp_core, group->pp_running_job, group->pp_running_sub_job);
 
 #if defined(CONFIG_MALI400_PROFILING)
-            _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-                    MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
-                    MALI_PROFILING_EVENT_REASON_START_STOP_HW_PHYSICAL,
-                    mali_pp_job_get_perf_counter_value0(group->pp_running_job, group->pp_running_sub_job),
-                    mali_pp_job_get_perf_counter_value1(group->pp_running_job, group->pp_running_sub_job),
-                    mali_pp_job_get_perf_counter_src0(group->pp_running_job, group->pp_running_sub_job) | (mali_pp_job_get_perf_counter_src1(group->pp_running_job, group->pp_running_sub_job) << 8),
-                    0, 0);
-
-            trace_mali_core_active(mali_pp_job_get_pid(group->pp_running_job),
-                    0 /* active */, 0 /* PP */, mali_pp_core_get_id(group->pp_core),
-                    mali_pp_job_get_frame_builder_id(group->pp_running_job),
-                    mali_pp_job_get_flush_id(group->pp_running_job));
-
-            if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-                    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-                mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
-            }
+			_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+						      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
+						      MALI_PROFILING_EVENT_REASON_START_STOP_HW_PHYSICAL,
+						      mali_pp_job_get_perf_counter_value0(group->pp_running_job, group->pp_running_sub_job),
+						      mali_pp_job_get_perf_counter_value1(group->pp_running_job, group->pp_running_sub_job),
+						      mali_pp_job_get_perf_counter_src0(group->pp_running_job, group->pp_running_sub_job) | (mali_pp_job_get_perf_counter_src1(group->pp_running_job, group->pp_running_sub_job) << 8),
+						      0, 0);
+
+			trace_mali_core_active(mali_pp_job_get_pid(group->pp_running_job),
+					       0 /* active */, 0 /* PP */, mali_pp_core_get_id(group->pp_core),
+					       mali_pp_job_get_frame_builder_id(group->pp_running_job),
+					       mali_pp_job_get_flush_id(group->pp_running_job));
+
+			if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+			    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+				mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
+			}
 #endif
-        }
+		}
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-        trace_gpu_sched_switch(
-                mali_gp_core_description(group->gp_core),
-                sched_clock(), 0, 0, 0);
-#endif
-
-    }
-
-    if (success) {
-        /* Only do soft reset for successful jobs, a full recovery
-         * reset will be done for failed jobs. */
-        mali_pp_reset_async(group->pp_core);
-    }
-
-    pp_job_to_return = group->pp_running_job;
-    group->pp_running_job = NULL;
-    group->is_working = MALI_FALSE;
-    *sub_job = group->pp_running_sub_job;
-
-    if (!success) {
-        MALI_DEBUG_PRINT(2, ("Mali group: Executing recovery reset due to job failure\n"));
-        mali_group_recovery_reset(group);
-    } else if (_MALI_OSK_ERR_OK != mali_pp_reset_wait(group->pp_core)) {
-        MALI_PRINT_ERROR(("Mali group: Executing recovery reset due to reset failure\n"));
-        mali_group_recovery_reset(group);
-    }
+		trace_gpu_sched_switch(
+			mali_gp_core_description(group->gp_core),
+			sched_clock(), 0, 0, 0);
+#endif
+
+	}
+
+	if (success) {
+		/* Only do soft reset for successful jobs, a full recovery
+		 * reset will be done for failed jobs. */
+		mali_pp_reset_async(group->pp_core);
+	}
+
+	pp_job_to_return = group->pp_running_job;
+	group->pp_running_job = NULL;
+	group->is_working = MALI_FALSE;
+	*sub_job = group->pp_running_sub_job;
+
+	if (!success) {
+		MALI_DEBUG_PRINT(2, ("Mali group: Executing recovery reset due to job failure\n"));
+		mali_group_recovery_reset(group);
+	} else if (_MALI_OSK_ERR_OK != mali_pp_reset_wait(group->pp_core)) {
+		MALI_PRINT_ERROR(("Mali group: Executing recovery reset due to reset failure\n"));
+		mali_group_recovery_reset(group);
+	}
 
-    return pp_job_to_return;
+	return pp_job_to_return;
 }
 
 struct mali_gp_job *mali_group_complete_gp(struct mali_group *group, mali_bool success)
 {
-    struct mali_gp_job *gp_job_to_return;
+	struct mali_gp_job *gp_job_to_return;
 
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_POINTER(group->gp_core);
-    MALI_DEBUG_ASSERT_POINTER(group->gp_running_job);
-    MALI_DEBUG_ASSERT(MALI_TRUE == group->is_working);
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(group->gp_core);
+	MALI_DEBUG_ASSERT_POINTER(group->gp_running_job);
+	MALI_DEBUG_ASSERT(MALI_TRUE == group->is_working);
 
-    /* Stop/clear the timeout timer. */
-    _mali_osk_timer_del_async(group->timeout_timer);
+	/* Stop/clear the timeout timer. */
+	_mali_osk_timer_del_async(group->timeout_timer);
 
-    if (NULL != group->gp_running_job) {
-        mali_gp_update_performance_counters(group->gp_core, group->gp_running_job);
+	if (NULL != group->gp_running_job) {
+		mali_gp_update_performance_counters(group->gp_core, group->gp_running_job);
 
 #if defined(CONFIG_MALI400_PROFILING)
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP | MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
-                mali_gp_job_get_perf_counter_value0(group->gp_running_job),
-                mali_gp_job_get_perf_counter_value1(group->gp_running_job),
-                mali_gp_job_get_perf_counter_src0(group->gp_running_job) | (mali_gp_job_get_perf_counter_src1(group->gp_running_job) << 8),
-                0, 0);
-
-        if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-                (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0])))
-            mali_group_report_l2_cache_counters_per_core(group, 0);
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP | MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
+					      mali_gp_job_get_perf_counter_value0(group->gp_running_job),
+					      mali_gp_job_get_perf_counter_value1(group->gp_running_job),
+					      mali_gp_job_get_perf_counter_src0(group->gp_running_job) | (mali_gp_job_get_perf_counter_src1(group->gp_running_job) << 8),
+					      0, 0);
+
+		if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+		    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0])))
+			mali_group_report_l2_cache_counters_per_core(group, 0);
 #endif
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-        trace_gpu_sched_switch(
-                mali_pp_core_description(group->pp_core),
-                sched_clock(), 0, 0, 0);
+		trace_gpu_sched_switch(
+			mali_pp_core_description(group->pp_core),
+			sched_clock(), 0, 0, 0);
 #endif
 
 #if defined(CONFIG_MALI400_PROFILING)
-        trace_mali_core_active(mali_gp_job_get_pid(group->gp_running_job), 0 /* active */, 1 /* GP */,  0 /* core */,
-                mali_gp_job_get_frame_builder_id(group->gp_running_job), mali_gp_job_get_flush_id(group->gp_running_job));
+		trace_mali_core_active(mali_gp_job_get_pid(group->gp_running_job), 0 /* active */, 1 /* GP */,  0 /* core */,
+				       mali_gp_job_get_frame_builder_id(group->gp_running_job), mali_gp_job_get_flush_id(group->gp_running_job));
 #endif
 
-        mali_gp_job_set_current_heap_addr(group->gp_running_job,
-                mali_gp_read_plbu_alloc_start_addr(group->gp_core));
-    }
-
-    if (success) {
-        /* Only do soft reset for successful jobs, a full recovery
-         * reset will be done for failed jobs. */
-        mali_gp_reset_async(group->gp_core);
-    }
-
-    gp_job_to_return = group->gp_running_job;
-    group->gp_running_job = NULL;
-    group->is_working = MALI_FALSE;
-
-    if (!success) {
-        MALI_DEBUG_PRINT(2, ("Mali group: Executing recovery reset due to job failure\n"));
-        mali_group_recovery_reset(group);
-    } else if (_MALI_OSK_ERR_OK != mali_gp_reset_wait(group->gp_core)) {
-        MALI_PRINT_ERROR(("Mali group: Executing recovery reset due to reset failure\n"));
-        mali_group_recovery_reset(group);
-    }
+		mali_gp_job_set_current_heap_addr(group->gp_running_job,
+						  mali_gp_read_plbu_alloc_start_addr(group->gp_core));
+	}
+
+	if (success) {
+		/* Only do soft reset for successful jobs, a full recovery
+		 * reset will be done for failed jobs. */
+		mali_gp_reset_async(group->gp_core);
+	}
+
+	gp_job_to_return = group->gp_running_job;
+	group->gp_running_job = NULL;
+	group->is_working = MALI_FALSE;
+
+	if (!success) {
+		MALI_DEBUG_PRINT(2, ("Mali group: Executing recovery reset due to job failure\n"));
+		mali_group_recovery_reset(group);
+	} else if (_MALI_OSK_ERR_OK != mali_gp_reset_wait(group->gp_core)) {
+		MALI_PRINT_ERROR(("Mali group: Executing recovery reset due to reset failure\n"));
+		mali_group_recovery_reset(group);
+	}
 
-    return gp_job_to_return;
+	return gp_job_to_return;
 }
 
 struct mali_group *mali_group_get_glob_group(u32 index)
 {
-    if (mali_global_num_groups > index) {
-        return mali_global_groups[index];
-    }
+	if (mali_global_num_groups > index) {
+		return mali_global_groups[index];
+	}
 
-    return NULL;
+	return NULL;
 }
 
 u32 mali_group_get_glob_num_groups(void)
 {
-    return mali_global_num_groups;
+	return mali_global_num_groups;
 }
 
 static void mali_group_activate_page_directory(struct mali_group *group, struct mali_session_data *session)
 {
-    MALI_DEBUG_PRINT(5, ("Mali group: Activating page directory 0x%08X from session 0x%08X on group %s\n",
-                mali_session_get_page_directory(session), session,
-                mali_group_core_description(group)));
-
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-    if (group->session != session) {
-        /* Different session than last time, so we need to do some work */
-        MALI_DEBUG_PRINT(5, ("Mali group: Activate session: %08x previous: %08x on group %s\n",
-                    session, group->session,
-                    mali_group_core_description(group)));
-        mali_mmu_activate_page_directory(group->mmu, mali_session_get_page_directory(session));
-        group->session = session;
-    } else {
-        /* Same session as last time, so no work required */
-        MALI_DEBUG_PRINT(4, ("Mali group: Activate existing session 0x%08X on group %s\n",
-                    session->page_directory,
-                    mali_group_core_description(group)));
-        mali_mmu_zap_tlb_without_stall(group->mmu);
-    }
+	MALI_DEBUG_PRINT(5, ("Mali group: Activating page directory 0x%08X from session 0x%08X on group %s\n",
+			     mali_session_get_page_directory(session), session,
+			     mali_group_core_description(group)));
+
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+	if (group->session != session) {
+		/* Different session than last time, so we need to do some work */
+		MALI_DEBUG_PRINT(5, ("Mali group: Activate session: %08x previous: %08x on group %s\n",
+				     session, group->session,
+				     mali_group_core_description(group)));
+		mali_mmu_activate_page_directory(group->mmu, mali_session_get_page_directory(session));
+		group->session = session;
+	} else {
+		/* Same session as last time, so no work required */
+		MALI_DEBUG_PRINT(4, ("Mali group: Activate existing session 0x%08X on group %s\n",
+				     session->page_directory,
+				     mali_group_core_description(group)));
+		mali_mmu_zap_tlb_without_stall(group->mmu);
+	}
 }
 
 static void mali_group_recovery_reset(struct mali_group *group)
 {
-    _mali_osk_errcode_t err;
+	_mali_osk_errcode_t err;
 
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
 
-    /* Stop cores, bus stop */
-    if (NULL != group->pp_core) {
-        mali_pp_stop_bus(group->pp_core);
-    } else {
-        mali_gp_stop_bus(group->gp_core);
-    }
-
-    /* Flush MMU and clear page fault (if any) */
-    mali_mmu_activate_fault_flush_page_directory(group->mmu);
-    mali_mmu_page_fault_done(group->mmu);
-
-    /* Wait for cores to stop bus, then do a hard reset on them */
-    if (NULL != group->pp_core) {
-        if (mali_group_is_virtual(group)) {
-            struct mali_group *child, *temp;
-
-            /* Disable the broadcast unit while we do reset directly on the member cores. */
-            mali_bcast_disable(group->bcast_core);
-
-            _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-                mali_pp_stop_bus_wait(child->pp_core);
-                mali_pp_hard_reset(child->pp_core);
-            }
-
-            mali_bcast_enable(group->bcast_core);
-        } else {
-            mali_pp_stop_bus_wait(group->pp_core);
-            mali_pp_hard_reset(group->pp_core);
-        }
-    } else {
-        mali_gp_stop_bus_wait(group->gp_core);
-        mali_gp_hard_reset(group->gp_core);
-    }
-
-    /* Reset MMU */
-    err = mali_mmu_reset(group->mmu);
-    MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
-    MALI_IGNORE(err);
+	/* Stop cores, bus stop */
+	if (NULL != group->pp_core) {
+		mali_pp_stop_bus(group->pp_core);
+	} else {
+		mali_gp_stop_bus(group->gp_core);
+	}
+
+	/* Flush MMU and clear page fault (if any) */
+	mali_mmu_activate_fault_flush_page_directory(group->mmu);
+	mali_mmu_page_fault_done(group->mmu);
+
+	/* Wait for cores to stop bus, then do a hard reset on them */
+	if (NULL != group->pp_core) {
+		if (mali_group_is_virtual(group)) {
+			struct mali_group *child, *temp;
+
+			/* Disable the broadcast unit while we do reset directly on the member cores. */
+			mali_bcast_disable(group->bcast_core);
+
+			_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+				mali_pp_stop_bus_wait(child->pp_core);
+				mali_pp_hard_reset(child->pp_core);
+			}
+
+			mali_bcast_enable(group->bcast_core);
+		} else {
+			mali_pp_stop_bus_wait(group->pp_core);
+			mali_pp_hard_reset(group->pp_core);
+		}
+	} else {
+		mali_gp_stop_bus_wait(group->gp_core);
+		mali_gp_hard_reset(group->gp_core);
+	}
+
+	/* Reset MMU */
+	err = mali_mmu_reset(group->mmu);
+	MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
+	MALI_IGNORE(err);
 
-    group->session = NULL;
+	group->session = NULL;
 }
 
 #if MALI_STATE_TRACKING
 u32 mali_group_dump_state(struct mali_group *group, char *buf, u32 size)
 {
-    int n = 0;
-    int i;
-    struct mali_group *child;
-    struct mali_group *temp;
-
-    if (mali_group_is_virtual(group)) {
-        n += _mali_osk_snprintf(buf + n, size - n,
-                "Virtual PP Group: %p\n", group);
-    } else if (mali_group_is_in_virtual(group)) {
-        n += _mali_osk_snprintf(buf + n, size - n,
-                "Child PP Group: %p\n", group);
-    } else if (NULL != group->pp_core) {
-        n += _mali_osk_snprintf(buf + n, size - n,
-                "Physical PP Group: %p\n", group);
-    } else {
-        MALI_DEBUG_ASSERT_POINTER(group->gp_core);
-        n += _mali_osk_snprintf(buf + n, size - n,
-                "GP Group: %p\n", group);
-    }
-
-    switch (group->state) {
-        case MALI_GROUP_STATE_INACTIVE:
-            n += _mali_osk_snprintf(buf + n, size - n,
-                    "\tstate: INACTIVE\n");
-            break;
-        case MALI_GROUP_STATE_ACTIVATION_PENDING:
-            n += _mali_osk_snprintf(buf + n, size - n,
-                    "\tstate: ACTIVATION_PENDING\n");
-            break;
-        case MALI_GROUP_STATE_ACTIVE:
-            n += _mali_osk_snprintf(buf + n, size - n,
-                    "\tstate: MALI_GROUP_STATE_ACTIVE\n");
-            break;
-        default:
-            n += _mali_osk_snprintf(buf + n, size - n,
-                    "\tstate: UNKNOWN (%d)\n", group->state);
-            MALI_DEBUG_ASSERT(0);
-            break;
-    }
-
-    n += _mali_osk_snprintf(buf + n, size - n,
-            "\tSW power: %s\n",
-            group->power_is_on ? "On" : "Off");
-
-    n += mali_pm_dump_state_domain(group->pm_domain, buf + n, size - n);
-
-    for (i = 0; i < 2; i++) {
-        if (NULL != group->l2_cache_core[i]) {
-            struct mali_pm_domain *domain;
-            domain = mali_l2_cache_get_pm_domain(
-                    group->l2_cache_core[i]);
-            n += mali_pm_dump_state_domain(domain,
-                    buf + n, size - n);
-        }
-    }
-
-    if (group->gp_core) {
-        n += mali_gp_dump_state(group->gp_core, buf + n, size - n);
-        n += _mali_osk_snprintf(buf + n, size - n,
-                "\tGP running job: %p\n", group->gp_running_job);
-    }
-
-    if (group->pp_core) {
-        n += mali_pp_dump_state(group->pp_core, buf + n, size - n);
-        n += _mali_osk_snprintf(buf + n, size - n,
-                "\tPP running job: %p, subjob %d \n",
-                group->pp_running_job,
-                group->pp_running_sub_job);
-    }
-
-    _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list,
-            struct mali_group, group_list) {
-        n += mali_group_dump_state(child, buf + n, size - n);
-    }
+	int n = 0;
+	int i;
+	struct mali_group *child;
+	struct mali_group *temp;
+
+	if (mali_group_is_virtual(group)) {
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"Virtual PP Group: %p\n", group);
+	} else if (mali_group_is_in_virtual(group)) {
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"Child PP Group: %p\n", group);
+	} else if (NULL != group->pp_core) {
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"Physical PP Group: %p\n", group);
+	} else {
+		MALI_DEBUG_ASSERT_POINTER(group->gp_core);
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"GP Group: %p\n", group);
+	}
+
+	switch (group->state) {
+	case MALI_GROUP_STATE_INACTIVE:
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"\tstate: INACTIVE\n");
+		break;
+	case MALI_GROUP_STATE_ACTIVATION_PENDING:
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"\tstate: ACTIVATION_PENDING\n");
+		break;
+	case MALI_GROUP_STATE_ACTIVE:
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"\tstate: MALI_GROUP_STATE_ACTIVE\n");
+		break;
+	default:
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"\tstate: UNKNOWN (%d)\n", group->state);
+		MALI_DEBUG_ASSERT(0);
+		break;
+	}
+
+	n += _mali_osk_snprintf(buf + n, size - n,
+				"\tSW power: %s\n",
+				group->power_is_on ? "On" : "Off");
+
+	n += mali_pm_dump_state_domain(group->pm_domain, buf + n, size - n);
+
+	for (i = 0; i < 2; i++) {
+		if (NULL != group->l2_cache_core[i]) {
+			struct mali_pm_domain *domain;
+			domain = mali_l2_cache_get_pm_domain(
+					 group->l2_cache_core[i]);
+			n += mali_pm_dump_state_domain(domain,
+						       buf + n, size - n);
+		}
+	}
+
+	if (group->gp_core) {
+		n += mali_gp_dump_state(group->gp_core, buf + n, size - n);
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"\tGP running job: %p\n", group->gp_running_job);
+	}
+
+	if (group->pp_core) {
+		n += mali_pp_dump_state(group->pp_core, buf + n, size - n);
+		n += _mali_osk_snprintf(buf + n, size - n,
+					"\tPP running job: %p, subjob %d \n",
+					group->pp_running_job,
+					group->pp_running_sub_job);
+	}
+
+	_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list,
+				    struct mali_group, group_list) {
+		n += mali_group_dump_state(child, buf + n, size - n);
+	}
 
-    return n;
+	return n;
 }
 #endif
 
-/* Kasin added. */
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-#include <platform/meson_m400/mali_fix.h>
-#define INT_MALI_PP2_MMU ( 6+32)
-struct _mali_osk_irq_t_struct;
-u32 get_irqnum(struct _mali_osk_irq_t_struct* irq);
-#endif
-
 _mali_osk_errcode_t mali_group_upper_half_mmu(void *data)
 {
-    struct mali_group *group = (struct mali_group *)data;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    struct mali_mmu_core *mmu = group->mmu;
-#endif
-    _mali_osk_errcode_t ret;
-
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_POINTER(group->mmu);
+	struct mali_group *group = (struct mali_group *)data;
+	_mali_osk_errcode_t ret;
 
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    if (MALI_FALSE == group->power_is_on)
-        MALI_SUCCESS;
-    if (get_irqnum(mmu->irq) == INT_MALI_PP2_MMU)
-    {
-        if (group == NULL || group->pp_core == NULL)
-            MALI_SUCCESS;
-        if (group->pp_core->core_id == 0) {
-            if (malifix_get_mmu_int_process_state(0) == MMU_INT_HIT)
-                malifix_set_mmu_int_process_state(0, MMU_INT_TOP);
-            else
-                MALI_SUCCESS;
-        }
-        else if (group->pp_core->core_id == 1) {
-            if (malifix_get_mmu_int_process_state(1) == MMU_INT_HIT)
-                malifix_set_mmu_int_process_state(1, MMU_INT_TOP);
-            else
-                MALI_SUCCESS;
-        } else
-            MALI_SUCCESS;
-    }
-#endif
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(group->mmu);
 
-    if (NULL != group->gp_core) {
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-                MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-                0, 0, /* No pid and tid for interrupt handler */
-                MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
-                mali_mmu_get_rawstat(group->mmu), 0);
-    } else {
-        MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-                MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-                0, 0, /* No pid and tid for interrupt handler */
-                MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
-                    mali_pp_core_get_id(group->pp_core)),
-                mali_mmu_get_rawstat(group->mmu), 0);
-    }
-
-    ret = mali_executor_interrupt_mmu(group, MALI_TRUE);
-
-    if (NULL != group->gp_core) {
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-                MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-                0, 0, /* No pid and tid for interrupt handler */
-                MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
-                mali_mmu_get_rawstat(group->mmu), 0);
-    } else {
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-                MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-                0, 0, /* No pid and tid for interrupt handler */
-                MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
-                    mali_pp_core_get_id(group->pp_core)),
-                mali_mmu_get_rawstat(group->mmu), 0);
-    }
+	if (NULL != group->gp_core) {
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+					      0, 0, /* No pid and tid for interrupt handler */
+					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
+					      mali_mmu_get_rawstat(group->mmu), 0);
+	} else {
+		MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+					      0, 0, /* No pid and tid for interrupt handler */
+					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
+						      mali_pp_core_get_id(group->pp_core)),
+					      mali_mmu_get_rawstat(group->mmu), 0);
+	}
+
+	ret = mali_executor_interrupt_mmu(group, MALI_TRUE);
+
+	if (NULL != group->gp_core) {
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+					      0, 0, /* No pid and tid for interrupt handler */
+					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
+					      mali_mmu_get_rawstat(group->mmu), 0);
+	} else {
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+					      0, 0, /* No pid and tid for interrupt handler */
+					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
+						      mali_pp_core_get_id(group->pp_core)),
+					      mali_mmu_get_rawstat(group->mmu), 0);
+	}
 
-    return ret;
+	return ret;
 }
 
 static void mali_group_bottom_half_mmu(void *data)
 {
-    struct mali_group *group = (struct mali_group *)data;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    struct mali_mmu_core *mmu = group->mmu;
-#endif
+	struct mali_group *group = (struct mali_group *)data;
 
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_POINTER(group->mmu);
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(group->mmu);
 
-    if (NULL != group->gp_core) {
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-                MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-                0, _mali_osk_get_tid(), /* pid and tid */
-                MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
-                mali_mmu_get_rawstat(group->mmu), 0);
-    } else {
-        MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-                MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-                0, _mali_osk_get_tid(), /* pid and tid */
-                MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
-                    mali_pp_core_get_id(group->pp_core)),
-                mali_mmu_get_rawstat(group->mmu), 0);
-    }
-
-    mali_executor_interrupt_mmu(group, MALI_FALSE);
-
-    if (NULL != group->gp_core) {
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-                MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-                0, _mali_osk_get_tid(), /* pid and tid */
-                MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
-                mali_mmu_get_rawstat(group->mmu), 0);
-    } else {
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-                MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-                0, _mali_osk_get_tid(), /* pid and tid */
-                MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
-                    mali_pp_core_get_id(group->pp_core)),
-                mali_mmu_get_rawstat(group->mmu), 0);
-    }
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    if (get_irqnum(mmu->irq) == INT_MALI_PP2_MMU)
-    {
-        if (group->pp_core->core_id == 0) {
-            if (malifix_get_mmu_int_process_state(0) == MMU_INT_TOP)
-                malifix_set_mmu_int_process_state(0, MMU_INT_NONE);
-        }
-        else if (group->pp_core->core_id == 1) {
-            if (malifix_get_mmu_int_process_state(1) == MMU_INT_TOP)
-                malifix_set_mmu_int_process_state(1, MMU_INT_NONE);
-        }
-    }
-#endif
+	if (NULL != group->gp_core) {
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+					      0, _mali_osk_get_tid(), /* pid and tid */
+					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
+					      mali_mmu_get_rawstat(group->mmu), 0);
+	} else {
+		MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+					      0, _mali_osk_get_tid(), /* pid and tid */
+					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
+						      mali_pp_core_get_id(group->pp_core)),
+					      mali_mmu_get_rawstat(group->mmu), 0);
+	}
+
+	mali_executor_interrupt_mmu(group, MALI_FALSE);
+
+	if (NULL != group->gp_core) {
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+					      0, _mali_osk_get_tid(), /* pid and tid */
+					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
+					      mali_mmu_get_rawstat(group->mmu), 0);
+	} else {
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+					      0, _mali_osk_get_tid(), /* pid and tid */
+					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
+						      mali_pp_core_get_id(group->pp_core)),
+					      mali_mmu_get_rawstat(group->mmu), 0);
+	}
 }
 
 _mali_osk_errcode_t mali_group_upper_half_gp(void *data)
 {
-    struct mali_group *group = (struct mali_group *)data;
-    _mali_osk_errcode_t ret;
+	struct mali_group *group = (struct mali_group *)data;
+	_mali_osk_errcode_t ret;
 
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_POINTER(group->gp_core);
-    MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-            MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-            0, 0, /* No pid and tid for interrupt handler */
-            MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
-            mali_gp_get_rawstat(group->gp_core), 0);
-
-    MALI_DEBUG_PRINT(4, ("Group: Interrupt 0x%08X from %s\n",
-                mali_gp_get_rawstat(group->gp_core),
-                mali_group_core_description(group)));
-
-    ret = mali_executor_interrupt_gp(group, MALI_TRUE);
-
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-            MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-            0, 0, /* No pid and tid for interrupt handler */
-            MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
-            mali_gp_get_rawstat(group->gp_core), 0);
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(group->gp_core);
+	MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+				      0, 0, /* No pid and tid for interrupt handler */
+				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
+				      mali_gp_get_rawstat(group->gp_core), 0);
+
+	MALI_DEBUG_PRINT(4, ("Group: Interrupt 0x%08X from %s\n",
+			     mali_gp_get_rawstat(group->gp_core),
+			     mali_group_core_description(group)));
+
+	ret = mali_executor_interrupt_gp(group, MALI_TRUE);
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+				      0, 0, /* No pid and tid for interrupt handler */
+				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
+				      mali_gp_get_rawstat(group->gp_core), 0);
 
-    return ret;
+	return ret;
 }
 
 static void mali_group_bottom_half_gp(void *data)
 {
-    struct mali_group *group = (struct mali_group *)data;
-
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_POINTER(group->gp_core);
-    MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-            MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-            0, _mali_osk_get_tid(), /* pid and tid */
-            MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
-            mali_gp_get_rawstat(group->gp_core), 0);
-
-    mali_executor_interrupt_gp(group, MALI_FALSE);
-
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-            MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-            0, _mali_osk_get_tid(), /* pid and tid */
-            MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
-            mali_gp_get_rawstat(group->gp_core), 0);
-}
-
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-int PP0_int_cnt = 0;
-int mali_PP0_int_cnt(void)
-{
-    return PP0_int_cnt;
-}
-EXPORT_SYMBOL(mali_PP0_int_cnt);
+	struct mali_group *group = (struct mali_group *)data;
 
-int PP1_int_cnt = 0;
-int mali_PP1_int_cnt(void)
-{
-    return PP1_int_cnt;
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(group->gp_core);
+	MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+				      0, _mali_osk_get_tid(), /* pid and tid */
+				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
+				      mali_gp_get_rawstat(group->gp_core), 0);
+
+	mali_executor_interrupt_gp(group, MALI_FALSE);
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+				      0, _mali_osk_get_tid(), /* pid and tid */
+				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
+				      mali_gp_get_rawstat(group->gp_core), 0);
 }
-EXPORT_SYMBOL(mali_PP1_int_cnt);
-#endif
 
 _mali_osk_errcode_t mali_group_upper_half_pp(void *data)
 {
-    struct mali_group *group = (struct mali_group *)data;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    struct mali_pp_core *core = group->pp_core;
-#endif
-    _mali_osk_errcode_t ret;
-
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-    MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-            MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-            0, 0, /* No pid and tid for interrupt handler */
-            MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
-                mali_pp_core_get_id(group->pp_core)),
-            mali_pp_get_rawstat(group->pp_core), 0);
-
-    MALI_DEBUG_PRINT(4, ("Group: Interrupt 0x%08X from %s\n",
-                mali_pp_get_rawstat(group->pp_core),
-                mali_group_core_description(group)));
-
-    ret = mali_executor_interrupt_pp(group, MALI_TRUE);
-
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    if (core->core_id == 0)
-        PP0_int_cnt++;
-    else if (core->core_id == 1)
-        PP1_int_cnt++;
-#endif
+	struct mali_group *group = (struct mali_group *)data;
+	_mali_osk_errcode_t ret;
 
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-            MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-            0, 0, /* No pid and tid for interrupt handler */
-            MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
-                mali_pp_core_get_id(group->pp_core)),
-            mali_pp_get_rawstat(group->pp_core), 0);
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+	MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+				      0, 0, /* No pid and tid for interrupt handler */
+				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
+					      mali_pp_core_get_id(group->pp_core)),
+				      mali_pp_get_rawstat(group->pp_core), 0);
+
+	MALI_DEBUG_PRINT(4, ("Group: Interrupt 0x%08X from %s\n",
+			     mali_pp_get_rawstat(group->pp_core),
+			     mali_group_core_description(group)));
+
+	ret = mali_executor_interrupt_pp(group, MALI_TRUE);
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+				      0, 0, /* No pid and tid for interrupt handler */
+				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
+					      mali_pp_core_get_id(group->pp_core)),
+				      mali_pp_get_rawstat(group->pp_core), 0);
 
-    return ret;
+	return ret;
 }
 
 static void mali_group_bottom_half_pp(void *data)
 {
-    struct mali_group *group = (struct mali_group *)data;
+	struct mali_group *group = (struct mali_group *)data;
 
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-    MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-            MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-            0, _mali_osk_get_tid(), /* pid and tid */
-            MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
-                mali_pp_core_get_id(group->pp_core)),
-            mali_pp_get_rawstat(group->pp_core), 0);
-
-    mali_executor_interrupt_pp(group, MALI_FALSE);
-
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-            MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-            0, _mali_osk_get_tid(), /* pid and tid */
-            MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
-                mali_pp_core_get_id(group->pp_core)),
-            mali_pp_get_rawstat(group->pp_core), 0);
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+	MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+				      0, _mali_osk_get_tid(), /* pid and tid */
+				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
+					      mali_pp_core_get_id(group->pp_core)),
+				      mali_pp_get_rawstat(group->pp_core), 0);
+
+	mali_executor_interrupt_pp(group, MALI_FALSE);
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+				      0, _mali_osk_get_tid(), /* pid and tid */
+				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
+					      mali_pp_core_get_id(group->pp_core)),
+				      mali_pp_get_rawstat(group->pp_core), 0);
 }
 
 static void mali_group_timeout(void *data)
 {
-    struct mali_group *group = (struct mali_group *)data;
-    MALI_DEBUG_ASSERT_POINTER(group);
+	struct mali_group *group = (struct mali_group *)data;
+	MALI_DEBUG_ASSERT_POINTER(group);
 
-    MALI_DEBUG_PRINT(2, ("Group: timeout handler for %s at %u\n",
-                mali_group_core_description(group),
-                _mali_osk_time_tickcount()));
-
-    if (mali_core_timeout < 65533)
-        mali_core_timeout++;
-    if (NULL != group->gp_core) {
-        mali_group_schedule_bottom_half_gp(group);
-    } else {
-        MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-        mali_group_schedule_bottom_half_pp(group);
-    }
+	MALI_DEBUG_PRINT(2, ("Group: timeout handler for %s at %u\n",
+			     mali_group_core_description(group),
+			     _mali_osk_time_tickcount()));
+
+	if (NULL != group->gp_core) {
+		mali_group_schedule_bottom_half_gp(group);
+	} else {
+		MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+		mali_group_schedule_bottom_half_pp(group);
+	}
 }
 
 mali_bool mali_group_zap_session(struct mali_group *group,
-        struct mali_session_data *session)
+				 struct mali_session_data *session)
 {
-    MALI_DEBUG_ASSERT_POINTER(group);
-    MALI_DEBUG_ASSERT_POINTER(session);
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-    if (group->session != session) {
-        /* not running from this session */
-        return MALI_TRUE; /* success */
-    }
-
-    if (group->is_working) {
-        /* The Zap also does the stall and disable_stall */
-        mali_bool zap_success = mali_mmu_zap_tlb(group->mmu);
-        return zap_success;
-    } else {
-        /* Just remove the session instead of zapping */
-        mali_group_clear_session(group);
-        return MALI_TRUE; /* success */
-    }
+	MALI_DEBUG_ASSERT_POINTER(group);
+	MALI_DEBUG_ASSERT_POINTER(session);
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+	if (group->session != session) {
+		/* not running from this session */
+		return MALI_TRUE; /* success */
+	}
+
+	if (group->is_working) {
+		/* The Zap also does the stall and disable_stall */
+		mali_bool zap_success = mali_mmu_zap_tlb(group->mmu);
+		return zap_success;
+	} else {
+		/* Just remove the session instead of zapping */
+		mali_group_clear_session(group);
+		return MALI_TRUE; /* success */
+	}
 }
 
 #if defined(CONFIG_MALI400_PROFILING)
 static void mali_group_report_l2_cache_counters_per_core(struct mali_group *group, u32 core_num)
 {
-    u32 source0 = 0;
-    u32 value0 = 0;
-    u32 source1 = 0;
-    u32 value1 = 0;
-    u32 profiling_channel = 0;
-
-    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-    switch (core_num) {
-        case 0:
-            profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
-                MALI_PROFILING_EVENT_CHANNEL_GPU |
-                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L20_COUNTERS;
-            break;
-        case 1:
-            profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
-                MALI_PROFILING_EVENT_CHANNEL_GPU |
-                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L21_COUNTERS;
-            break;
-        case 2:
-            profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
-                MALI_PROFILING_EVENT_CHANNEL_GPU |
-                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L22_COUNTERS;
-            break;
-        default:
-            profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
-                MALI_PROFILING_EVENT_CHANNEL_GPU |
-                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L20_COUNTERS;
-            break;
-    }
-
-    if (0 == core_num) {
-        mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
-    }
-    if (1 == core_num) {
-        if (1 == mali_l2_cache_get_id(group->l2_cache_core[0])) {
-            mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
-        } else if (1 == mali_l2_cache_get_id(group->l2_cache_core[1])) {
-            mali_l2_cache_core_get_counter_values(group->l2_cache_core[1], &source0, &value0, &source1, &value1);
-        }
-    }
-    if (2 == core_num) {
-        if (2 == mali_l2_cache_get_id(group->l2_cache_core[0])) {
-            mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
-        } else if (2 == mali_l2_cache_get_id(group->l2_cache_core[1])) {
-            mali_l2_cache_core_get_counter_values(group->l2_cache_core[1], &source0, &value0, &source1, &value1);
-        }
-    }
+	u32 source0 = 0;
+	u32 value0 = 0;
+	u32 source1 = 0;
+	u32 value1 = 0;
+	u32 profiling_channel = 0;
+
+	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+	switch (core_num) {
+	case 0:
+		profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
+				    MALI_PROFILING_EVENT_CHANNEL_GPU |
+				    MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L20_COUNTERS;
+		break;
+	case 1:
+		profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
+				    MALI_PROFILING_EVENT_CHANNEL_GPU |
+				    MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L21_COUNTERS;
+		break;
+	case 2:
+		profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
+				    MALI_PROFILING_EVENT_CHANNEL_GPU |
+				    MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L22_COUNTERS;
+		break;
+	default:
+		profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
+				    MALI_PROFILING_EVENT_CHANNEL_GPU |
+				    MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L20_COUNTERS;
+		break;
+	}
+
+	if (0 == core_num) {
+		mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
+	}
+	if (1 == core_num) {
+		if (1 == mali_l2_cache_get_id(group->l2_cache_core[0])) {
+			mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
+		} else if (1 == mali_l2_cache_get_id(group->l2_cache_core[1])) {
+			mali_l2_cache_core_get_counter_values(group->l2_cache_core[1], &source0, &value0, &source1, &value1);
+		}
+	}
+	if (2 == core_num) {
+		if (2 == mali_l2_cache_get_id(group->l2_cache_core[0])) {
+			mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
+		} else if (2 == mali_l2_cache_get_id(group->l2_cache_core[1])) {
+			mali_l2_cache_core_get_counter_values(group->l2_cache_core[1], &source0, &value0, &source1, &value1);
+		}
+	}
 
-    _mali_osk_profiling_add_event(profiling_channel, source1 << 8 | source0, value0, value1, 0, 0);
+	_mali_osk_profiling_add_event(profiling_channel, source1 << 8 | source0, value0, value1, 0, 0);
 }
 #endif /* #if defined(CONFIG_MALI400_PROFILING) */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_group.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_group.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_group.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_group.h	2016-04-04 16:25:31.768527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_hw_core.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_hw_core.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_hw_core.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_hw_core.c	2016-04-04 16:25:31.778527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_hw_core.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_hw_core.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_hw_core.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_hw_core.h	2016-04-04 16:25:31.788527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_common.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_common.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_common.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_common.h	2016-04-04 16:25:31.798527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_core.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_core.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_core.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_core.c	2016-04-04 16:25:31.808527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -622,7 +622,7 @@
 		}
 
 		if (MALI_SHARED_MEMORY_DEFAULT_SIZE == mali_shared_mem_size &&
-		    0 != data.shared_mem_size) {
+				0 != data.shared_mem_size) {
 			mali_shared_mem_size = data.shared_mem_size;
 		}
 	}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_core.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_core.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_core.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_core.h	2016-04-04 16:25:31.828527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_descriptor_mapping.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_descriptor_mapping.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_descriptor_mapping.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_descriptor_mapping.c	2016-04-04 16:25:31.838527000 +0300
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
+ * 
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ * 
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "mali_kernel_common.h"
+#include "mali_kernel_descriptor_mapping.h"
+#include "mali_osk.h"
+#include "mali_osk_bitops.h"
+#include "mali_memory_types.h"
+#include "mali_session.h"
+
+#define MALI_PAD_INT(x) (((x) + (BITS_PER_LONG - 1)) & ~(BITS_PER_LONG - 1))
+
+/**
+ * Allocate a descriptor table capable of holding 'count' mappings
+ * @param count Number of mappings in the table
+ * @return Pointer to a new table, NULL on error
+ */
+static mali_descriptor_table *descriptor_table_alloc(int count);
+
+/**
+ * Free a descriptor table
+ * @param table The table to free
+ */
+static void descriptor_table_free(mali_descriptor_table *table);
+
+mali_descriptor_mapping *mali_descriptor_mapping_create(int init_entries, int max_entries)
+{
+	mali_descriptor_mapping *map = _mali_osk_calloc(1, sizeof(mali_descriptor_mapping));
+
+	init_entries = MALI_PAD_INT(init_entries);
+	max_entries = MALI_PAD_INT(max_entries);
+
+	if (NULL != map) {
+		map->table = descriptor_table_alloc(init_entries);
+		if (NULL != map->table) {
+			map->lock = _mali_osk_mutex_rw_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_DESCRIPTOR_MAP);
+			if (NULL != map->lock) {
+				_mali_osk_set_nonatomic_bit(0, map->table->usage); /* reserve bit 0 to prevent NULL/zero logic to kick in */
+				map->max_nr_mappings_allowed = max_entries;
+				map->current_nr_mappings = init_entries;
+				return map;
+			}
+			descriptor_table_free(map->table);
+		}
+		_mali_osk_free(map);
+	}
+	return NULL;
+}
+
+void mali_descriptor_mapping_destroy(mali_descriptor_mapping *map)
+{
+	descriptor_table_free(map->table);
+	_mali_osk_mutex_rw_term(map->lock);
+	_mali_osk_free(map);
+}
+
+_mali_osk_errcode_t mali_descriptor_mapping_allocate_mapping(mali_descriptor_mapping *map, void *target, int *odescriptor)
+{
+	_mali_osk_errcode_t err = _MALI_OSK_ERR_FAULT;
+	int new_descriptor;
+	mali_mem_allocation *descriptor;
+	struct mali_session_data *session;
+
+	MALI_DEBUG_ASSERT_POINTER(map);
+	MALI_DEBUG_ASSERT_POINTER(odescriptor);
+	MALI_DEBUG_ASSERT_POINTER(target);
+
+	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RW);
+	new_descriptor = _mali_osk_find_first_zero_bit(map->table->usage, map->current_nr_mappings);
+	if (new_descriptor == map->current_nr_mappings) {
+		/* no free descriptor, try to expand the table */
+		mali_descriptor_table *new_table, * old_table;
+		if (map->current_nr_mappings >= map->max_nr_mappings_allowed) goto unlock_and_exit;
+
+		map->current_nr_mappings += BITS_PER_LONG;
+		new_table = descriptor_table_alloc(map->current_nr_mappings);
+		if (NULL == new_table) goto unlock_and_exit;
+
+		old_table = map->table;
+		_mali_osk_memcpy(new_table->usage, old_table->usage, (sizeof(unsigned long)*map->current_nr_mappings) / BITS_PER_LONG);
+		_mali_osk_memcpy(new_table->mappings, old_table->mappings, map->current_nr_mappings * sizeof(void *));
+		map->table = new_table;
+		descriptor_table_free(old_table);
+	}
+
+	/* we have found a valid descriptor, set the value and usage bit */
+	_mali_osk_set_nonatomic_bit(new_descriptor, map->table->usage);
+	map->table->mappings[new_descriptor] = target;
+	*odescriptor = new_descriptor;
+
+	/* To calculate the mali mem usage for the session */
+	descriptor = (mali_mem_allocation *)target;
+	session = descriptor->session;
+
+	MALI_DEBUG_ASSERT_POINTER(session);
+
+	session->mali_mem_array[descriptor->type] += descriptor->size;
+	if ((MALI_MEM_OS == descriptor->type || MALI_MEM_BLOCK == descriptor->type) &&
+	    (session->mali_mem_array[MALI_MEM_OS] + session->mali_mem_array[MALI_MEM_BLOCK] > session->max_mali_mem_allocated)) {
+		session->max_mali_mem_allocated = session->mali_mem_array[MALI_MEM_OS] + session->mali_mem_array[MALI_MEM_BLOCK];
+	}
+	err = _MALI_OSK_ERR_OK;
+
+unlock_and_exit:
+	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RW);
+	MALI_ERROR(err);
+}
+
+void mali_descriptor_mapping_call_for_each(mali_descriptor_mapping *map, void (*callback)(int, void *))
+{
+	int i;
+
+	MALI_DEBUG_ASSERT_POINTER(map);
+	MALI_DEBUG_ASSERT_POINTER(callback);
+
+	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RO);
+	/* id 0 is skipped as it's an reserved ID not mapping to anything */
+	for (i = 1; i < map->current_nr_mappings; ++i) {
+		if (_mali_osk_test_bit(i, map->table->usage)) {
+			callback(i, map->table->mappings[i]);
+		}
+	}
+	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RO);
+}
+
+_mali_osk_errcode_t mali_descriptor_mapping_get(mali_descriptor_mapping *map, int descriptor, void **target)
+{
+	_mali_osk_errcode_t result = _MALI_OSK_ERR_FAULT;
+	MALI_DEBUG_ASSERT_POINTER(map);
+	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RO);
+	if ((descriptor >= 0) && (descriptor < map->current_nr_mappings) && _mali_osk_test_bit(descriptor, map->table->usage)) {
+		*target = map->table->mappings[descriptor];
+		result = _MALI_OSK_ERR_OK;
+	} else *target = NULL;
+	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RO);
+	MALI_ERROR(result);
+}
+
+_mali_osk_errcode_t mali_descriptor_mapping_set(mali_descriptor_mapping *map, int descriptor, void *target)
+{
+	_mali_osk_errcode_t result = _MALI_OSK_ERR_FAULT;
+	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RO);
+	if ((descriptor >= 0) && (descriptor < map->current_nr_mappings) && _mali_osk_test_bit(descriptor, map->table->usage)) {
+		map->table->mappings[descriptor] = target;
+		result = _MALI_OSK_ERR_OK;
+	}
+	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RO);
+	MALI_ERROR(result);
+}
+
+void *mali_descriptor_mapping_free(mali_descriptor_mapping *map, int descriptor)
+{
+	void *old_value = NULL;
+	mali_mem_allocation *tmp_descriptor;
+	struct mali_session_data *session;
+
+	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RW);
+	if ((descriptor >= 0) && (descriptor < map->current_nr_mappings) && _mali_osk_test_bit(descriptor, map->table->usage)) {
+		old_value = map->table->mappings[descriptor];
+		map->table->mappings[descriptor] = NULL;
+		_mali_osk_clear_nonatomic_bit(descriptor, map->table->usage);
+	}
+	if (NULL != old_value) {
+		tmp_descriptor = (mali_mem_allocation *)old_value;
+		session = tmp_descriptor->session;
+
+		MALI_DEBUG_ASSERT_POINTER(session);
+
+		MALI_DEBUG_ASSERT(session->mali_mem_array[tmp_descriptor->type] >= tmp_descriptor->size);
+
+		session->mali_mem_array[tmp_descriptor->type] -= tmp_descriptor->size;
+	}
+	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RW);
+
+	return old_value;
+}
+
+static mali_descriptor_table *descriptor_table_alloc(int count)
+{
+	mali_descriptor_table *table;
+
+	table = _mali_osk_calloc(1, sizeof(mali_descriptor_table) + ((sizeof(unsigned long) * count) / BITS_PER_LONG) + (sizeof(void *) * count));
+
+	if (NULL != table) {
+		table->usage = (u32 *)((u8 *)table + sizeof(mali_descriptor_table));
+		table->mappings = (void **)((u8 *)table + sizeof(mali_descriptor_table) + ((sizeof(unsigned long) * count) / BITS_PER_LONG));
+	}
+
+	return table;
+}
+
+static void descriptor_table_free(mali_descriptor_table *table)
+{
+	_mali_osk_free(table);
+}
\ No newline at end of file
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_descriptor_mapping.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_descriptor_mapping.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_descriptor_mapping.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_descriptor_mapping.h	2016-04-04 16:25:31.838527000 +0300
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
+ * 
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ * 
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/**
+ * @file mali_kernel_descriptor_mapping.h
+ */
+
+#ifndef __MALI_KERNEL_DESCRIPTOR_MAPPING_H__
+#define __MALI_KERNEL_DESCRIPTOR_MAPPING_H__
+
+#include "mali_osk.h"
+
+struct mali_session_data;
+
+/**
+ * The actual descriptor mapping table, never directly accessed by clients
+ */
+typedef struct mali_descriptor_table {
+	u32 *usage;  /**< Pointer to bitpattern indicating if a descriptor is valid/used or not */
+	void **mappings; /**< Array of the pointers the descriptors map to */
+} mali_descriptor_table;
+
+/**
+ * The descriptor mapping object
+ * Provides a separate namespace where we can map an integer to a pointer
+ */
+typedef struct mali_descriptor_mapping {
+	_mali_osk_mutex_rw_t *lock; /**< Lock protecting access to the mapping object */
+	int max_nr_mappings_allowed; /**< Max number of mappings to support in this namespace */
+	int current_nr_mappings; /**< Current number of possible mappings */
+	mali_descriptor_table *table;  /**< Pointer to the current mapping table */
+} mali_descriptor_mapping;
+
+/**
+ * Create a descriptor mapping object
+ * Create a descriptor mapping capable of holding init_entries growable to max_entries
+ * @param init_entries Number of entries to preallocate memory for
+ * @param max_entries Number of entries to max support
+ * @return Pointer to a descriptor mapping object, NULL on failure
+ */
+mali_descriptor_mapping *mali_descriptor_mapping_create(int init_entries, int max_entries);
+
+/**
+ * Destroy a descriptor mapping object
+ * @param map The map to free
+ */
+void mali_descriptor_mapping_destroy(mali_descriptor_mapping *map);
+
+/**
+ * Allocate a new mapping entry (descriptor ID)
+ * Allocates a new entry in the map.
+ * @param map The map to allocate a new entry in
+ * @param target The value to map to
+ * @return The descriptor allocated, a negative value on error
+ */
+_mali_osk_errcode_t mali_descriptor_mapping_allocate_mapping(mali_descriptor_mapping *map, void *target, int *descriptor);
+
+/**
+ * Get the value mapped to by a descriptor ID
+ * @param map The map to lookup the descriptor id in
+ * @param descriptor The descriptor ID to lookup
+ * @param target Pointer to a pointer which will receive the stored value
+ * @return 0 on successful lookup, negative on error
+ */
+_mali_osk_errcode_t mali_descriptor_mapping_get(mali_descriptor_mapping *map, int descriptor, void **target);
+
+/**
+ * Set the value mapped to by a descriptor ID
+ * @param map The map to lookup the descriptor id in
+ * @param descriptor The descriptor ID to lookup
+ * @param target Pointer to replace the current value with
+ * @return 0 on successful lookup, negative on error
+ */
+_mali_osk_errcode_t mali_descriptor_mapping_set(mali_descriptor_mapping *map, int descriptor, void *target);
+
+/**
+ * Call the specified callback function for each descriptor in map.
+ * Entire function is mutex protected.
+ * @param map The map to do callbacks for
+ * @param callback A callback function which will be calle for each entry in map
+ */
+void mali_descriptor_mapping_call_for_each(mali_descriptor_mapping *map, void (*callback)(int, void *));
+
+/**
+ * Free the descriptor ID
+ * For the descriptor to be reused it has to be freed
+ * @param map The map to free the descriptor from
+ * @param descriptor The descriptor ID to free
+ *
+ * @return old value of descriptor mapping
+ */
+void *mali_descriptor_mapping_free(mali_descriptor_mapping *map, int descriptor);
+
+#endif /* __MALI_KERNEL_DESCRIPTOR_MAPPING_H__ */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_utilization.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_utilization.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_utilization.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_utilization.c	2016-04-04 16:25:31.838527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -45,7 +45,7 @@
 static u32 mali_control_first_timeout = 100;
 static struct mali_gpu_utilization_data mali_util_data = {0, };
 
-struct mali_gpu_utilization_data *mali_utilization_calculate(u64 *start_time, u64 *time_period, mali_bool *need_add_timer)
+struct mali_gpu_utilization_data *mali_utilization_calculate(u64 *start_time, u64 *time_period)
 {
 	u64 time_now;
 	u32 leading_zeroes;
@@ -65,7 +65,6 @@
 	*time_period = time_now - *start_time;
 
 	if (accumulated_work_time_gpu == 0 && work_start_time_gpu == 0) {
-		mali_control_timer_pause();
 		/*
 		 * No work done for this period
 		 * - No need to reschedule timer
@@ -81,7 +80,8 @@
 
 		mali_utilization_data_unlock();
 
-		*need_add_timer = MALI_FALSE;
+		/* Stop add timer until the next job submited */
+		mali_control_timer_suspend(MALI_FALSE);
 
 		mali_executor_hint_disable(MALI_EXECUTOR_HINT_GP_BOUND);
 
@@ -172,8 +172,6 @@
 
 	mali_utilization_data_unlock();
 
-	*need_add_timer = MALI_TRUE;
-
 	MALI_DEBUG_PRINT(4, ("last_utilization_gpu = %d \n", last_utilization_gpu));
 	MALI_DEBUG_PRINT(4, ("last_utilization_gp = %d \n", last_utilization_gp));
 	MALI_DEBUG_PRINT(4, ("last_utilization_pp = %d \n", last_utilization_pp));
@@ -419,11 +417,6 @@
 	_mali_osk_spinlock_irq_unlock(utilization_data_lock);
 }
 
-void mali_utilization_data_assert_locked(void)
-{
-	MALI_DEBUG_ASSERT_LOCK_HELD(utilization_data_lock);
-}
-
 u32 _mali_ukk_utilization_gp_pp(void)
 {
 	return last_utilization_gpu;
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_utilization.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_utilization.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_utilization.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_utilization.h	2016-04-04 16:25:31.848527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -54,7 +54,7 @@
 /**
  * Should be called to calcution the GPU utilization
  */
-struct mali_gpu_utilization_data *mali_utilization_calculate(u64 *start_time, u64 *time_period, mali_bool *need_add_timer);
+struct mali_gpu_utilization_data *mali_utilization_calculate(u64 *start_time, u64 *time_period);
 
 _mali_osk_spinlock_irq_t *mali_utilization_get_lock(void);
 
@@ -64,8 +64,6 @@
 
 void mali_utilization_data_unlock(void);
 
-void mali_utilization_data_assert_locked(void);
-
 void mali_utilization_reset(void);
 
 
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_vsync.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_vsync.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_kernel_vsync.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_kernel_vsync.c	2016-04-04 16:25:31.858527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_l2_cache.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_l2_cache.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_l2_cache.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_l2_cache.c	2016-04-04 16:25:31.868527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -68,7 +68,7 @@
 #define MALI400_L2_MAX_READS_NOT_SET -1
 
 static struct mali_l2_cache_core *
-	mali_global_l2s[MALI_MAX_NUMBER_OF_L2_CACHE_CORES] = { NULL, };
+		mali_global_l2s[MALI_MAX_NUMBER_OF_L2_CACHE_CORES] = { NULL, };
 static u32 mali_global_num_l2s = 0;
 
 int mali_l2_max_reads = MALI400_L2_MAX_READS_NOT_SET;
@@ -466,24 +466,21 @@
 
 static void mali_l2_cache_reset(struct mali_l2_cache_core *cache)
 {
-    MALI_DEBUG_ASSERT_POINTER(cache);
-    MALI_DEBUG_ASSERT_LOCK_HELD(cache->lock);
+	if (cache && cache->pm_domain && !cache->pm_domain->power_is_on)
+		return;
+		
+	MALI_DEBUG_ASSERT_POINTER(cache);
+	MALI_DEBUG_ASSERT_LOCK_HELD(cache->lock);
+	
+	/* Invalidate cache (just to keep it in a known state at startup) */
+	mali_l2_cache_send_command(cache, MALI400_L2_CACHE_REGISTER_COMMAND,
+				   MALI400_L2_CACHE_COMMAND_CLEAR_ALL);
 
-    /* Kasin Added, skip off power domain. */
-    if (cache && cache->pm_domain && cache->pm_domain->power_is_on == MALI_FALSE) {
-        printk("===========%s, %d skip off power domain?\n", __FUNCTION__, __LINE__);
-    }
-
-
-    /* Invalidate cache (just to keep it in a known state at startup) */
-    mali_l2_cache_send_command(cache, MALI400_L2_CACHE_REGISTER_COMMAND,
-            MALI400_L2_CACHE_COMMAND_CLEAR_ALL);
-
-    /* Enable cache */
-    mali_hw_core_register_write(&cache->hw_core,
-            MALI400_L2_CACHE_REGISTER_ENABLE,
-            (u32)MALI400_L2_CACHE_ENABLE_ACCESS |
-            (u32)MALI400_L2_CACHE_ENABLE_READ_ALLOCATE);
+	/* Enable cache */
+	mali_hw_core_register_write(&cache->hw_core,
+				    MALI400_L2_CACHE_REGISTER_ENABLE,
+				    (u32)MALI400_L2_CACHE_ENABLE_ACCESS |
+				    (u32)MALI400_L2_CACHE_ENABLE_READ_ALLOCATE);
 
 	if (MALI400_L2_MAX_READS_NOT_SET != mali_l2_max_reads) {
 		mali_hw_core_register_write(&cache->hw_core,
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_l2_cache.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_l2_cache.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_l2_cache.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_l2_cache.h	2016-04-04 16:25:31.878527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mem_validation.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mem_validation.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mem_validation.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mem_validation.c	2016-04-04 16:25:31.888527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -46,7 +46,6 @@
 
 _mali_osk_errcode_t mali_mem_validation_check(u32 phys_addr, u32 size)
 {
-#if 0
 	if (phys_addr < (phys_addr + size)) { /* Don't allow overflow (or zero size) */
 		if ((0 == (phys_addr & (~_MALI_OSK_CPU_PAGE_MASK))) &&
 		    (0 == (size & (~_MALI_OSK_CPU_PAGE_MASK)))) {
@@ -63,7 +62,4 @@
 	MALI_PRINT_ERROR(("MALI PHYSICAL RANGE VALIDATION ERROR: The range supplied was: phys_base=0x%08X, size=0x%08X\n", phys_addr, size));
 
 	return _MALI_OSK_ERR_FAULT;
-#else
-	return _MALI_OSK_ERR_OK;
-#endif
 }
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mem_validation.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mem_validation.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mem_validation.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mem_validation.h	2016-04-04 16:25:31.898527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mmu.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mmu.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mmu.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mmu.c	2016-04-04 16:25:31.908527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mmu.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mmu.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mmu.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mmu.h	2016-04-04 16:25:31.918527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mmu_page_directory.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mmu_page_directory.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mmu_page_directory.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mmu_page_directory.c	2016-04-04 16:25:31.928527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mmu_page_directory.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mmu_page_directory.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_mmu_page_directory.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_mmu_page_directory.h	2016-04-04 16:25:31.938527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_bitops.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_bitops.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_bitops.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_bitops.h	2016-04-04 16:25:31.978527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk.h	2016-04-04 16:25:31.958527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_list.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_list.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_list.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_list.h	2016-04-04 16:25:31.978527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_mali.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_mali.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_mali.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_mali.h	2016-04-04 16:25:31.988527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_profiling.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_profiling.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_profiling.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_profiling.h	2016-04-04 16:25:31.998527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_types.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_types.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_osk_types.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_osk_types.h	2016-04-04 16:25:32.008527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -335,11 +335,11 @@
  */
 
 /** Mali Page Order, as log to base 2 of the Page size. @see _MALI_OSK_MALI_PAGE_SIZE */
-#define _MALI_OSK_MALI_PAGE_ORDER PAGE_SHIFT
+#define _MALI_OSK_MALI_PAGE_ORDER ((u32)12)
 /** Mali Page Size, in bytes.               */
-#define _MALI_OSK_MALI_PAGE_SIZE PAGE_SIZE
+#define _MALI_OSK_MALI_PAGE_SIZE (((u32)1) << (_MALI_OSK_MALI_PAGE_ORDER))
 /** Mali Page Mask, which masks off the offset within a page */
-#define _MALI_OSK_MALI_PAGE_MASK PAGE_MASK
+#define _MALI_OSK_MALI_PAGE_MASK (~((((u32)1) << (_MALI_OSK_MALI_PAGE_ORDER)) - ((u32)1)))
 /** @} */ /* end of group _MALI_OSK_MALI_PAGE*/
 
 /** @brief flags for mapping a user-accessible memory range
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pm.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pm.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pm.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pm.c	2016-04-04 16:25:32.018527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -709,7 +709,7 @@
 		struct mali_group *groups_up[MALI_MAX_NUMBER_OF_GROUPS];
 		u32 num_groups_up = 0;
 		struct mali_l2_cache_core *
-			l2_up[MALI_MAX_NUMBER_OF_L2_CACHE_CORES];
+				l2_up[MALI_MAX_NUMBER_OF_L2_CACHE_CORES];
 		u32 num_l2_up = 0;
 		u32 i;
 
@@ -779,7 +779,7 @@
 		struct mali_group *groups_down[MALI_MAX_NUMBER_OF_GROUPS];
 		u32 num_groups_down = 0;
 		struct mali_l2_cache_core *
-			l2_down[MALI_MAX_NUMBER_OF_L2_CACHE_CORES];
+				l2_down[MALI_MAX_NUMBER_OF_L2_CACHE_CORES];
 		u32 num_l2_down = 0;
 		u32 i;
 
@@ -883,7 +883,7 @@
 		struct mali_group *groups_down[MALI_MAX_NUMBER_OF_GROUPS];
 		u32 num_groups_down = 0;
 		struct mali_l2_cache_core *
-			l2_down[MALI_MAX_NUMBER_OF_L2_CACHE_CORES];
+				l2_down[MALI_MAX_NUMBER_OF_L2_CACHE_CORES];
 		u32 num_l2_down = 0;
 		u32 i;
 
@@ -1028,22 +1028,22 @@
 	/* L2gp/L2PP0/L2PP4 */
 	if (mali_is_mali400()) {
 		if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(
-			    MALI400_OFFSET_L2_CACHE0, NULL)) {
-			domain_config[MALI_DOMAIN_INDEX_L20] = 0x01 << 1;
+					MALI400_OFFSET_L2_CACHE0, NULL)) {
+				domain_config[MALI_DOMAIN_INDEX_L20] = 0x01 << 1;
 		}
 	} else if (mali_is_mali450()) {
 		if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(
-			    MALI450_OFFSET_L2_CACHE0, NULL)) {
+					MALI450_OFFSET_L2_CACHE0, NULL)) {
 			domain_config[MALI_DOMAIN_INDEX_L20] = 0x01 << 0;
 		}
 
 		if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(
-			    MALI450_OFFSET_L2_CACHE1, NULL)) {
+					MALI450_OFFSET_L2_CACHE1, NULL)) {
 			domain_config[MALI_DOMAIN_INDEX_L21] = 0x01 << 1;
 		}
 
 		if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(
-			    MALI450_OFFSET_L2_CACHE2, NULL)) {
+					MALI450_OFFSET_L2_CACHE2, NULL)) {
 			domain_config[MALI_DOMAIN_INDEX_L22] = 0x01 << 3;
 		}
 	}
@@ -1069,21 +1069,14 @@
 
 	for (i = 0; i < MALI_MAX_NUMBER_OF_DOMAINS - 1; i++) {
 		if (0 != domain_config[i]) {
-			MALI_DEBUG_PRINT(2, ("Using customer pmu config:\n"));
 			break;
 		}
 	}
 
 	if (MALI_MAX_NUMBER_OF_DOMAINS - 1 == i) {
-		MALI_DEBUG_PRINT(2, ("Using hw detect pmu config:\n"));
 		mali_pm_set_default_pm_domain_config();
 	}
 
-	for (i = 0; i < MALI_MAX_NUMBER_OF_DOMAINS - 1; i++) {
-		if (domain_config[i]) {
-			MALI_DEBUG_PRINT(2, ("domain_config[%d] = 0x%x \n", i, domain_config[i]));
-		}
-	}
 	/* Can't override dummy domain mask */
 	domain_config[MALI_DOMAIN_INDEX_DUMMY] =
 		1 << MALI_DOMAIN_INDEX_DUMMY;
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pm_domain.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pm_domain.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pm_domain.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pm_domain.c	2016-04-04 16:25:32.048527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pm_domain.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pm_domain.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pm_domain.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pm_domain.h	2016-04-04 16:25:32.048527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pm.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pm.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pm.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pm.h	2016-04-04 16:25:32.038527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pmu.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pmu.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pmu.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pmu.c	2016-04-04 16:25:32.058527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -144,6 +144,7 @@
 	MALI_DEBUG_ASSERT(0 == (stat & mask));
 
 	if (0 == mask || 0 == ((~stat) & mask)) return _MALI_OSK_ERR_OK;
+	if (mask == 8) return _MALI_OSK_ERR_OK;
 
 	mali_hw_core_register_write(&pmu->hw_core,
 				    PMU_REG_ADDR_MGMT_POWER_DOWN, mask);
@@ -167,7 +168,7 @@
 	/* Verify power status of domains after power down */
 	stat = mali_hw_core_register_read(&pmu->hw_core,
 					  PMU_REG_ADDR_MGMT_STATUS);
-	MALI_DEBUG_ASSERT(mask == (stat & mask));
+	//MALI_DEBUG_ASSERT(mask == (stat & mask));
 #endif
 
 	return _MALI_OSK_ERR_OK;
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pmu.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pmu.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pmu.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pmu.h	2016-04-04 16:25:32.068527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp.c	2016-04-04 16:25:32.078527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -19,8 +19,6 @@
 #include "mali_osk_profiling.h"
 #endif
 
-#include <mali_platform.h>
-
 /* Number of frame registers on Mali-200 */
 #define MALI_PP_MALI200_NUM_FRAME_REGISTERS ((0x04C/4)+1)
 /* Number of frame registers on Mali-300 and later */
@@ -149,8 +147,6 @@
 
 	if (MALI_REG_POLL_COUNT_FAST == i) {
 		MALI_PRINT_ERROR(("Mali PP: Failed to stop bus on %s. Status: 0x%08x\n", core->hw_core.description, mali_hw_core_register_read(&core->hw_core, MALI200_REG_ADDR_MGMT_STATUS)));
-		if (mali_gp_reset_fail < 65533)
-			mali_gp_reset_fail++;
 		return _MALI_OSK_ERR_FAULT;
 	}
 	return _MALI_OSK_ERR_OK;
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp.h	2016-04-04 16:25:32.088527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp_job.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp_job.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp_job.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp_job.c	2016-04-04 16:25:32.098527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -43,7 +43,6 @@
 
 	job = _mali_osk_calloc(1, sizeof(struct mali_pp_job));
 	if (NULL != job) {
-		u32 num_memory_cookies = 0;
 		if (0 != _mali_osk_copy_from_user(&job->uargs, uargs, sizeof(_mali_uk_pp_start_job_s))) {
 			goto fail;
 		}
@@ -88,17 +87,17 @@
 
 		_mali_osk_atomic_init(&job->sub_jobs_completed, 0);
 		_mali_osk_atomic_init(&job->sub_job_errors, 0);
-		num_memory_cookies = job->uargs.num_memory_cookies;
-		if (num_memory_cookies !=  0) {
+
+		if (job->uargs.num_memory_cookies > 0) {
 			u32 size;
 			u32 __user *memory_cookies = (u32 __user *)(uintptr_t)job->uargs.memory_cookies;
 
-			if (num_memory_cookies > session->allocation_mgr.mali_allocation_nr) {
+			if (job->uargs.num_memory_cookies > session->descriptor_mapping->current_nr_mappings) {
 				MALI_PRINT_ERROR(("Mali PP job: Too many memory cookies specified in job object\n"));
 				goto fail;
 			}
 
-			size = sizeof(*memory_cookies) * num_memory_cookies;
+			size = sizeof(*memory_cookies) * job->uargs.num_memory_cookies;
 
 			job->memory_cookies = _mali_osk_malloc(size);
 			if (NULL == job->memory_cookies) {
@@ -110,6 +109,17 @@
 				MALI_PRINT_ERROR(("Mali PP job: Failed to copy %d bytes of memory cookies from user!\n", size));
 				goto fail;
 			}
+
+#if defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
+			if (0 < job->uargs.num_memory_cookies) {
+				job->dma_bufs = _mali_osk_calloc(job->uargs.num_memory_cookies,
+								 sizeof(struct mali_dma_buf_attachment *));
+				if (NULL == job->dma_bufs) {
+					MALI_PRINT_ERROR(("Mali PP job: Failed to allocate dma_bufs array!\n"));
+					goto fail;
+				}
+			}
+#endif
 		}
 
 		if (_MALI_OSK_ERR_OK != mali_pp_job_check(job)) {
@@ -141,6 +151,16 @@
 		_mali_osk_notification_delete(job->finished_notification);
 	}
 
+#if defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
+	/* Unmap buffers attached to job */
+	if (0 < job->uargs.num_memory_cookies) {
+		mali_dma_buf_unmap_job(job);
+		if (NULL != job->dma_bufs) {
+			_mali_osk_free(job->dma_bufs);
+		}
+	}
+#endif /* CONFIG_DMA_SHARED_BUFFER */
+
 	if (NULL != job->memory_cookies) {
 		_mali_osk_free(job->memory_cookies);
 	}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp_job.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp_job.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp_job.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp_job.h	2016-04-04 16:25:32.108527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -68,6 +68,9 @@
 	 * No lock is thus needed for these.
 	 */
 	u32 *memory_cookies;                               /**< Memory cookies attached to job */
+#if defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
+	struct mali_dma_buf_attachment **dma_bufs;         /**< Array of DMA-bufs used by job */
+#endif
 
 	/*
 	 * These members are used by the scheduler,
@@ -416,6 +419,32 @@
 	return MALI_FALSE;
 }
 
+#if defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
+MALI_STATIC_INLINE u32 mali_pp_job_num_dma_bufs(struct mali_pp_job *job)
+{
+	MALI_DEBUG_ASSERT_POINTER(job);
+	return job->uargs.num_memory_cookies;
+}
+
+MALI_STATIC_INLINE struct mali_dma_buf_attachment *mali_pp_job_get_dma_buf(
+	struct mali_pp_job *job, u32 index)
+{
+	MALI_DEBUG_ASSERT_POINTER(job);
+	MALI_DEBUG_ASSERT(index < job->uargs.num_memory_cookies);
+	MALI_DEBUG_ASSERT_POINTER(job->dma_bufs);
+	return job->dma_bufs[index];
+}
+
+MALI_STATIC_INLINE void mali_pp_job_set_dma_buf(struct mali_pp_job *job,
+		u32 index, struct mali_dma_buf_attachment *mem)
+{
+	MALI_DEBUG_ASSERT_POINTER(job);
+	MALI_DEBUG_ASSERT(index < job->uargs.num_memory_cookies);
+	MALI_DEBUG_ASSERT_POINTER(job->dma_bufs);
+	job->dma_bufs[index] = mem;
+}
+#endif
+
 MALI_STATIC_INLINE void mali_pp_job_mark_sub_job_started(struct mali_pp_job *job, u32 sub_job)
 {
 	MALI_DEBUG_ASSERT_POINTER(job);
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp_scheduler.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp_scheduler.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp_scheduler.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp_scheduler.c	2016-04-04 16:25:32.128527000 +0300
@@ -0,0 +1,2067 @@
+/*
+ * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
+ * 
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ * 
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "mali_pp_scheduler.h"
+#include "mali_kernel_common.h"
+#include "mali_kernel_core.h"
+#include "mali_osk.h"
+#include "mali_osk_list.h"
+#include "mali_scheduler.h"
+#include "mali_pp.h"
+#include "mali_pp_job.h"
+#include "mali_group.h"
+#include "mali_pm.h"
+#include "mali_timeline.h"
+#include "mali_osk_profiling.h"
+#include "mali_kernel_utilization.h"
+#include "mali_session.h"
+#include "mali_pm_domain.h"
+#include "linux/mali/mali_utgard.h"
+
+#if defined(CONFIG_DMA_SHARED_BUFFER)
+#include "mali_memory_dma_buf.h"
+#endif
+#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
+#include <linux/sched.h>
+#include <trace/events/gpu.h>
+#endif
+
+/* Queue type used for physical and virtual job queues. */
+struct mali_pp_scheduler_job_queue {
+	_MALI_OSK_LIST_HEAD(normal_pri); /* List of jobs with some unscheduled work. */
+	_MALI_OSK_LIST_HEAD(high_pri);   /* List of high priority jobs with some unscheduled work. */
+	u32 depth;                       /* Depth of combined queues. */
+};
+
+/* If dma_buf with map on demand is used, we defer job deletion and job queue if in atomic context,
+ * since both might sleep. */
+#if defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
+#define MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE 1
+#define MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE 1
+#endif /* !defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH) */
+
+static void mali_pp_scheduler_job_queued(void);
+static void mali_pp_scheduler_job_completed(void);
+
+/* Maximum of 8 PP cores (a group can only have maximum of 1 PP core) */
+#define MALI_MAX_NUMBER_OF_PP_GROUPS 9
+
+static mali_bool mali_pp_scheduler_is_suspended(void *data);
+
+static u32 pp_version = 0;
+
+/* Physical job queue */
+static struct mali_pp_scheduler_job_queue job_queue;
+
+/* Physical groups */
+static _MALI_OSK_LIST_HEAD_STATIC_INIT(group_list_working);     /* List of physical groups with working jobs on the pp core */
+static _MALI_OSK_LIST_HEAD_STATIC_INIT(group_list_idle);        /* List of physical groups with idle jobs on the pp core */
+static _MALI_OSK_LIST_HEAD_STATIC_INIT(group_list_disabled);    /* List of disabled physical groups */
+
+/* Virtual job queue (Mali-450 only) */
+static struct mali_pp_scheduler_job_queue virtual_job_queue;
+
+/**
+ * Add job to scheduler queue.
+ *
+ * @param job Job to queue.
+ * @return Schedule mask.
+ */
+static mali_scheduler_mask mali_pp_scheduler_queue_job(struct mali_pp_job *job);
+
+/* Virtual group (Mali-450 only) */
+static struct mali_group *virtual_group = NULL;                 /* Virtual group (if any) */
+static enum {
+	VIRTUAL_GROUP_IDLE,
+	VIRTUAL_GROUP_WORKING,
+	VIRTUAL_GROUP_DISABLED,
+}
+virtual_group_state = VIRTUAL_GROUP_IDLE;            /* Flag which indicates whether the virtual group is working or idle */
+
+/* Number of physical cores */
+static u32 num_cores = 0;
+
+/* Number of physical cores which are enabled */
+static u32 enabled_cores = 0;
+
+/* Enable or disable core scaling */
+static mali_bool core_scaling_enabled = MALI_TRUE;
+
+/* Variables to allow safe pausing of the scheduler */
+static _mali_osk_wait_queue_t *pp_scheduler_working_wait_queue = NULL;
+static u32 pause_count = 0;
+
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+static _mali_osk_spinlock_irq_t *pp_scheduler_lock = NULL;
+#else
+static _mali_osk_spinlock_t *pp_scheduler_lock = NULL;
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+
+MALI_STATIC_INLINE void mali_pp_scheduler_lock(void)
+{
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+	_mali_osk_spinlock_irq_lock(pp_scheduler_lock);
+#else
+	_mali_osk_spinlock_lock(pp_scheduler_lock);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+	MALI_DEBUG_PRINT(5, ("Mali PP scheduler: PP scheduler lock taken.\n"));
+}
+
+MALI_STATIC_INLINE void mali_pp_scheduler_unlock(void)
+{
+	MALI_DEBUG_PRINT(5, ("Mali PP scheduler: Releasing PP scheduler lock.\n"));
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+	_mali_osk_spinlock_irq_unlock(pp_scheduler_lock);
+#else
+	_mali_osk_spinlock_unlock(pp_scheduler_lock);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+}
+
+#if defined(DEBUG)
+#define MALI_ASSERT_PP_SCHEDULER_LOCKED() MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock)
+#else
+#define MALI_ASSERT_PP_SCHEDULER_LOCKED() do {} while (0)
+#endif /* defined(DEBUG) */
+
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
+
+static _mali_osk_wq_work_t *pp_scheduler_wq_job_delete = NULL;
+static _mali_osk_spinlock_irq_t *pp_scheduler_job_delete_lock = NULL;
+static _MALI_OSK_LIST_HEAD_STATIC_INIT(pp_scheduler_job_deletion_queue);
+
+static void mali_pp_scheduler_deferred_job_delete(struct mali_pp_job *job)
+{
+	MALI_DEBUG_ASSERT_POINTER(job);
+
+	_mali_osk_spinlock_irq_lock(pp_scheduler_job_delete_lock);
+
+	/* This job object should not be on any lists. */
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_list));
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_fb_lookup_list));
+
+	_mali_osk_list_addtail(&job->list, &pp_scheduler_job_deletion_queue);
+
+	_mali_osk_spinlock_irq_unlock(pp_scheduler_job_delete_lock);
+
+	_mali_osk_wq_schedule_work(pp_scheduler_wq_job_delete);
+}
+
+static void mali_pp_scheduler_do_job_delete(void *arg)
+{
+	_MALI_OSK_LIST_HEAD_STATIC_INIT(list);
+	struct mali_pp_job *job;
+	struct mali_pp_job *tmp;
+
+	MALI_IGNORE(arg);
+
+	_mali_osk_spinlock_irq_lock(pp_scheduler_job_delete_lock);
+
+	/*
+	 * Quickly "unhook" the jobs pending to be deleted, so we can release the lock before
+	 * we start deleting the job objects (without any locks held
+	 */
+	_mali_osk_list_move_list(&pp_scheduler_job_deletion_queue, &list);
+
+	_mali_osk_spinlock_irq_unlock(pp_scheduler_job_delete_lock);
+
+	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &list, struct mali_pp_job, list) {
+		mali_pp_job_delete(job); /* delete the job object itself */
+	}
+}
+
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
+
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
+
+static _mali_osk_wq_work_t *pp_scheduler_wq_job_queue = NULL;
+static _mali_osk_spinlock_irq_t *pp_scheduler_job_queue_lock = NULL;
+static _MALI_OSK_LIST_HEAD_STATIC_INIT(pp_scheduler_job_queue_list);
+
+static void mali_pp_scheduler_deferred_job_queue(struct mali_pp_job *job)
+{
+	MALI_DEBUG_ASSERT_POINTER(job);
+
+	_mali_osk_spinlock_irq_lock(pp_scheduler_job_queue_lock);
+	_mali_osk_list_addtail(&job->list, &pp_scheduler_job_queue_list);
+	_mali_osk_spinlock_irq_unlock(pp_scheduler_job_queue_lock);
+
+	_mali_osk_wq_schedule_work(pp_scheduler_wq_job_queue);
+}
+
+static void mali_pp_scheduler_do_job_queue(void *arg)
+{
+	_MALI_OSK_LIST_HEAD_STATIC_INIT(list);
+	struct mali_pp_job *job;
+	struct mali_pp_job *tmp;
+	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
+
+	MALI_IGNORE(arg);
+
+	_mali_osk_spinlock_irq_lock(pp_scheduler_job_queue_lock);
+
+	/*
+	 * Quickly "unhook" the jobs pending to be queued, so we can release the lock before
+	 * we start queueing the job objects (without any locks held)
+	 */
+	_mali_osk_list_move_list(&pp_scheduler_job_queue_list, &list);
+
+	_mali_osk_spinlock_irq_unlock(pp_scheduler_job_queue_lock);
+
+	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &list, struct mali_pp_job, list) {
+		_mali_osk_list_delinit(&job->list);
+		schedule_mask |= mali_pp_scheduler_queue_job(job);
+	}
+
+	mali_scheduler_schedule_from_mask(schedule_mask, MALI_FALSE);
+}
+
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
+
+MALI_STATIC_INLINE mali_bool mali_pp_scheduler_has_virtual_group(void)
+{
+#if defined(CONFIG_MALI450)
+	return NULL != virtual_group;
+#else
+	return MALI_FALSE;
+#endif /* defined(CONFIG_MALI450) */
+}
+
+_mali_osk_errcode_t mali_pp_scheduler_initialize(void)
+{
+	_MALI_OSK_INIT_LIST_HEAD(&job_queue.normal_pri);
+	_MALI_OSK_INIT_LIST_HEAD(&job_queue.high_pri);
+	job_queue.depth = 0;
+
+	_MALI_OSK_INIT_LIST_HEAD(&virtual_job_queue.normal_pri);
+	_MALI_OSK_INIT_LIST_HEAD(&virtual_job_queue.high_pri);
+	virtual_job_queue.depth = 0;
+
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+	pp_scheduler_lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER);
+#else
+	pp_scheduler_lock = _mali_osk_spinlock_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+	if (NULL == pp_scheduler_lock) goto cleanup;
+
+	pp_scheduler_working_wait_queue = _mali_osk_wait_queue_init();
+	if (NULL == pp_scheduler_working_wait_queue) goto cleanup;
+
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
+	pp_scheduler_wq_job_delete = _mali_osk_wq_create_work(mali_pp_scheduler_do_job_delete, NULL);
+	if (NULL == pp_scheduler_wq_job_delete) goto cleanup;
+
+	pp_scheduler_job_delete_lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER_DEFERRED);
+	if (NULL == pp_scheduler_job_delete_lock) goto cleanup;
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
+
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
+	pp_scheduler_wq_job_queue = _mali_osk_wq_create_work(mali_pp_scheduler_do_job_queue, NULL);
+	if (NULL == pp_scheduler_wq_job_queue) goto cleanup;
+
+	pp_scheduler_job_queue_lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER_DEFERRED);
+	if (NULL == pp_scheduler_job_queue_lock) goto cleanup;
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
+
+	return _MALI_OSK_ERR_OK;
+
+cleanup:
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
+	if (NULL != pp_scheduler_job_queue_lock) {
+		_mali_osk_spinlock_irq_term(pp_scheduler_job_queue_lock);
+		pp_scheduler_job_queue_lock = NULL;
+	}
+
+	if (NULL != pp_scheduler_wq_job_queue) {
+		_mali_osk_wq_delete_work(pp_scheduler_wq_job_queue);
+		pp_scheduler_wq_job_queue = NULL;
+	}
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
+
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
+	if (NULL != pp_scheduler_job_delete_lock) {
+		_mali_osk_spinlock_irq_term(pp_scheduler_job_delete_lock);
+		pp_scheduler_job_delete_lock = NULL;
+	}
+
+	if (NULL != pp_scheduler_wq_job_delete) {
+		_mali_osk_wq_delete_work(pp_scheduler_wq_job_delete);
+		pp_scheduler_wq_job_delete = NULL;
+	}
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
+
+	if (NULL != pp_scheduler_working_wait_queue) {
+		_mali_osk_wait_queue_term(pp_scheduler_working_wait_queue);
+		pp_scheduler_working_wait_queue = NULL;
+	}
+
+	if (NULL != pp_scheduler_lock) {
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+		_mali_osk_spinlock_irq_term(pp_scheduler_lock);
+#else
+		_mali_osk_spinlock_term(pp_scheduler_lock);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+		pp_scheduler_lock = NULL;
+	}
+
+	return _MALI_OSK_ERR_NOMEM;
+}
+
+void mali_pp_scheduler_terminate(void)
+{
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
+	_mali_osk_spinlock_irq_term(pp_scheduler_job_queue_lock);
+	_mali_osk_wq_delete_work(pp_scheduler_wq_job_queue);
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
+
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
+	_mali_osk_spinlock_irq_term(pp_scheduler_job_delete_lock);
+	_mali_osk_wq_delete_work(pp_scheduler_wq_job_delete);
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
+
+	_mali_osk_wait_queue_term(pp_scheduler_working_wait_queue);
+
+#if defined(MALI_UPPER_HALF_SCHEDULING)
+	_mali_osk_spinlock_irq_term(pp_scheduler_lock);
+#else
+	_mali_osk_spinlock_term(pp_scheduler_lock);
+#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
+}
+
+void mali_pp_scheduler_populate(void)
+{
+	struct mali_group *group;
+	struct mali_pp_core *pp_core;
+	u32 num_groups;
+	u32 i;
+
+	num_groups = mali_group_get_glob_num_groups();
+
+	/* Do we have a virtual group? */
+	for (i = 0; i < num_groups; i++) {
+		group = mali_group_get_glob_group(i);
+
+		if (mali_group_is_virtual(group)) {
+			MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Found virtual group %p.\n", group));
+
+			virtual_group = group;
+			break;
+		}
+	}
+
+	/* Find all the available PP cores */
+	for (i = 0; i < num_groups; i++) {
+		group = mali_group_get_glob_group(i);
+		pp_core = mali_group_get_pp_core(group);
+
+		if (NULL != pp_core && !mali_group_is_virtual(group)) {
+			if (0 == pp_version) {
+				/* Retrieve PP version from the first available PP core */
+				pp_version = mali_pp_core_get_version(pp_core);
+			}
+
+			if (mali_pp_scheduler_has_virtual_group()) {
+				/* Add all physical PP cores to the virtual group */
+				mali_group_lock(virtual_group);
+				group->state = MALI_GROUP_STATE_JOINING_VIRTUAL;
+				mali_group_add_group(virtual_group, group, MALI_TRUE);
+				mali_group_unlock(virtual_group);
+			} else {
+				_mali_osk_list_add(&group->pp_scheduler_list, &group_list_idle);
+			}
+
+			num_cores++;
+		}
+	}
+
+	enabled_cores = num_cores;
+}
+
+void mali_pp_scheduler_depopulate(void)
+{
+	struct mali_group *group, *temp;
+
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&group_list_working));
+	MALI_DEBUG_ASSERT(VIRTUAL_GROUP_WORKING != virtual_group_state);
+
+	/* Delete all groups owned by scheduler */
+	if (mali_pp_scheduler_has_virtual_group()) {
+		mali_group_delete(virtual_group);
+	}
+
+	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_idle, struct mali_group, pp_scheduler_list) {
+		mali_group_delete(group);
+	}
+	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_disabled, struct mali_group, pp_scheduler_list) {
+		mali_group_delete(group);
+	}
+}
+
+MALI_STATIC_INLINE void mali_pp_scheduler_disable_empty_virtual(void)
+{
+	MALI_ASSERT_GROUP_LOCKED(virtual_group);
+
+	if (mali_group_virtual_disable_if_empty(virtual_group)) {
+		MALI_DEBUG_PRINT(4, ("Disabling empty virtual group\n"));
+
+		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_IDLE == virtual_group_state);
+
+		virtual_group_state = VIRTUAL_GROUP_DISABLED;
+	}
+}
+
+MALI_STATIC_INLINE void mali_pp_scheduler_enable_empty_virtual(void)
+{
+	MALI_ASSERT_GROUP_LOCKED(virtual_group);
+
+	if (mali_group_virtual_enable_if_empty(virtual_group)) {
+		MALI_DEBUG_PRINT(4, ("Re-enabling empty virtual group\n"));
+
+		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_DISABLED == virtual_group_state);
+
+		virtual_group_state = VIRTUAL_GROUP_IDLE;
+	}
+}
+
+static struct mali_pp_job *mali_pp_scheduler_get_job(struct mali_pp_scheduler_job_queue *queue)
+{
+	struct mali_pp_job *job = NULL;
+
+	MALI_ASSERT_PP_SCHEDULER_LOCKED();
+	MALI_DEBUG_ASSERT_POINTER(queue);
+
+	/* Check if we have a normal priority job. */
+	if (!_mali_osk_list_empty(&queue->normal_pri)) {
+		MALI_DEBUG_ASSERT(queue->depth > 0);
+		job = _MALI_OSK_LIST_ENTRY(queue->normal_pri.next, struct mali_pp_job, list);
+	}
+
+	/* Prefer normal priority job if it is in progress. */
+	if (NULL != job && 0 < job->sub_jobs_started) {
+		return job;
+	}
+
+	/* Check if we have a high priority job. */
+	if (!_mali_osk_list_empty(&queue->high_pri)) {
+		MALI_DEBUG_ASSERT(queue->depth > 0);
+		job = _MALI_OSK_LIST_ENTRY(queue->high_pri.next, struct mali_pp_job, list);
+	}
+
+	return job;
+}
+
+/**
+ * Returns a physical job if a physical job is ready to run
+ */
+MALI_STATIC_INLINE struct mali_pp_job *mali_pp_scheduler_get_physical_job(void)
+{
+	MALI_ASSERT_PP_SCHEDULER_LOCKED();
+	return mali_pp_scheduler_get_job(&job_queue);
+}
+
+MALI_STATIC_INLINE void mali_pp_scheduler_dequeue_physical_job(struct mali_pp_job *job)
+{
+	MALI_ASSERT_PP_SCHEDULER_LOCKED();
+	MALI_DEBUG_ASSERT(job_queue.depth > 0);
+
+	/* Remove job from queue */
+	if (!mali_pp_job_has_unstarted_sub_jobs(job)) {
+		/* All sub jobs have been started: remove job from queue */
+		_mali_osk_list_delinit(&job->list);
+		_mali_osk_list_delinit(&job->session_fb_lookup_list);
+	}
+
+	--job_queue.depth;
+}
+
+/**
+ * Returns a virtual job if a virtual job is ready to run
+ */
+MALI_STATIC_INLINE struct mali_pp_job *mali_pp_scheduler_get_virtual_job(void)
+{
+	MALI_ASSERT_PP_SCHEDULER_LOCKED();
+	MALI_DEBUG_ASSERT_POINTER(virtual_group);
+	return mali_pp_scheduler_get_job(&virtual_job_queue);
+}
+
+MALI_STATIC_INLINE void mali_pp_scheduler_dequeue_virtual_job(struct mali_pp_job *job)
+{
+	MALI_ASSERT_PP_SCHEDULER_LOCKED();
+	MALI_DEBUG_ASSERT(virtual_job_queue.depth > 0);
+
+	/* Remove job from queue */
+	_mali_osk_list_delinit(&job->list);
+	_mali_osk_list_delinit(&job->session_fb_lookup_list);
+	--virtual_job_queue.depth;
+}
+
+/**
+ * Checks if the criteria is met for removing a physical core from virtual group
+ */
+MALI_STATIC_INLINE mali_bool mali_pp_scheduler_can_move_virtual_to_physical(void)
+{
+	MALI_ASSERT_PP_SCHEDULER_LOCKED();
+	MALI_DEBUG_ASSERT(mali_pp_scheduler_has_virtual_group());
+	MALI_ASSERT_GROUP_LOCKED(virtual_group);
+	/*
+	 * The criteria for taking out a physical group from a virtual group are the following:
+	 * - There virtual group is idle
+	 * - There are currently no physical groups (idle and working)
+	 * - There are physical jobs to be scheduled
+	 */
+	return (VIRTUAL_GROUP_IDLE == virtual_group_state) &&
+	       _mali_osk_list_empty(&group_list_idle) &&
+	       _mali_osk_list_empty(&group_list_working) &&
+	       (NULL != mali_pp_scheduler_get_physical_job());
+}
+
+MALI_STATIC_INLINE struct mali_group *mali_pp_scheduler_acquire_physical_group(void)
+{
+	MALI_ASSERT_PP_SCHEDULER_LOCKED();
+
+	if (!_mali_osk_list_empty(&group_list_idle)) {
+		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Acquiring physical group from idle list.\n"));
+		return _MALI_OSK_LIST_ENTRY(group_list_idle.next, struct mali_group, pp_scheduler_list);
+	} else if (mali_pp_scheduler_has_virtual_group()) {
+		MALI_ASSERT_GROUP_LOCKED(virtual_group);
+		if (mali_pp_scheduler_can_move_virtual_to_physical()) {
+			struct mali_group *group;
+			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Acquiring physical group from virtual group.\n"));
+			group = mali_group_acquire_group(virtual_group);
+
+			if (mali_pp_scheduler_has_virtual_group()) {
+				mali_pp_scheduler_disable_empty_virtual();
+			}
+
+			return group;
+		}
+	}
+
+	return NULL;
+}
+
+static void mali_pp_scheduler_return_job_to_user(struct mali_pp_job *job, mali_bool deferred)
+{
+	if (MALI_FALSE == mali_pp_job_use_no_notification(job)) {
+		u32 i;
+		u32 num_counters_to_copy;
+		mali_bool success = mali_pp_job_was_success(job);
+
+		_mali_uk_pp_job_finished_s *jobres = job->finished_notification->result_buffer;
+		_mali_osk_memset(jobres, 0, sizeof(_mali_uk_pp_job_finished_s)); /* @@@@ can be removed once we initialize all members in this struct */
+		jobres->user_job_ptr = mali_pp_job_get_user_id(job);
+		if (MALI_TRUE == success) {
+			jobres->status = _MALI_UK_JOB_STATUS_END_SUCCESS;
+		} else {
+			jobres->status = _MALI_UK_JOB_STATUS_END_UNKNOWN_ERR;
+		}
+
+		if (mali_pp_job_is_virtual(job)) {
+			num_counters_to_copy = num_cores; /* Number of physical cores available */
+		} else {
+			num_counters_to_copy = mali_pp_job_get_sub_job_count(job);
+		}
+
+		for (i = 0; i < num_counters_to_copy; i++) {
+			jobres->perf_counter0[i] = mali_pp_job_get_perf_counter_value0(job, i);
+			jobres->perf_counter1[i] = mali_pp_job_get_perf_counter_value1(job, i);
+			jobres->perf_counter_src0 = mali_pp_job_get_pp_counter_global_src0();
+			jobres->perf_counter_src1 = mali_pp_job_get_pp_counter_global_src1();
+		}
+
+		mali_session_send_notification(mali_pp_job_get_session(job), job->finished_notification);
+		job->finished_notification = NULL;
+	}
+
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
+	if (MALI_TRUE == deferred) {
+		/* The deletion of the job object (releasing sync refs etc) must be done in a different context */
+		mali_pp_scheduler_deferred_job_delete(job);
+	} else {
+		mali_pp_job_delete(job);
+	}
+#else
+	MALI_DEBUG_ASSERT(MALI_FALSE == deferred); /* no use cases need this in this configuration */
+	mali_pp_job_delete(job);
+#endif
+}
+
+static void mali_pp_scheduler_finalize_job(struct mali_pp_job * job)
+{
+	/* This job object should not be on any lists. */
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_list));
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_fb_lookup_list));
+
+	/* Send notification back to user space */
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
+	mali_pp_scheduler_return_job_to_user(job, MALI_TRUE);
+#else
+	mali_pp_scheduler_return_job_to_user(job, MALI_FALSE);
+#endif
+
+#if defined(CONFIG_MALI400_POWER_PERFORMANCE_POLICY)
+	if (_MALI_PP_JOB_FLAG_IS_WINDOW_SURFACE & job->uargs.flags) {
+		_mali_osk_atomic_inc(&job->session->number_of_window_jobs);
+	}
+#endif
+
+	mali_pp_scheduler_job_completed();
+}
+
+void mali_pp_scheduler_schedule(void)
+{
+	struct mali_group* physical_groups_to_start[MALI_MAX_NUMBER_OF_PP_GROUPS - 1];
+	struct mali_pp_job* physical_jobs_to_start[MALI_MAX_NUMBER_OF_PP_GROUPS - 1];
+	u32 physical_sub_jobs_to_start[MALI_MAX_NUMBER_OF_PP_GROUPS - 1];
+	int num_physical_jobs_to_start = 0;
+	int i;
+
+	if (mali_pp_scheduler_has_virtual_group()) {
+		/* Lock the virtual group since we might have to grab physical groups. */
+		mali_group_lock(virtual_group);
+	}
+
+	mali_pp_scheduler_lock();
+	if (pause_count > 0) {
+		/* Scheduler is suspended, don't schedule any jobs. */
+		mali_pp_scheduler_unlock();
+		if (mali_pp_scheduler_has_virtual_group()) {
+			mali_group_unlock(virtual_group);
+		}
+		return;
+	}
+
+	/* Find physical job(s) to schedule first. */
+	while (1) {
+		struct mali_group *group;
+		struct mali_pp_job *job;
+		u32 sub_job;
+
+		job = mali_pp_scheduler_get_physical_job();
+		if (NULL == job) {
+			break; /* No job, early out. */
+		}
+
+		if (mali_scheduler_hint_is_enabled(MALI_SCHEDULER_HINT_GP_BOUND) &&
+		    mali_pp_job_is_large_and_unstarted(job) && !_mali_osk_list_empty(&group_list_working)) {
+			/* Since not all groups are idle, don't schedule yet. */
+			break;
+		}
+
+		MALI_DEBUG_ASSERT(!mali_pp_job_is_virtual(job));
+		MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(job));
+		MALI_DEBUG_ASSERT(1 <= mali_pp_job_get_sub_job_count(job));
+
+		/* Acquire a physical group, either from the idle list or from the virtual group.
+		 * In case the group was acquired from the virtual group, it's state will be
+		 * LEAVING_VIRTUAL and must be set to IDLE before it can be used. */
+		group = mali_pp_scheduler_acquire_physical_group();
+		if (NULL == group) {
+			/* Could not get a group to run the job on, early out. */
+			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: No more physical groups available.\n"));
+			break;
+		}
+
+		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Acquired physical group %p.\n", group));
+
+		/* Mark sub job as started. */
+		sub_job = mali_pp_job_get_first_unstarted_sub_job(job);
+		mali_pp_job_mark_sub_job_started(job, sub_job);
+
+		/* Remove job from queue (if this was the last sub job). */
+		mali_pp_scheduler_dequeue_physical_job(job);
+
+		/* Move group to working list. */
+		_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_working);
+
+		/* Keep track of this group, so that we actually can start the job once we are done with the scheduler lock we are now holding. */
+		physical_groups_to_start[num_physical_jobs_to_start] = group;
+		physical_jobs_to_start[num_physical_jobs_to_start] = job;
+		physical_sub_jobs_to_start[num_physical_jobs_to_start] = sub_job;
+		++num_physical_jobs_to_start;
+
+		MALI_DEBUG_ASSERT(num_physical_jobs_to_start < MALI_MAX_NUMBER_OF_PP_GROUPS);
+	}
+
+	if (mali_pp_scheduler_has_virtual_group()) {
+		if (VIRTUAL_GROUP_IDLE == virtual_group_state) {
+			/* We have a virtual group and it is idle. */
+
+			struct mali_pp_job *job;
+
+			/* Find a virtual job we can start. */
+			job = mali_pp_scheduler_get_virtual_job();
+
+			if (NULL != job) {
+				MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(job));
+				MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(job));
+				MALI_DEBUG_ASSERT(1 == mali_pp_job_get_sub_job_count(job));
+
+				/* Mark the one and only sub job as started. */
+				mali_pp_job_mark_sub_job_started(job, 0);
+
+				/* Remove job from queue. */
+				mali_pp_scheduler_dequeue_virtual_job(job);
+
+				/* Virtual group is now working. */
+				virtual_group_state = VIRTUAL_GROUP_WORKING;
+
+				/* We no longer need the scheduler lock, but we still need the virtual lock
+				 * in order to start the virtual job. */
+				mali_pp_scheduler_unlock();
+
+				/* Start job. */
+				mali_group_start_pp_job(virtual_group, job, 0);
+
+				MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Virtual job %u (0x%08X) part %u/%u started (from schedule).\n",
+				                     mali_pp_job_get_id(job), job, 1,
+				                     mali_pp_job_get_sub_job_count(job)));
+
+				mali_group_unlock(virtual_group);
+			} else {
+				/* No virtual job to start. */
+				mali_pp_scheduler_unlock();
+				mali_group_unlock(virtual_group);
+			}
+		} else {
+			/* We have a virtual group, but it is busy or disabled. */
+			MALI_DEBUG_ASSERT(VIRTUAL_GROUP_IDLE != virtual_group_state);
+
+			mali_pp_scheduler_unlock();
+			mali_group_unlock(virtual_group);
+		}
+	} else {
+		/* There is no virtual group. */
+		mali_pp_scheduler_unlock();
+	}
+
+	/* We have now released the scheduler lock, and we are ready to start the physical jobs.
+	 * The reason we want to wait until we have released the scheduler lock is that job start
+	 * may take quite a bit of time (many registers have to be written). This will allow new
+	 * jobs from user space to come in, and post-processing of other PP jobs to happen at the
+	 * same time as we start jobs. */
+	for (i = 0; i < num_physical_jobs_to_start; i++) {
+		struct mali_group *group = physical_groups_to_start[i];
+		struct mali_pp_job *job  = physical_jobs_to_start[i];
+		u32 sub_job              = physical_sub_jobs_to_start[i];
+
+		MALI_DEBUG_ASSERT_POINTER(group);
+		MALI_DEBUG_ASSERT_POINTER(job);
+		MALI_DEBUG_ASSERT(!mali_group_is_virtual(group));
+		MALI_DEBUG_ASSERT(!mali_pp_job_is_virtual(job));
+
+		mali_group_lock(group);
+
+		/* Set state to IDLE if group was acquired from the virtual group. */
+		group->state = MALI_GROUP_STATE_IDLE;
+
+		mali_group_start_pp_job(group, job, sub_job);
+
+		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Physical job %u (0x%08X) part %u/%u started (from schedule).\n",
+		                     mali_pp_job_get_id(job), job, sub_job + 1,
+		                     mali_pp_job_get_sub_job_count(job)));
+
+		mali_group_unlock(group);
+	}
+}
+
+/**
+ * Set group idle.
+ *
+ * If @ref group is the virtual group, nothing is done since the virtual group should be idle
+ * already.
+ *
+ * If @ref group is a physical group we rejoin the virtual group, if it exists.  If not, we move the
+ * physical group to the idle list.
+ *
+ * @note The group and the scheduler must both be locked when entering this function.  Both will be
+ * unlocked before exiting.
+ *
+ * @param group The group to set idle.
+ */
+static void mali_pp_scheduler_set_group_idle_and_unlock(struct mali_group *group)
+{
+	MALI_DEBUG_ASSERT_POINTER(group);
+
+	MALI_ASSERT_GROUP_LOCKED(group);
+	MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock);
+
+	if (mali_group_is_virtual(group)) {
+		/* The virtual group should have been set to non-working already. */
+		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_IDLE == virtual_group_state);
+
+		mali_pp_scheduler_unlock();
+		mali_group_unlock(group);
+
+		return;
+	} else {
+		if (mali_pp_scheduler_has_virtual_group()) {
+			/* Rejoin virtual group. */
+
+			/* We're no longer needed on the scheduler list. */
+			_mali_osk_list_delinit(&(group->pp_scheduler_list));
+
+			/* Make sure no interrupts are handled for this group during the transition
+			 * from physical to virtual. */
+			group->state = MALI_GROUP_STATE_JOINING_VIRTUAL;
+
+			mali_pp_scheduler_unlock();
+			mali_group_unlock(group);
+
+			mali_group_lock(virtual_group);
+
+			if (mali_pp_scheduler_has_virtual_group()) {
+				mali_pp_scheduler_enable_empty_virtual();
+			}
+
+			/* We need to recheck the group state since it is possible that someone has
+			 * modified the group before we locked the virtual group. */
+			if (MALI_GROUP_STATE_JOINING_VIRTUAL == group->state) {
+				mali_group_add_group(virtual_group, group, MALI_TRUE);
+			}
+
+			mali_group_unlock(virtual_group);
+		} else {
+			/* Move physical group back to idle list. */
+			_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_idle);
+
+#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
+			trace_gpu_sched_switch(mali_pp_get_hw_core_desc(group->pp_core), sched_clock(), 0, 0, 0);
+#endif
+
+			mali_pp_scheduler_unlock();
+			mali_group_unlock(group);
+		}
+	}
+}
+
+/**
+ * Schedule job on locked group.
+ *
+ * @note The group and the scheduler must both be locked when entering this function.  Both will be
+ * unlocked before exiting.
+ *
+ * @param group The group to schedule on.
+ */
+static void mali_pp_scheduler_schedule_on_group_and_unlock(struct mali_group *group)
+{
+	MALI_DEBUG_ASSERT_POINTER(group);
+
+	MALI_ASSERT_GROUP_LOCKED(group);
+	MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock);
+
+	if (mali_group_is_virtual(group)) {
+		/* Now that the virtual group is idle, check if we should reconfigure. */
+
+		struct mali_pp_job *virtual_job = NULL;
+		struct mali_pp_job *physical_job = NULL;
+		struct mali_group *physical_group = NULL;
+		u32 physical_sub_job = 0;
+
+		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_IDLE == virtual_group_state);
+
+		if (mali_pp_scheduler_can_move_virtual_to_physical()) {
+			/* There is a runnable physical job and we can acquire a physical group. */
+			physical_job = mali_pp_scheduler_get_physical_job();
+			MALI_DEBUG_ASSERT_POINTER(physical_job);
+			MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(physical_job));
+
+			/* Mark sub job as started. */
+			physical_sub_job = mali_pp_job_get_first_unstarted_sub_job(physical_job);
+			mali_pp_job_mark_sub_job_started(physical_job, physical_sub_job);
+
+			/* Remove job from queue (if this was the last sub job). */
+			mali_pp_scheduler_dequeue_physical_job(physical_job);
+
+			/* Acquire a physical group from the virtual group.  Its state will
+			 * be LEAVING_VIRTUAL and must be set to IDLE before it can be
+			 * used. */
+			physical_group = mali_group_acquire_group(virtual_group);
+
+			/* Move physical group to the working list, as we will soon start a job on it. */
+			_mali_osk_list_move(&(physical_group->pp_scheduler_list), &group_list_working);
+
+			mali_pp_scheduler_disable_empty_virtual();
+		}
+
+		/* Get next virtual job. */
+		virtual_job = mali_pp_scheduler_get_virtual_job();
+		if (NULL != virtual_job && VIRTUAL_GROUP_IDLE == virtual_group_state) {
+			/* There is a runnable virtual job. */
+
+			MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(virtual_job));
+			MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(virtual_job));
+			MALI_DEBUG_ASSERT(1 == mali_pp_job_get_sub_job_count(virtual_job));
+
+			mali_pp_job_mark_sub_job_started(virtual_job, 0);
+
+			/* Remove job from queue. */
+			mali_pp_scheduler_dequeue_virtual_job(virtual_job);
+
+			/* Virtual group is now working. */
+			virtual_group_state = VIRTUAL_GROUP_WORKING;
+
+			mali_pp_scheduler_unlock();
+
+			/* Start job. */
+			mali_group_start_pp_job(group, virtual_job, 0);
+
+			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Virtual job %u (0x%08X) part %u/%u started (from job_done).\n",
+			                     mali_pp_job_get_id(virtual_job), virtual_job, 1,
+			                     mali_pp_job_get_sub_job_count(virtual_job)));
+		} else {
+#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
+			trace_gpu_sched_switch("Mali_Virtual_PP", sched_clock(), 0, 0, 0);
+#endif
+
+			mali_pp_scheduler_unlock();
+		}
+
+		/* Releasing the virtual group lock that was held when entering the function. */
+		mali_group_unlock(group);
+
+		/* Start a physical job (if we acquired a physical group earlier). */
+		if (NULL != physical_job && NULL != physical_group) {
+			mali_group_lock(physical_group);
+
+			/* Change the group state from LEAVING_VIRTUAL to IDLE to complete the transition. */
+			physical_group->state = MALI_GROUP_STATE_IDLE;
+
+			/* Start job. */
+			mali_group_start_pp_job(physical_group, physical_job, physical_sub_job);
+
+			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Physical job %u (0x%08X) part %u/%u started (from job_done).\n",
+			                     mali_pp_job_get_id(physical_job), physical_job, physical_sub_job + 1,
+			                     mali_pp_job_get_sub_job_count(physical_job)));
+
+			mali_group_unlock(physical_group);
+		}
+	} else {
+		/* Physical group. */
+		struct mali_pp_job *job = NULL;
+		u32 sub_job = 0;
+
+		job = mali_pp_scheduler_get_physical_job();
+		if (NULL != job) {
+			/* There is a runnable physical job. */
+			MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(job));
+
+			/* Mark sub job as started. */
+			sub_job = mali_pp_job_get_first_unstarted_sub_job(job);
+			mali_pp_job_mark_sub_job_started(job, sub_job);
+
+			/* Remove job from queue (if this was the last sub job). */
+			mali_pp_scheduler_dequeue_physical_job(job);
+
+			mali_pp_scheduler_unlock();
+
+			/* Group is already on the working list, so start the new job. */
+			mali_group_start_pp_job(group, job, sub_job);
+
+			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Physical job %u (0x%08X) part %u/%u started (from job_done).\n",
+			                     mali_pp_job_get_id(job), job, sub_job + 1, mali_pp_job_get_sub_job_count(job)));
+
+			mali_group_unlock(group);
+		} else {
+			mali_pp_scheduler_set_group_idle_and_unlock(group);
+		}
+	}
+}
+
+void mali_pp_scheduler_job_done(struct mali_group *group, struct mali_pp_job *job, u32 sub_job, mali_bool success, mali_bool in_upper_half)
+{
+	mali_bool job_is_done = MALI_FALSE;
+	mali_bool schedule_on_group = MALI_FALSE;
+	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
+
+	MALI_DEBUG_PRINT(3, ("Mali PP scheduler: %s job %u (0x%08X) part %u/%u completed (%s).\n",
+	                     mali_pp_job_is_virtual(job) ? "Virtual" : "Physical",
+	                     mali_pp_job_get_id(job),
+	                     job, sub_job + 1,
+	                     mali_pp_job_get_sub_job_count(job),
+	                     success ? "success" : "failure"));
+
+	MALI_ASSERT_GROUP_LOCKED(group);
+	mali_pp_scheduler_lock();
+
+	mali_pp_job_mark_sub_job_completed(job, success);
+
+	MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(job) == mali_group_is_virtual(group));
+
+	job_is_done = mali_pp_job_is_complete(job);
+
+	if (job_is_done) {
+		/* Job is removed from these lists when the last sub job is scheduled. */
+		MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
+		MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_fb_lookup_list));
+
+		/* Remove job from session list. */
+		_mali_osk_list_delinit(&job->session_list);
+
+		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: All parts completed for %s job %u (0x%08X).\n",
+		                     mali_pp_job_is_virtual(job) ? "virtual" : "physical",
+		                     mali_pp_job_get_id(job), job));
+
+		mali_pp_scheduler_unlock();
+
+		/* Release tracker.  If other trackers are waiting on this tracker, this could
+		 * trigger activation.  The returned scheduling mask can be used to determine if we
+		 * have to schedule GP, PP or both. */
+		schedule_mask = mali_timeline_tracker_release(&job->tracker);
+
+		mali_pp_scheduler_lock();
+	}
+
+	if (mali_group_is_virtual(group)) {
+		/* Obey the policy. */
+		virtual_group_state = VIRTUAL_GROUP_IDLE;
+	}
+
+	/* If paused, then this was the last job, so wake up sleeping workers and return. */
+	if (pause_count > 0) {
+		/* Wake up sleeping workers. Their wake-up condition is that
+		 * num_slots == num_slots_idle, so unless we are done working, no
+		 * threads will actually be woken up.
+		 */
+		if (!mali_group_is_virtual(group)) {
+			/* Move physical group to idle list. */
+			_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_idle);
+		}
+
+#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
+		trace_gpu_sched_switch(mali_pp_get_hw_core_desc(group->pp_core), sched_clock(), 0, 0, 0);
+#endif
+
+		_mali_osk_wait_queue_wake_up(pp_scheduler_working_wait_queue);
+
+		mali_pp_scheduler_unlock();
+		mali_group_unlock(group);
+
+		if (job_is_done) {
+			/* Return job to user and delete it. */
+			mali_pp_scheduler_finalize_job(job);
+		}
+
+		/* A GP job might be queued by tracker release above,
+		 * make sure GP scheduler gets a chance to schedule this (if possible)
+		 */
+		mali_scheduler_schedule_from_mask(schedule_mask & ~MALI_SCHEDULER_MASK_PP, in_upper_half);
+
+		return;
+	}
+
+	/* Since this group just finished running a job, we can reschedule a new job on it
+	 * immediately. */
+
+	/* By default, don't schedule on group. */
+	schedule_on_group = MALI_FALSE;
+
+	if (mali_group_is_virtual(group)) {
+		/* Always schedule immediately on virtual group. */
+		schedule_mask &= ~MALI_SCHEDULER_MASK_PP;
+		schedule_on_group = MALI_TRUE;
+	} else if (0 < job_queue.depth && (!mali_scheduler_mask_is_set(schedule_mask, MALI_SCHEDULER_MASK_PP) || _mali_osk_list_empty(&group_list_idle))) {
+		struct mali_pp_job *next_job = NULL;
+
+		next_job = mali_pp_scheduler_get_physical_job();
+		MALI_DEBUG_ASSERT_POINTER(next_job);
+
+		/* If no new jobs have been queued or if this group is the only idle group, we can
+		 * schedule immediately on this group, unless we are GP bound and the next job would
+		 * benefit from all its sub jobs being started concurrently. */
+
+		if (mali_scheduler_hint_is_enabled(MALI_SCHEDULER_HINT_GP_BOUND) && mali_pp_job_is_large_and_unstarted(next_job)) {
+			/* We are GP bound and the job would benefit from all sub jobs being started
+			 * concurrently.  Postpone scheduling until after group has been unlocked. */
+			schedule_mask |= MALI_SCHEDULER_MASK_PP;
+			schedule_on_group = MALI_FALSE;
+		} else {
+			/* Schedule job immediately since we are not GP bound. */
+			schedule_mask &= ~MALI_SCHEDULER_MASK_PP;
+			schedule_on_group = MALI_TRUE;
+		}
+	}
+
+	if (schedule_on_group) {
+		/* Schedule a new job on this group. */
+		mali_pp_scheduler_schedule_on_group_and_unlock(group);
+	} else {
+		/* Set group idle.  Will rejoin virtual group, under appropriate conditions. */
+		mali_pp_scheduler_set_group_idle_and_unlock(group);
+	}
+
+	if (!schedule_on_group || MALI_SCHEDULER_MASK_EMPTY != schedule_mask) {
+		if (MALI_SCHEDULER_MASK_PP & schedule_mask) {
+			/* Schedule PP directly. */
+			mali_pp_scheduler_schedule();
+			schedule_mask &= ~MALI_SCHEDULER_MASK_PP;
+		}
+
+		/* Schedule other jobs that were activated. */
+		mali_scheduler_schedule_from_mask(schedule_mask, in_upper_half);
+	}
+
+	if (job_is_done) {
+		/* Return job to user and delete it. */
+		mali_pp_scheduler_finalize_job(job);
+	}
+}
+
+void mali_pp_scheduler_suspend(void)
+{
+	mali_pp_scheduler_lock();
+	pause_count++; /* Increment the pause_count so that no more jobs will be scheduled */
+	mali_pp_scheduler_unlock();
+
+	/* Go to sleep. When woken up again (in mali_pp_scheduler_job_done), the
+	 * mali_pp_scheduler_suspended() function will be called. This will return true
+	 * if state is idle and pause_count > 0, so if the core is active this
+	 * will not do anything.
+	 */
+	_mali_osk_wait_queue_wait_event(pp_scheduler_working_wait_queue, mali_pp_scheduler_is_suspended, NULL);
+}
+
+void mali_pp_scheduler_resume(void)
+{
+	mali_pp_scheduler_lock();
+	pause_count--; /* Decrement pause_count to allow scheduling again (if it reaches 0) */
+	mali_pp_scheduler_unlock();
+	if (0 == pause_count) {
+		mali_pp_scheduler_schedule();
+	}
+}
+
+mali_timeline_point mali_pp_scheduler_submit_job(struct mali_session_data *session, struct mali_pp_job *job)
+{
+	mali_timeline_point point;
+	u32 fb_lookup_id = 0;
+
+	MALI_DEBUG_ASSERT_POINTER(session);
+	MALI_DEBUG_ASSERT_POINTER(job);
+
+	mali_pp_scheduler_lock();
+
+	fb_lookup_id = mali_pp_job_get_fb_lookup_id(job);
+	MALI_DEBUG_ASSERT(MALI_PP_JOB_FB_LOOKUP_LIST_SIZE > fb_lookup_id);
+
+	/* Adding job to the lookup list used to quickly discard writeback units of queued jobs. */
+	_mali_osk_list_addtail(&job->session_fb_lookup_list, &session->pp_job_fb_lookup_list[fb_lookup_id]);
+
+	mali_pp_scheduler_unlock();
+
+	mali_pp_scheduler_job_queued();
+
+	/* Add job to Timeline system. */
+	point = mali_timeline_system_add_tracker(session->timeline_system, &job->tracker, MALI_TIMELINE_PP);
+
+	return point;
+}
+
+_mali_osk_errcode_t _mali_ukk_pp_start_job(void *ctx, _mali_uk_pp_start_job_s *uargs)
+{
+	struct mali_session_data *session;
+	struct mali_pp_job *job;
+	mali_timeline_point point;
+	u32 __user *timeline_point_ptr = NULL;
+
+	MALI_DEBUG_ASSERT_POINTER(uargs);
+	MALI_DEBUG_ASSERT_POINTER(ctx);
+
+	session = (struct mali_session_data*)ctx;
+
+	job = mali_pp_job_create(session, uargs, mali_scheduler_get_new_id());
+	if (NULL == job) {
+		MALI_PRINT_ERROR(("Failed to create PP job.\n"));
+		return _MALI_OSK_ERR_NOMEM;
+	}
+
+	timeline_point_ptr = (u32 __user *) job->uargs.timeline_point_ptr;
+
+	point = mali_pp_scheduler_submit_job(session, job);
+	job = NULL;
+
+	if (0 != _mali_osk_put_user(((u32) point), timeline_point_ptr)) {
+		/* Let user space know that something failed after the job was started. */
+		return _MALI_OSK_ERR_ITEM_NOT_FOUND;
+	}
+
+	return _MALI_OSK_ERR_OK;
+}
+
+_mali_osk_errcode_t _mali_ukk_pp_and_gp_start_job(void *ctx, _mali_uk_pp_and_gp_start_job_s *uargs)
+{
+	struct mali_session_data *session;
+	_mali_uk_pp_and_gp_start_job_s kargs;
+	struct mali_pp_job *pp_job;
+	struct mali_gp_job *gp_job;
+	u32 __user *timeline_point_ptr = NULL;
+	mali_timeline_point point;
+
+	MALI_DEBUG_ASSERT_POINTER(ctx);
+	MALI_DEBUG_ASSERT_POINTER(uargs);
+
+	session = (struct mali_session_data *) ctx;
+
+	if (0 != _mali_osk_copy_from_user(&kargs, uargs, sizeof(_mali_uk_pp_and_gp_start_job_s))) {
+		return _MALI_OSK_ERR_NOMEM;
+	}
+
+	pp_job = mali_pp_job_create(session, kargs.pp_args, mali_scheduler_get_new_id());
+	if (NULL == pp_job) {
+		MALI_PRINT_ERROR(("Failed to create PP job.\n"));
+		return _MALI_OSK_ERR_NOMEM;
+	}
+
+	gp_job = mali_gp_job_create(session, kargs.gp_args, mali_scheduler_get_new_id(), mali_pp_job_get_tracker(pp_job));
+	if (NULL == gp_job) {
+		MALI_PRINT_ERROR(("Failed to create GP job.\n"));
+		mali_pp_job_delete(pp_job);
+		return _MALI_OSK_ERR_NOMEM;
+	}
+
+	timeline_point_ptr = (u32 __user *) pp_job->uargs.timeline_point_ptr;
+
+	/* Submit GP job. */
+	mali_gp_scheduler_submit_job(session, gp_job);
+	gp_job = NULL;
+
+	/* Submit PP job. */
+	point = mali_pp_scheduler_submit_job(session, pp_job);
+	pp_job = NULL;
+
+	if (0 != _mali_osk_put_user(((u32) point), timeline_point_ptr)) {
+		/* Let user space know that something failed after the jobs were started. */
+		return _MALI_OSK_ERR_ITEM_NOT_FOUND;
+	}
+
+	return _MALI_OSK_ERR_OK;
+}
+
+_mali_osk_errcode_t _mali_ukk_get_pp_number_of_cores(_mali_uk_get_pp_number_of_cores_s *args)
+{
+	MALI_DEBUG_ASSERT_POINTER(args);
+	MALI_DEBUG_ASSERT_POINTER(args->ctx);
+	args->number_of_total_cores = num_cores;
+	args->number_of_enabled_cores = enabled_cores;
+	return _MALI_OSK_ERR_OK;
+}
+
+u32 mali_pp_scheduler_get_num_cores_total(void)
+{
+	return num_cores;
+}
+
+u32 mali_pp_scheduler_get_num_cores_enabled(void)
+{
+	return enabled_cores;
+}
+
+_mali_osk_errcode_t _mali_ukk_get_pp_core_version(_mali_uk_get_pp_core_version_s *args)
+{
+	MALI_DEBUG_ASSERT_POINTER(args);
+	MALI_DEBUG_ASSERT_POINTER(args->ctx);
+	args->version = pp_version;
+	return _MALI_OSK_ERR_OK;
+}
+
+void _mali_ukk_pp_job_disable_wb(_mali_uk_pp_disable_wb_s *args)
+{
+	struct mali_session_data *session;
+	struct mali_pp_job *job;
+	struct mali_pp_job *tmp;
+	u32 fb_lookup_id;
+
+	MALI_DEBUG_ASSERT_POINTER(args);
+	MALI_DEBUG_ASSERT_POINTER(args->ctx);
+
+	session = (struct mali_session_data*)args->ctx;
+
+	fb_lookup_id = args->fb_id & MALI_PP_JOB_FB_LOOKUP_LIST_MASK;
+
+	mali_pp_scheduler_lock();
+
+	/* Iterate over all jobs for given frame builder_id. */
+	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &session->pp_job_fb_lookup_list[fb_lookup_id], struct mali_pp_job, session_fb_lookup_list) {
+		MALI_DEBUG_CODE(u32 disable_mask = 0);
+
+		if (mali_pp_job_get_frame_builder_id(job) == (u32) args->fb_id) {
+			MALI_DEBUG_CODE(disable_mask |= 0xD<<(4*3));
+			if (args->wb0_memory == job->uargs.wb0_registers[MALI200_REG_ADDR_WB_SOURCE_ADDR/sizeof(u32)]) {
+				MALI_DEBUG_CODE(disable_mask |= 0x1<<(4*1));
+				mali_pp_job_disable_wb0(job);
+			}
+			if (args->wb1_memory == job->uargs.wb1_registers[MALI200_REG_ADDR_WB_SOURCE_ADDR/sizeof(u32)]) {
+				MALI_DEBUG_CODE(disable_mask |= 0x2<<(4*2));
+				mali_pp_job_disable_wb1(job);
+			}
+			if (args->wb2_memory == job->uargs.wb2_registers[MALI200_REG_ADDR_WB_SOURCE_ADDR/sizeof(u32)]) {
+				MALI_DEBUG_CODE(disable_mask |= 0x3<<(4*3));
+				mali_pp_job_disable_wb2(job);
+			}
+			MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Disable WB: 0x%X.\n", disable_mask));
+		} else {
+			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Disable WB mismatching FB.\n"));
+		}
+	}
+
+	mali_pp_scheduler_unlock();
+}
+
+void mali_pp_scheduler_abort_session(struct mali_session_data *session)
+{
+	u32 i = 0;
+	struct mali_pp_job *job, *tmp_job;
+	struct mali_group *group, *tmp_group;
+	struct mali_group *groups[MALI_MAX_NUMBER_OF_GROUPS];
+	_MALI_OSK_LIST_HEAD_STATIC_INIT(removed_jobs);
+
+	MALI_DEBUG_ASSERT_POINTER(session);
+	MALI_DEBUG_ASSERT(session->is_aborting);
+
+	MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Aborting all jobs from session 0x%08X.\n", session));
+
+	mali_pp_scheduler_lock();
+
+	/* Find all jobs from the aborting session. */
+	_MALI_OSK_LIST_FOREACHENTRY(job, tmp_job, &session->pp_job_list, struct mali_pp_job, session_list) {
+		/* Remove job from queue. */
+		if (mali_pp_job_is_virtual(job)) {
+			MALI_DEBUG_ASSERT(1 == mali_pp_job_get_sub_job_count(job));
+			if (0 == mali_pp_job_get_first_unstarted_sub_job(job)) {
+				--virtual_job_queue.depth;
+			}
+		} else {
+			job_queue.depth -= mali_pp_job_get_sub_job_count(job) - mali_pp_job_get_first_unstarted_sub_job(job);
+		}
+
+		_mali_osk_list_delinit(&job->list);
+		_mali_osk_list_delinit(&job->session_fb_lookup_list);
+
+		mali_pp_job_mark_unstarted_failed(job);
+
+		if (mali_pp_job_is_complete(job)) {
+			/* Job is complete, remove from session list. */
+			_mali_osk_list_delinit(&job->session_list);
+
+			/* Move job to local list for release and deletion. */
+			_mali_osk_list_add(&job->list, &removed_jobs);
+
+			MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Aborted PP job %u (0x%08X).\n", mali_pp_job_get_id(job), job));
+		} else {
+			MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Keeping partially started PP job %u (0x%08X) in session.\n", mali_pp_job_get_id(job), job));
+		}
+	}
+
+	_MALI_OSK_LIST_FOREACHENTRY(group, tmp_group, &group_list_working, struct mali_group, pp_scheduler_list) {
+		groups[i++] = group;
+	}
+
+	_MALI_OSK_LIST_FOREACHENTRY(group, tmp_group, &group_list_idle, struct mali_group, pp_scheduler_list) {
+		groups[i++] = group;
+	}
+
+	mali_pp_scheduler_unlock();
+
+	/* Release and delete all found jobs from the aborting session. */
+	_MALI_OSK_LIST_FOREACHENTRY(job, tmp_job, &removed_jobs, struct mali_pp_job, list) {
+		mali_timeline_tracker_release(&job->tracker);
+		mali_pp_job_delete(job);
+		mali_pp_scheduler_job_completed();
+	}
+
+	/* Abort any running jobs from the session. */
+	while (i > 0) {
+		mali_group_abort_session(groups[--i], session);
+	}
+
+	if (mali_pp_scheduler_has_virtual_group()) {
+		mali_group_abort_session(virtual_group, session);
+	}
+}
+
+static mali_bool mali_pp_scheduler_is_suspended(void *data)
+{
+	mali_bool ret;
+
+	/* This callback does not use the data pointer. */
+	MALI_IGNORE(data);
+
+	mali_pp_scheduler_lock();
+
+	ret = pause_count > 0
+	      && _mali_osk_list_empty(&group_list_working)
+	      && VIRTUAL_GROUP_WORKING != virtual_group_state;
+
+	mali_pp_scheduler_unlock();
+
+	return ret;
+}
+
+struct mali_pp_core *mali_pp_scheduler_get_virtual_pp(void)
+{
+	if (mali_pp_scheduler_has_virtual_group()) {
+		return mali_group_get_pp_core(virtual_group);
+	} else {
+		return NULL;
+	}
+}
+
+#if MALI_STATE_TRACKING
+u32 mali_pp_scheduler_dump_state(char *buf, u32 size)
+{
+	int n = 0;
+	struct mali_group *group;
+	struct mali_group *temp;
+
+	n += _mali_osk_snprintf(buf + n, size - n, "PP:\n");
+	n += _mali_osk_snprintf(buf + n, size - n, "\tQueue is %s\n", _mali_osk_list_empty(&job_queue.normal_pri) ? "empty" : "not empty");
+	n += _mali_osk_snprintf(buf + n, size - n, "\tHigh priority queue is %s\n", _mali_osk_list_empty(&job_queue.high_pri) ? "empty" : "not empty");
+	n += _mali_osk_snprintf(buf + n, size - n, "\n");
+
+	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_working, struct mali_group, pp_scheduler_list) {
+		n += mali_group_dump_state(group, buf + n, size - n);
+	}
+
+	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_idle, struct mali_group, pp_scheduler_list) {
+		n += mali_group_dump_state(group, buf + n, size - n);
+	}
+
+	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_disabled, struct mali_group, pp_scheduler_list) {
+		n += mali_group_dump_state(group, buf + n, size - n);
+	}
+
+	if (mali_pp_scheduler_has_virtual_group()) {
+		n += mali_group_dump_state(virtual_group, buf + n, size -n);
+	}
+
+	n += _mali_osk_snprintf(buf + n, size - n, "\n");
+	return n;
+}
+#endif
+
+/* This function is intended for power on reset of all cores.
+ * No locking is done for the list iteration, which can only be safe if the
+ * scheduler is paused and all cores idle. That is always the case on init and
+ * power on. */
+void mali_pp_scheduler_reset_all_groups(void)
+{
+	struct mali_group *group, *temp;
+	struct mali_group *groups[MALI_MAX_NUMBER_OF_GROUPS];
+	s32 i = 0;
+
+	if (mali_pp_scheduler_has_virtual_group()) {
+		mali_group_lock(virtual_group);
+		mali_group_reset(virtual_group);
+		mali_group_unlock(virtual_group);
+	}
+
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&group_list_working));
+	MALI_DEBUG_ASSERT(VIRTUAL_GROUP_WORKING != virtual_group_state);
+	mali_pp_scheduler_lock();
+	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_idle, struct mali_group, pp_scheduler_list) {
+		groups[i++] = group;
+	}
+	mali_pp_scheduler_unlock();
+
+	while (i > 0) {
+		group = groups[--i];
+
+		mali_group_lock(group);
+		mali_group_reset(group);
+		mali_group_unlock(group);
+	}
+}
+
+void mali_pp_scheduler_zap_all_active(struct mali_session_data *session)
+{
+	struct mali_group *group, *temp;
+	struct mali_group *groups[MALI_MAX_NUMBER_OF_GROUPS];
+	s32 i = 0;
+
+	if (mali_pp_scheduler_has_virtual_group()) {
+		mali_group_zap_session(virtual_group, session);
+	}
+
+	mali_pp_scheduler_lock();
+	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_working, struct mali_group, pp_scheduler_list) {
+		groups[i++] = group;
+	}
+	mali_pp_scheduler_unlock();
+
+	while (i > 0) {
+		mali_group_zap_session(groups[--i], session);
+	}
+}
+
+/* A pm reference must be taken with _mali_osk_pm_dev_ref_add_no_power_on
+ * before calling this function to avoid Mali powering down as HW is accessed.
+ */
+static void mali_pp_scheduler_enable_group_internal(struct mali_group *group)
+{
+	MALI_DEBUG_ASSERT_POINTER(group);
+
+	mali_group_lock(group);
+
+	if (MALI_GROUP_STATE_DISABLED != group->state) {
+		mali_group_unlock(group);
+		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: PP group %p already enabled.\n", group));
+		return;
+	}
+
+	MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Enabling PP group %p.\n", group));
+
+	mali_pp_scheduler_lock();
+
+	MALI_DEBUG_ASSERT(MALI_GROUP_STATE_DISABLED == group->state);
+	++enabled_cores;
+
+	if (mali_pp_scheduler_has_virtual_group()) {
+		mali_bool update_hw;
+
+		/* Add group to virtual group. */
+		_mali_osk_list_delinit(&(group->pp_scheduler_list));
+		group->state = MALI_GROUP_STATE_JOINING_VIRTUAL;
+
+		mali_pp_scheduler_unlock();
+		mali_group_unlock(group);
+
+		mali_group_lock(virtual_group);
+
+		update_hw = mali_pm_is_power_on();
+		/* Get ref of group domain */
+		mali_group_get_pm_domain_ref(group);
+
+		MALI_DEBUG_ASSERT(NULL == group->pm_domain ||
+		                  MALI_PM_DOMAIN_ON == mali_pm_domain_state_get(group->pm_domain));
+
+		if (update_hw) {
+			mali_group_lock(group);
+			mali_group_power_on_group(group);
+			mali_group_reset(group);
+			mali_group_unlock(group);
+		}
+
+		mali_pp_scheduler_enable_empty_virtual();
+		mali_group_add_group(virtual_group, group, update_hw);
+		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Done enabling group %p. Added to virtual group.\n", group));
+
+		mali_group_unlock(virtual_group);
+	} else {
+		/* Get ref of group domain */
+		mali_group_get_pm_domain_ref(group);
+
+		MALI_DEBUG_ASSERT(NULL == group->pm_domain ||
+		                  MALI_PM_DOMAIN_ON == mali_pm_domain_state_get(group->pm_domain));
+
+		/* Put group on idle list. */
+		if (mali_pm_is_power_on()) {
+			mali_group_power_on_group(group);
+			mali_group_reset(group);
+		}
+
+		_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_idle);
+		group->state = MALI_GROUP_STATE_IDLE;
+
+		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Done enabling group %p. Now on idle list.\n", group));
+		mali_pp_scheduler_unlock();
+		mali_group_unlock(group);
+	}
+}
+
+void mali_pp_scheduler_enable_group(struct mali_group *group)
+{
+	MALI_DEBUG_ASSERT_POINTER(group);
+
+	_mali_osk_pm_dev_ref_add_no_power_on();
+
+	mali_pp_scheduler_enable_group_internal(group);
+
+	_mali_osk_pm_dev_ref_dec_no_power_on();
+
+	/* Pick up any jobs that might have been queued if all PP groups were disabled. */
+	mali_pp_scheduler_schedule();
+}
+
+static void mali_pp_scheduler_disable_group_internal(struct mali_group *group)
+{
+	if (mali_pp_scheduler_has_virtual_group()) {
+		mali_group_lock(virtual_group);
+
+		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_WORKING != virtual_group_state);
+		if (MALI_GROUP_STATE_JOINING_VIRTUAL == group->state) {
+			/* The group was in the process of being added to the virtual group.  We
+			 * only need to change the state to reverse this. */
+			group->state = MALI_GROUP_STATE_LEAVING_VIRTUAL;
+		} else if (MALI_GROUP_STATE_IN_VIRTUAL == group->state) {
+			/* Remove group from virtual group.  The state of the group will be
+			 * LEAVING_VIRTUAL and the group will not be on any scheduler list. */
+			mali_group_remove_group(virtual_group, group);
+
+			mali_pp_scheduler_disable_empty_virtual();
+		}
+
+		mali_group_unlock(virtual_group);
+	}
+
+	mali_group_lock(group);
+	mali_pp_scheduler_lock();
+
+	MALI_DEBUG_ASSERT(   MALI_GROUP_STATE_IDLE            == group->state
+	                     || MALI_GROUP_STATE_LEAVING_VIRTUAL == group->state
+	                     || MALI_GROUP_STATE_DISABLED        == group->state);
+
+	if (MALI_GROUP_STATE_DISABLED == group->state) {
+		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: PP group %p already disabled.\n", group));
+	} else {
+		MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Disabling PP group %p.\n", group));
+
+		--enabled_cores;
+		_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_disabled);
+		group->state = MALI_GROUP_STATE_DISABLED;
+
+		mali_group_power_off_group(group, MALI_TRUE);
+		mali_group_put_pm_domain_ref(group);
+	}
+
+	mali_pp_scheduler_unlock();
+	mali_group_unlock(group);
+}
+
+void mali_pp_scheduler_disable_group(struct mali_group *group)
+{
+	MALI_DEBUG_ASSERT_POINTER(group);
+
+	mali_pp_scheduler_suspend();
+
+	_mali_osk_pm_dev_ref_add_no_power_on();
+
+	mali_pp_scheduler_disable_group_internal(group);
+
+	_mali_osk_pm_dev_ref_dec_no_power_on();
+
+	mali_pp_scheduler_resume();
+}
+
+static void mali_pp_scheduler_notify_core_change(u32 num_cores)
+{
+	mali_bool done = MALI_FALSE;
+
+	if (mali_is_mali450()) {
+		return;
+	}
+
+	/*
+	 * This function gets a bit complicated because we can't hold the session lock while
+	 * allocating notification objects.
+	 */
+
+	while (!done) {
+		u32 i;
+		u32 num_sessions_alloc;
+		u32 num_sessions_with_lock;
+		u32 used_notification_objects = 0;
+		_mali_osk_notification_t **notobjs;
+
+		/* Pre allocate the number of notifications objects we need right now (might change after lock has been taken) */
+		num_sessions_alloc = mali_session_get_count();
+		if (0 == num_sessions_alloc) {
+			/* No sessions to report to */
+			return;
+		}
+
+		notobjs = (_mali_osk_notification_t **)_mali_osk_malloc(sizeof(_mali_osk_notification_t *) * num_sessions_alloc);
+		if (NULL == notobjs) {
+			MALI_PRINT_ERROR(("Failed to notify user space session about num PP core change (alloc failure)\n"));
+			/* there is probably no point in trying again, system must be really low on memory and probably unusable now anyway */
+			return;
+		}
+
+		for (i = 0; i < num_sessions_alloc; i++) {
+			notobjs[i] = _mali_osk_notification_create(_MALI_NOTIFICATION_PP_NUM_CORE_CHANGE, sizeof(_mali_uk_pp_num_cores_changed_s));
+			if (NULL != notobjs[i]) {
+				_mali_uk_pp_num_cores_changed_s *data = notobjs[i]->result_buffer;
+				data->number_of_enabled_cores = num_cores;
+			} else {
+				MALI_PRINT_ERROR(("Failed to notify user space session about num PP core change (alloc failure %u)\n", i));
+			}
+		}
+
+		mali_session_lock();
+
+		/* number of sessions will not change while we hold the lock */
+		num_sessions_with_lock = mali_session_get_count();
+
+		if (num_sessions_alloc >= num_sessions_with_lock) {
+			/* We have allocated enough notification objects for all the sessions atm */
+			struct mali_session_data *session, *tmp;
+			MALI_SESSION_FOREACH(session, tmp, link) {
+				MALI_DEBUG_ASSERT(used_notification_objects < num_sessions_alloc);
+				if (NULL != notobjs[used_notification_objects]) {
+					mali_session_send_notification(session, notobjs[used_notification_objects]);
+					notobjs[used_notification_objects] = NULL; /* Don't track this notification object any more */
+				}
+				used_notification_objects++;
+			}
+			done = MALI_TRUE;
+		}
+
+		mali_session_unlock();
+
+		/* Delete any remaining/unused notification objects */
+		for (; used_notification_objects < num_sessions_alloc; used_notification_objects++) {
+			if (NULL != notobjs[used_notification_objects]) {
+				_mali_osk_notification_delete(notobjs[used_notification_objects]);
+			}
+		}
+
+		_mali_osk_free(notobjs);
+	}
+}
+
+static void mali_pp_scheduler_core_scale_up(unsigned int target_core_nr)
+{
+	MALI_DEBUG_PRINT(3, ("Requesting %d cores: enabling %d cores\n", target_core_nr, target_core_nr - enabled_cores));
+
+	_mali_osk_pm_dev_ref_add_no_power_on();
+	_mali_osk_pm_dev_barrier();
+
+	while (target_core_nr > enabled_cores) {
+		/*
+		 * If there are any cores which do not belong to any domain,
+		 * then these will always be found at the head of the list and
+		 * we'll thus enabled these first.
+		 */
+
+		mali_pp_scheduler_lock();
+
+		if (!_mali_osk_list_empty(&group_list_disabled)) {
+			struct mali_group *group;
+
+			group = _MALI_OSK_LIST_ENTRY(group_list_disabled.next, struct mali_group, pp_scheduler_list);
+
+			MALI_DEBUG_ASSERT_POINTER(group);
+			MALI_DEBUG_ASSERT(MALI_GROUP_STATE_DISABLED == group->state);
+
+			mali_pp_scheduler_unlock();
+
+			mali_pp_scheduler_enable_group_internal(group);
+		} else {
+			mali_pp_scheduler_unlock();
+			break; /* no more groups on disabled list */
+		}
+	}
+
+	_mali_osk_pm_dev_ref_dec_no_power_on();
+
+	mali_pp_scheduler_schedule();
+}
+
+static void mali_pp_scheduler_core_scale_down(unsigned int target_core_nr)
+{
+	MALI_DEBUG_PRINT(3, ("Requesting %d cores: disabling %d cores\n", target_core_nr, enabled_cores - target_core_nr));
+
+	mali_pp_scheduler_suspend();
+
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&group_list_working));
+
+	_mali_osk_pm_dev_ref_add_no_power_on();
+
+	if (NULL != mali_pmu_get_global_pmu_core()) {
+		int i;
+
+		for (i = MALI_MAX_NUMBER_OF_DOMAINS - 1; i >= 0; i--) {
+			if (target_core_nr < enabled_cores) {
+				struct mali_pm_domain *domain;
+
+				domain = mali_pm_domain_get_from_index(i);
+
+				/* Domain is valid and has pp cores */
+				if ((NULL != domain) && (NULL != domain->group_list)) {
+					struct mali_group *group;
+
+					MALI_PM_DOMAIN_FOR_EACH_GROUP(group, domain) {
+						/* If group is pp core */
+						if (NULL != mali_group_get_pp_core(group)) {
+							mali_pp_scheduler_disable_group_internal(group);
+							if (target_core_nr >= enabled_cores) {
+								break;
+							}
+						}
+					}
+				}
+			} else {
+				break;
+			}
+		}
+	}
+
+	/*
+	 * Didn't find enough cores associated with a power domain,
+	 * so we need to disable cores which we can't power off with the PMU.
+	 * Start with physical groups used by the scheduler,
+	 * then remove physical from virtual if even more groups are needed.
+	 */
+
+	while (target_core_nr < enabled_cores) {
+		mali_pp_scheduler_lock();
+		if (!_mali_osk_list_empty(&group_list_idle)) {
+			struct mali_group *group;
+
+			group = _MALI_OSK_LIST_ENTRY(group_list_idle.next, struct mali_group, pp_scheduler_list);
+			MALI_DEBUG_ASSERT_POINTER(group);
+
+			mali_pp_scheduler_unlock();
+
+			mali_pp_scheduler_disable_group_internal(group);
+		} else {
+			mali_pp_scheduler_unlock();
+			break; /* No more physical groups */
+		}
+	}
+
+	if (mali_pp_scheduler_has_virtual_group()) {
+		while (target_core_nr < enabled_cores) {
+			mali_group_lock(virtual_group);
+			if (!_mali_osk_list_empty(&virtual_group->group_list)) {
+				struct mali_group *group;
+
+				group = _MALI_OSK_LIST_ENTRY(virtual_group->group_list.next, struct mali_group, group_list);
+				MALI_DEBUG_ASSERT_POINTER(group);
+
+				mali_group_unlock(virtual_group);
+
+				mali_pp_scheduler_disable_group_internal(group);
+			} else {
+				mali_group_unlock(virtual_group);
+				break; /* No more physical groups in virtual group */
+			}
+		}
+	}
+
+	_mali_osk_pm_dev_ref_dec_no_power_on();
+
+	mali_pp_scheduler_resume();
+}
+
+int mali_pp_scheduler_set_perf_level(unsigned int target_core_nr, mali_bool override)
+{
+	if (target_core_nr == enabled_cores) return 0;
+	if (MALI_FALSE == core_scaling_enabled && MALI_FALSE == override) return -EPERM;
+	if (target_core_nr > num_cores) return -EINVAL;
+	if (0 == target_core_nr) return -EINVAL;
+
+	if (target_core_nr > enabled_cores) {
+		mali_pp_scheduler_core_scale_up(target_core_nr);
+	} else if (target_core_nr < enabled_cores) {
+		mali_pp_scheduler_core_scale_down(target_core_nr);
+	}
+
+	if (target_core_nr != enabled_cores) {
+		MALI_DEBUG_PRINT(2, ("Core scaling failed, target number: %d, actual number: %d\n", target_core_nr, enabled_cores));
+	}
+
+	mali_pp_scheduler_notify_core_change(enabled_cores);
+
+	return 0;
+}
+
+void mali_pp_scheduler_core_scaling_enable(void)
+{
+	/* PS: Core scaling is by default enabled */
+	core_scaling_enabled = MALI_TRUE;
+}
+
+void mali_pp_scheduler_core_scaling_disable(void)
+{
+	core_scaling_enabled = MALI_FALSE;
+}
+
+mali_bool mali_pp_scheduler_core_scaling_is_enabled(void)
+{
+	return core_scaling_enabled;
+}
+
+static void mali_pp_scheduler_job_queued(void)
+{
+	/* We hold a PM reference for every job we hold queued (and running) */
+	_mali_osk_pm_dev_ref_add();
+
+	if (mali_utilization_enabled()) {
+		/*
+		 * We cheat a little bit by counting the PP as busy from the time a PP job is queued.
+		 * This will be fine because we only loose the tiny idle gap between jobs, but
+		 * we will instead get less utilization work to do (less locks taken)
+		 */
+		mali_utilization_pp_start();
+	}
+}
+
+static void mali_pp_scheduler_job_completed(void)
+{
+	/* Release the PM reference we got in the mali_pp_scheduler_job_queued() function */
+	_mali_osk_pm_dev_ref_dec();
+
+	if (mali_utilization_enabled()) {
+		mali_utilization_pp_end();
+	}
+}
+
+static void mali_pp_scheduler_abort_job_and_unlock_scheduler(struct mali_pp_job *job)
+{
+	MALI_DEBUG_ASSERT_POINTER(job);
+	MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock);
+
+	/* This job should not be on any lists. */
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
+	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_list));
+
+	_mali_osk_list_delinit(&job->session_fb_lookup_list);
+
+	mali_pp_scheduler_unlock();
+
+	/* Release tracker. */
+	mali_timeline_tracker_release(&job->tracker);
+}
+
+static mali_scheduler_mask mali_pp_scheduler_queue_job(struct mali_pp_job *job)
+{
+	_mali_osk_list_t *queue = NULL;
+	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
+	struct mali_pp_job *iter, *tmp;
+
+	MALI_DEBUG_ASSERT_POINTER(job);
+	MALI_DEBUG_ASSERT_POINTER(job->session);
+
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
+	if (mali_pp_job_needs_dma_buf_mapping(job)) {
+		mali_dma_buf_map_job(job);
+	}
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
+
+	mali_pp_scheduler_lock();
+
+	if (unlikely(job->session->is_aborting)) {
+		/* Before checking if the session is aborting, the scheduler must be locked. */
+		MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock);
+
+		MALI_DEBUG_PRINT(2, ("Mali PP scheduler: Job %u (0x%08X) queued while session is aborting.\n", mali_pp_job_get_id(job), job));
+
+		mali_pp_scheduler_abort_job_and_unlock_scheduler(job);
+
+		/* Delete job. */
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
+		mali_pp_scheduler_deferred_job_delete(job);
+#else
+		mali_pp_job_delete(job);
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
+		mali_pp_scheduler_job_completed();
+
+		/* Since we are aborting we ignore the scheduler mask. */
+		return MALI_SCHEDULER_MASK_EMPTY;
+	}
+
+#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
+	trace_gpu_job_enqueue(mali_pp_job_get_tid(job), mali_pp_job_get_id(job), "PP");
+#endif
+
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE | MALI_PROFILING_EVENT_CHANNEL_SOFTWARE | MALI_PROFILING_EVENT_REASON_SINGLE_SW_PP_ENQUEUE, job->pid, job->tid, job->uargs.frame_builder_id, job->uargs.flush_id, 0);
+
+	job->cache_order = mali_scheduler_get_new_cache_order();
+
+	/* Determine which queue the job should be added to. */
+	if (mali_pp_job_is_virtual(job)) {
+		if (job->session->use_high_priority_job_queue) {
+			queue = &virtual_job_queue.high_pri;
+		} else {
+			queue = &virtual_job_queue.normal_pri;
+		}
+
+		virtual_job_queue.depth += 1;
+
+		/* Set schedule bitmask if the virtual group is idle. */
+		if (VIRTUAL_GROUP_IDLE == virtual_group_state) {
+			schedule_mask |= MALI_SCHEDULER_MASK_PP;
+		}
+	} else {
+		if (job->session->use_high_priority_job_queue) {
+			queue = &job_queue.high_pri;
+		} else {
+			queue = &job_queue.normal_pri;
+		}
+
+		job_queue.depth += mali_pp_job_get_sub_job_count(job);
+
+		/* Set schedule bitmask if there are physical PP cores available, or if there is an
+		 * idle virtual group. */
+		if (!_mali_osk_list_empty(&group_list_idle)
+		    || (mali_pp_scheduler_has_virtual_group()
+		        && (VIRTUAL_GROUP_IDLE == virtual_group_state))) {
+			schedule_mask |= MALI_SCHEDULER_MASK_PP;
+		}
+	}
+
+	/* Find position in queue where job should be added. */
+	_MALI_OSK_LIST_FOREACHENTRY_REVERSE(iter, tmp, queue, struct mali_pp_job, list) {
+		if (mali_pp_job_should_start_after(job, iter)) {
+			break;
+		}
+	}
+
+	/* Add job to queue. */
+	_mali_osk_list_add(&job->list, &iter->list);
+
+	/* Add job to session list. */
+	_mali_osk_list_addtail(&job->session_list, &(job->session->pp_job_list));
+
+	MALI_DEBUG_PRINT(3, ("Mali PP scheduler: %s job %u (0x%08X) with %u parts queued.\n",
+	                     mali_pp_job_is_virtual(job) ? "Virtual" : "Physical",
+	                     mali_pp_job_get_id(job), job, mali_pp_job_get_sub_job_count(job)));
+
+	mali_pp_scheduler_unlock();
+
+	return schedule_mask;
+}
+
+mali_scheduler_mask mali_pp_scheduler_activate_job(struct mali_pp_job *job)
+{
+	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
+
+	MALI_DEBUG_ASSERT_POINTER(job);
+	MALI_DEBUG_ASSERT_POINTER(job->session);
+
+	MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Timeline activation for job %u (0x%08X).\n", mali_pp_job_get_id(job), job));
+
+	if (MALI_TIMELINE_ACTIVATION_ERROR_FATAL_BIT & job->tracker.activation_error) {
+		MALI_DEBUG_PRINT(2, ("Mali PP scheduler: Job %u (0x%08X) activated with error, aborting.\n", mali_pp_job_get_id(job), job));
+
+		mali_pp_scheduler_lock();
+		mali_pp_scheduler_abort_job_and_unlock_scheduler(job);
+
+		mali_pp_job_mark_sub_job_completed(job, MALI_FALSE); /* Flagging the job as failed. */
+		mali_pp_scheduler_finalize_job(job);
+
+		return MALI_SCHEDULER_MASK_EMPTY;
+	}
+
+	/* PP job is ready to run, queue it. */
+
+#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
+	if (mali_pp_job_needs_dma_buf_mapping(job)) {
+		mali_pp_scheduler_deferred_job_queue(job);
+
+		return MALI_SCHEDULER_MASK_EMPTY;
+	}
+#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
+
+	schedule_mask = mali_pp_scheduler_queue_job(job);
+
+	return schedule_mask;
+}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp_scheduler.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp_scheduler.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_pp_scheduler.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_pp_scheduler.h	2016-04-04 16:25:32.128527000 +0300
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
+ * 
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ * 
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __MALI_PP_SCHEDULER_H__
+#define __MALI_PP_SCHEDULER_H__
+
+#include "mali_osk.h"
+#include "mali_pp_job.h"
+#include "mali_group.h"
+#include "linux/mali/mali_utgard.h"
+
+/** Initalize the HW independent parts of the  PP scheduler
+ */
+_mali_osk_errcode_t mali_pp_scheduler_initialize(void);
+void mali_pp_scheduler_terminate(void);
+
+/** Poplulate the PP scheduler with groups
+ */
+void mali_pp_scheduler_populate(void);
+void mali_pp_scheduler_depopulate(void);
+
+/**
+ * @brief Handle job completion.
+ *
+ * Will attempt to start a new job on the locked group.
+ *
+ * If all sub jobs have completed the job's tracker will be released, any other resources associated
+ * with the job will be freed.  A notification will also be sent to user space.
+ *
+ * Releasing the tracker might activate other jobs, so if appropriate we also schedule them.
+ *
+ * @note Group must be locked when entering this function.  Will be unlocked before exiting.
+ *
+ * @param group The group that completed the job.
+ * @param job The job that is done.
+ * @param sub_job Sub job of job.
+ * @param success MALI_TRUE if job completed successfully, MALI_FALSE if not.
+ * @param in_upper_half MALI_TRUE if called from upper half, MALI_FALSE if not.
+ */
+void mali_pp_scheduler_job_done(struct mali_group *group, struct mali_pp_job *job, u32 sub_job, mali_bool success, mali_bool in_upper_half);
+
+void mali_pp_scheduler_suspend(void);
+void mali_pp_scheduler_resume(void);
+
+/**
+ * @brief Abort all running and queued PP jobs from session.
+ *
+ * This functions aborts all PP jobs from the specified session. Queued jobs are removed from the
+ * queue and jobs currently running on a core will be aborted.
+ *
+ * @param session Session that is aborting.
+ */
+void mali_pp_scheduler_abort_session(struct mali_session_data *session);
+
+/**
+ * @brief Reset all groups
+ *
+ * This function resets all groups known by the PP scheuduler. This must be
+ * called after the Mali HW has been powered on in order to reset the HW.
+ *
+ * This function is intended for power on reset of all cores.
+ * No locking is done, which can only be safe if the scheduler is paused and
+ * all cores idle. That is always the case on init and power on.
+ */
+void mali_pp_scheduler_reset_all_groups(void);
+
+/**
+ * @brief Zap TLB on all groups with \a session active
+ *
+ * The scheculer will zap the session on all groups it owns.
+ */
+void mali_pp_scheduler_zap_all_active(struct mali_session_data *session);
+
+/**
+ * @brief Get the virtual PP core
+ *
+ * The returned PP core may only be used to prepare DMA command buffers for the
+ * PP core. Other actions must go through the PP scheduler, or the virtual
+ * group.
+ *
+ * @return Pointer to the virtual PP core, NULL if this doesn't exist
+ */
+struct mali_pp_core *mali_pp_scheduler_get_virtual_pp(void);
+
+u32 mali_pp_scheduler_dump_state(char *buf, u32 size);
+
+void mali_pp_scheduler_enable_group(struct mali_group *group);
+void mali_pp_scheduler_disable_group(struct mali_group *group);
+
+/**
+ * @brief Used by the Timeline system to queue a PP job.
+ *
+ * @note @ref mali_scheduler_schedule_from_mask() should be called if this function returns non-zero.
+ *
+ * @param job The PP job that is being activated.
+ *
+ * @return A scheduling bitmask that can be used to decide if scheduling is necessary after this
+ * call.
+ */
+mali_scheduler_mask mali_pp_scheduler_activate_job(struct mali_pp_job *job);
+
+/**
+ * @brief Schedule queued jobs on idle cores.
+ */
+void mali_pp_scheduler_schedule(void);
+
+int mali_pp_scheduler_set_perf_level(u32 cores, mali_bool override);
+
+void mali_pp_scheduler_core_scaling_enable(void);
+void mali_pp_scheduler_core_scaling_disable(void);
+mali_bool mali_pp_scheduler_core_scaling_is_enabled(void);
+
+u32 mali_pp_scheduler_get_num_cores_total(void);
+u32 mali_pp_scheduler_get_num_cores_enabled(void);
+
+/**
+ * @brief Returns the number of Pixel Processors in the system irrespective of the context
+ *
+ * @return number of physical Pixel Processor cores in the system
+ */
+u32 mali_pp_scheduler_get_num_cores_total(void);
+
+#endif /* __MALI_PP_SCHEDULER_H__ */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_scheduler.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_scheduler.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_scheduler.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_scheduler.c	2016-04-04 16:25:32.138527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -1266,8 +1266,8 @@
 			/* unlock scheduler in this uncommon case */
 			mali_scheduler_unlock();
 
-			schedule_mask |= mali_timeline_tracker_release(
-						 mali_pp_job_get_tracker(job));
+			mali_timeline_tracker_release(
+				mali_pp_job_get_tracker(job));
 
 			/* Notify user space and close the job object */
 			mali_scheduler_complete_pp_job(job, 0, MALI_TRUE,
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_scheduler.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_scheduler.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_scheduler.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_scheduler.h	2016-04-04 16:25:32.148527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_scheduler_types.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_scheduler_types.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_scheduler_types.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_scheduler_types.h	2016-04-04 16:25:32.158527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_session.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_session.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_session.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_session.c	2016-04-04 16:25:32.168527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_session.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_session.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_session.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_session.h	2016-04-04 16:25:32.178527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -12,10 +12,10 @@
 #define __MALI_SESSION_H__
 
 #include "mali_mmu_page_directory.h"
+#include "mali_kernel_descriptor_mapping.h"
 #include "mali_osk.h"
 #include "mali_osk_list.h"
 #include "mali_memory_types.h"
-#include "mali_memory_manager.h"
 
 struct mali_timeline_system;
 struct mali_soft_system;
@@ -28,9 +28,9 @@
 	_mali_osk_notification_queue_t *ioctl_queue;
 
 	_mali_osk_mutex_t *memory_lock; /**< Lock protecting the vm manipulation */
-#if 0
+	mali_descriptor_mapping *descriptor_mapping;  /**< Mapping between userspace descriptors and our pointers */
 	_mali_osk_list_t memory_head; /**< Track all the memory allocated in this session, for freeing on abnormal termination */
-#endif
+
 	struct mali_page_directory *page_directory; /**< MMU page directory for this session */
 
 	_MALI_OSK_LIST_HEAD(link); /**< Link for list of all sessions */
@@ -51,8 +51,6 @@
 	char *comm;
 	size_t mali_mem_array[MALI_MEM_TYPE_MAX]; /**< The array to record all mali mem types' usage for this session. */
 	size_t max_mali_mem_allocated; /**< The past max mali memory usage for this session. */
-	/* Added for new memroy system */
-	struct mali_allocation_manager allocation_mgr;
 };
 
 _mali_osk_errcode_t mali_session_initialize(void);
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_soft_job.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_soft_job.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_soft_job.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_soft_job.c	2016-04-04 16:25:32.178527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -289,10 +289,8 @@
 	job->activated_notification = NULL;
 }
 
-mali_scheduler_mask mali_soft_job_system_activate_job(struct mali_soft_job *job)
+void mali_soft_job_system_activate_job(struct mali_soft_job *job)
 {
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-
 	MALI_DEBUG_ASSERT_POINTER(job);
 	MALI_DEBUG_ASSERT_POINTER(job->system);
 	MALI_DEBUG_ASSERT_POINTER(job->system->session);
@@ -309,7 +307,7 @@
 		/* Since we are in shutdown, we can ignore the scheduling bitmask. */
 		mali_timeline_tracker_release(&job->tracker);
 		mali_soft_job_destroy(job);
-		return schedule_mask;
+		return;
 	}
 
 	/* Send activated notification. */
@@ -320,12 +318,15 @@
 
 	/* If job type is self signaled, release tracker, move soft job to free list, and scheduler at once */
 	if (MALI_SOFT_JOB_TYPE_SELF_SIGNALED == job->type) {
+		mali_scheduler_mask schedule_mask;
+
 		MALI_DEBUG_ASSERT(MALI_SOFT_JOB_STATE_STARTED == job->state);
 
 		job->state = MALI_SOFT_JOB_STATE_SIGNALED;
 		mali_soft_job_system_unlock(job->system);
 
-		schedule_mask |= mali_timeline_tracker_release(&job->tracker);
+		schedule_mask = mali_timeline_tracker_release(&job->tracker);
+		mali_executor_schedule_from_mask(schedule_mask, MALI_FALSE);
 
 		mali_soft_job_destroy(job);
 	} else {
@@ -333,8 +334,6 @@
 
 		mali_soft_job_system_unlock(job->system);
 	}
-
-	return schedule_mask;
 }
 
 mali_scheduler_mask mali_soft_job_system_timeout_job(struct mali_soft_job *job)
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_soft_job.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_soft_job.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_soft_job.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_soft_job.h	2016-04-04 16:25:32.188527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -165,9 +165,8 @@
  * Used by the Timeline system to activate a soft job.
  *
  * @param job The soft job that is being activated.
- * @return A scheduling bitmask.
  */
-mali_scheduler_mask mali_soft_job_system_activate_job(struct mali_soft_job *job);
+void mali_soft_job_system_activate_job(struct mali_soft_job *job);
 
 /**
  * Used by the Timeline system to timeout a soft job.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_spinlock_reentrant.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_spinlock_reentrant.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_spinlock_reentrant.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_spinlock_reentrant.c	2016-04-04 16:25:32.198527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_spinlock_reentrant.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_spinlock_reentrant.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_spinlock_reentrant.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_spinlock_reentrant.h	2016-04-04 16:25:32.208527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline.c	2016-04-04 16:25:32.218527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -115,11 +115,6 @@
 
 	mali_spinlock_reentrant_signal(system->spinlock, tid);
 
-	/*
-	 * Older versions of Linux, before 3.5, doesn't support fput() in interrupt
-	 * context. For those older kernels, allocate a list object and put the
-	 * fence object on that and defer the call to sync_fence_put() to a workqueue.
-	 */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
 	{
 		struct mali_deferred_fence_put_entry *obj;
@@ -659,7 +654,7 @@
 		timeline = tracker->timeline;
 		MALI_DEBUG_ASSERT_POINTER(timeline);
 
-		schedule_mask |= mali_soft_job_system_activate_job((struct mali_soft_job *) tracker->job);
+		mali_soft_job_system_activate_job((struct mali_soft_job *) tracker->job);
 
 		/* Start a soft timer to make sure the soft job be released in a limited time */
 		mali_spinlock_reentrant_wait(system->spinlock, tid);
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline_fence_wait.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline_fence_wait.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline_fence_wait.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline_fence_wait.c	2016-04-04 16:25:32.258527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -102,7 +102,7 @@
 		sync_fence = sync_fence_fdget(fence->sync_fd);
 		if (likely(NULL != sync_fence)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
-			if (0 == sync_fence->status) {
+			if( 0 == sync_fence->status) {
 #else
 			if (0 == atomic_read(&sync_fence->status)) {
 #endif
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline_fence_wait.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline_fence_wait.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline_fence_wait.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline_fence_wait.h	2016-04-04 16:25:32.268527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline.h	2016-04-04 16:25:32.238527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline_sync_fence.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline_sync_fence.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline_sync_fence.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline_sync_fence.c	2016-04-04 16:25:32.278527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline_sync_fence.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline_sync_fence.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_timeline_sync_fence.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_timeline_sync_fence.h	2016-04-04 16:25:32.288527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_ukk.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_ukk.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_ukk.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_ukk.h	2016-04-04 16:25:32.298527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -350,6 +350,31 @@
  */
 _mali_osk_errcode_t _mali_ukk_mem_write_safe(_mali_uk_mem_write_safe_s *args);
 
+/** @brief Map a physically contiguous range of memory into Mali
+ * @param args see _mali_uk_map_external_mem_s in mali_utgard_uk_types.h
+ * @return _MALI_OSK_ERR_OK on success, otherwise a suitable _mali_osk_errcode_t on failure.
+ */
+_mali_osk_errcode_t _mali_ukk_map_external_mem(_mali_uk_map_external_mem_s *args);
+
+/** @brief Unmap a physically contiguous range of memory from Mali
+ * @param args see _mali_uk_unmap_external_mem_s in mali_utgard_uk_types.h
+ * @return _MALI_OSK_ERR_OK on success, otherwise a suitable _mali_osk_errcode_t on failure.
+ */
+_mali_osk_errcode_t _mali_ukk_unmap_external_mem(_mali_uk_unmap_external_mem_s *args);
+
+#if defined(CONFIG_MALI400_UMP)
+/** @brief Map UMP memory into Mali
+ * @param args see _mali_uk_attach_ump_mem_s in mali_utgard_uk_types.h
+ * @return _MALI_OSK_ERR_OK on success, otherwise a suitable _mali_osk_errcode_t on failure.
+ */
+_mali_osk_errcode_t _mali_ukk_attach_ump_mem(_mali_uk_attach_ump_mem_s *args);
+/** @brief Unmap UMP memory from Mali
+ * @param args see _mali_uk_release_ump_mem_s in mali_utgard_uk_types.h
+ * @return _MALI_OSK_ERR_OK on success, otherwise a suitable _mali_osk_errcode_t on failure.
+ */
+_mali_osk_errcode_t _mali_ukk_release_ump_mem(_mali_uk_release_ump_mem_s *args);
+#endif /* CONFIG_MALI400_UMP */
+
 /** @} */ /* end group _mali_uk_memory */
 
 
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_user_settings_db.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_user_settings_db.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_user_settings_db.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_user_settings_db.c	2016-04-04 16:25:32.308527000 +0300
@@ -1,5 +1,5 @@
 /**
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_user_settings_db.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_user_settings_db.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/common/mali_user_settings_db.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/common/mali_user_settings_db.h	2016-04-04 16:25:32.318527000 +0300
@@ -1,5 +1,5 @@
 /**
- * Copyright (C) 2012-2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_counters.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_counters.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_counters.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_counters.h	2016-04-04 16:25:32.348527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard.h	2016-04-04 16:25:32.338527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -112,7 +112,7 @@
 	MALI_GPU_RESOURCES_MALI400_MP4(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp2_irq, pp2_mmu_irq, pp3_irq, pp3_mmu_irq) \
 	MALI_GPU_RESOURCE_PMU(base_addr + MALI_OFFSET_PMU) \
 
-	/* Mali-450 */
+/* Mali-450 */
 #define MALI_GPU_RESOURCES_MALI450_MP2(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp_bcast_irq) \
 	MALI_GPU_RESOURCE_L2(base_addr + MALI450_OFFSET_L2_CACHE0) \
 	MALI_GPU_RESOURCE_GP_WITH_MMU(base_addr + MALI_OFFSET_GP, gp_irq, base_addr + MALI_OFFSET_GP_MMU, gp_mmu_irq) \
@@ -363,85 +363,85 @@
 					  .end = pp_mmu_bcast_addr + 0x100, \
 	},
 
-	struct mali_gpu_utilization_data {
-		unsigned int utilization_gpu; /* Utilization for GP and all PP cores combined, 0 = no utilization, 256 = full utilization */
-		unsigned int utilization_gp;  /* Utilization for GP core only, 0 = no utilization, 256 = full utilization */
-		unsigned int utilization_pp;  /* Utilization for all PP cores combined, 0 = no utilization, 256 = full utilization */
-	};
-
-	struct mali_gpu_clk_item {
-		unsigned int clock; /* unit(MHz) */
-		unsigned int vol;
-	};
-
-	struct mali_gpu_clock {
-		struct mali_gpu_clk_item *item;
-		unsigned int num_of_steps;
-	};
-
-	struct mali_gpu_device_data {
-		/* Shared GPU memory */
-		unsigned long shared_mem_size;
-
-		/*
-		 * Mali PMU switch delay.
-		 * Only needed if the power gates are connected to the PMU in a high fanout
-		 * network. This value is the number of Mali clock cycles it takes to
-		 * enable the power gates and turn on the power mesh.
-		 * This value will have no effect if a daisy chain implementation is used.
-		 */
-		u32 pmu_switch_delay;
-
-		/* Mali Dynamic power domain configuration in sequence from 0-11
-		 *  GP  PP0 PP1  PP2  PP3  PP4  PP5  PP6  PP7, L2$0 L2$1 L2$2
-		 */
-		u16 pmu_domain_config[12];
-
-		/* Dedicated GPU memory range (physical). */
-		unsigned long dedicated_mem_start;
-		unsigned long dedicated_mem_size;
-
-		/* Frame buffer memory to be accessible by Mali GPU (physical) */
-		unsigned long fb_start;
-		unsigned long fb_size;
-
-		/* Max runtime [ms] for jobs */
-		int max_job_runtime;
-
-		/* Report GPU utilization and related control in this interval (specified in ms) */
-		unsigned long control_interval;
-
-		/* Function that will receive periodic GPU utilization numbers */
-		void (*utilization_callback)(struct mali_gpu_utilization_data *data);
-
-		/* Fuction that platform callback for freq setting, needed when CONFIG_MALI_DVFS enabled */
-		int (*set_freq)(int setting_clock_step);
-		/* Function that platfrom report it's clock info which driver can set, needed when CONFIG_MALI_DVFS enabled */
-		void (*get_clock_info)(struct mali_gpu_clock **data);
-		/* Function that get the current clock info, needed when CONFIG_MALI_DVFS enabled */
-		int (*get_freq)(void);
-	};
-
-	/**
-	 * Pause the scheduling and power state changes of Mali device driver.
-	 * mali_dev_resume() must always be called as soon as possible after this function
-	 * in order to resume normal operation of the Mali driver.
+struct mali_gpu_utilization_data {
+	unsigned int utilization_gpu; /* Utilization for GP and all PP cores combined, 0 = no utilization, 256 = full utilization */
+	unsigned int utilization_gp;  /* Utilization for GP core only, 0 = no utilization, 256 = full utilization */
+	unsigned int utilization_pp;  /* Utilization for all PP cores combined, 0 = no utilization, 256 = full utilization */
+};
+
+struct mali_gpu_clk_item {
+	unsigned int clock; /* unit(MHz) */
+	unsigned int vol;
+};
+
+struct mali_gpu_clock {
+	struct mali_gpu_clk_item *item;
+	unsigned int num_of_steps;
+};
+
+struct mali_gpu_device_data {
+	/* Shared GPU memory */
+	unsigned long shared_mem_size;
+
+	/*
+	 * Mali PMU switch delay.
+	 * Only needed if the power gates are connected to the PMU in a high fanout
+	 * network. This value is the number of Mali clock cycles it takes to
+	 * enable the power gates and turn on the power mesh.
+	 * This value will have no effect if a daisy chain implementation is used.
 	 */
-	void mali_dev_pause(void);
+	u32 pmu_switch_delay;
 
-	/**
-	 * Resume scheduling and allow power changes in Mali device driver.
-	 * This must always be called after mali_dev_pause().
+	/* Mali Dynamic power domain configuration in sequence from 0-11
+	 *  GP  PP0 PP1  PP2  PP3  PP4  PP5  PP6  PP7, L2$0 L2$1 L2$2
 	 */
-	void mali_dev_resume(void);
+	u16 pmu_domain_config[12];
 
-	/** @brief Set the desired number of PP cores to use.
-	 *
-	 * The internal Mali PMU will be used, if present, to physically power off the PP cores.
-	 *
-	 * @param num_cores The number of desired cores
-	 * @return 0 on success, otherwise error. -EINVAL means an invalid number of cores was specified.
-	 */
-	int mali_perf_set_num_pp_cores(unsigned int num_cores);
+	/* Dedicated GPU memory range (physical). */
+	unsigned long dedicated_mem_start;
+	unsigned long dedicated_mem_size;
+
+	/* Frame buffer memory to be accessible by Mali GPU (physical) */
+	unsigned long fb_start;
+	unsigned long fb_size;
+
+	/* Max runtime [ms] for jobs */
+	int max_job_runtime;
+
+	/* Report GPU utilization and related control in this interval (specified in ms) */
+	unsigned long control_interval;
+
+	/* Function that will receive periodic GPU utilization numbers */
+	void (*utilization_callback)(struct mali_gpu_utilization_data *data);
+
+	/* Fuction that platform callback for freq setting, needed when CONFIG_MALI_DVFS enabled */
+	int (*set_freq)(int setting_clock_step);
+	/* Function that platfrom report it's clock info which driver can set, needed when CONFIG_MALI_DVFS enabled */
+	void (*get_clock_info)(struct mali_gpu_clock **data);
+	/* Function that get the current clock info, needed when CONFIG_MALI_DVFS enabled */
+	int (*get_freq)(void);
+};
+
+/**
+ * Pause the scheduling and power state changes of Mali device driver.
+ * mali_dev_resume() must always be called as soon as possible after this function
+ * in order to resume normal operation of the Mali driver.
+ */
+void mali_dev_pause(void);
+
+/**
+ * Resume scheduling and allow power changes in Mali device driver.
+ * This must always be called after mali_dev_pause().
+ */
+void mali_dev_resume(void);
+
+/** @brief Set the desired number of PP cores to use.
+ *
+ * The internal Mali PMU will be used, if present, to physically power off the PP cores.
+ *
+ * @param num_cores The number of desired cores
+ * @return 0 on success, otherwise error. -EINVAL means an invalid number of cores was specified.
+ */
+int mali_perf_set_num_pp_cores(unsigned int num_cores);
 
 #endif
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_ioctl.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_ioctl.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_ioctl.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_ioctl.h	2016-04-04 16:25:32.368527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -51,11 +51,13 @@
 #define MALI_IOC_SOFT_JOB_START             _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_SOFT_JOB_START, _mali_uk_soft_job_start_s)
 #define MALI_IOC_SOFT_JOB_SIGNAL            _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_SOFT_JOB_SIGNAL, _mali_uk_soft_job_signal_s)
 
-#define MALI_IOC_MEM_ALLOC                  _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_ALLOC_MEM, _mali_uk_alloc_mem_s)
-#define MALI_IOC_MEM_FREE                   _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_FREE_MEM, _mali_uk_free_mem_s)
-#define MALI_IOC_MEM_BIND                   _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_BIND_MEM, _mali_uk_bind_mem_s)
-#define MALI_IOC_MEM_UNBIND                 _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_UNBIND_MEM, _mali_uk_unbind_mem_s)
+#define MALI_IOC_MEM_MAP_EXT                _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_MAP_EXT_MEM, _mali_uk_map_external_mem_s)
+#define MALI_IOC_MEM_UNMAP_EXT              _IOW (MALI_IOC_MEMORY_BASE, _MALI_UK_UNMAP_EXT_MEM, _mali_uk_unmap_external_mem_s)
+#define MALI_IOC_MEM_ATTACH_DMA_BUF         _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_ATTACH_DMA_BUF, _mali_uk_attach_dma_buf_s)
+#define MALI_IOC_MEM_RELEASE_DMA_BUF        _IOW(MALI_IOC_MEMORY_BASE, _MALI_UK_RELEASE_DMA_BUF, _mali_uk_release_dma_buf_s)
 #define MALI_IOC_MEM_DMA_BUF_GET_SIZE       _IOR(MALI_IOC_MEMORY_BASE, _MALI_UK_DMA_BUF_GET_SIZE, _mali_uk_dma_buf_get_size_s)
+#define MALI_IOC_MEM_ATTACH_UMP             _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_ATTACH_UMP_MEM, _mali_uk_attach_ump_mem_s)
+#define MALI_IOC_MEM_RELEASE_UMP            _IOW(MALI_IOC_MEMORY_BASE, _MALI_UK_RELEASE_UMP_MEM, _mali_uk_release_ump_mem_s)
 #define MALI_IOC_MEM_QUERY_MMU_PAGE_TABLE_DUMP_SIZE _IOR (MALI_IOC_MEMORY_BASE, _MALI_UK_QUERY_MMU_PAGE_TABLE_DUMP_SIZE, _mali_uk_query_mmu_page_table_dump_size_s)
 #define MALI_IOC_MEM_DUMP_MMU_PAGE_TABLE    _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_DUMP_MMU_PAGE_TABLE, _mali_uk_dump_mmu_page_table_s)
 #define MALI_IOC_MEM_WRITE_SAFE             _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_MEM_WRITE_SAFE, _mali_uk_mem_write_safe_s)
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_profiling_events.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_profiling_events.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_profiling_events.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_profiling_events.h	2016-04-04 16:25:32.368527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_profiling_gator_api.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_profiling_gator_api.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_profiling_gator_api.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_profiling_gator_api.h	2016-04-04 16:25:32.378527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_uk_types.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_uk_types.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_uk_types.h	2016-04-04 16:20:12.068527000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/include/linux/mali/mali_utgard_uk_types.h	2016-04-04 16:25:32.388527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -84,13 +84,19 @@
 
 	/** Memory functions */
 
-	_MALI_UK_ALLOC_MEM                = 0,   /**< _mali_ukk_init_mem() */
-	_MALI_UK_FREE_MEM,                       /**< _mali_ukk_term_mem() */
-	_MALI_UK_BIND_MEM,                       /**< _mali_ukk_mem_mmap() */
-	_MALI_UK_UNBIND_MEM,                     /**< _mali_ukk_mem_munmap() */
+	_MALI_UK_INIT_MEM                = 0,    /**< _mali_ukk_init_mem() */
+	_MALI_UK_TERM_MEM,                       /**< _mali_ukk_term_mem() */
+	_MALI_UK_MAP_MEM,                        /**< _mali_ukk_mem_mmap() */
+	_MALI_UK_UNMAP_MEM,                      /**< _mali_ukk_mem_munmap() */
 	_MALI_UK_QUERY_MMU_PAGE_TABLE_DUMP_SIZE, /**< _mali_ukk_mem_get_mmu_page_table_dump_size() */
 	_MALI_UK_DUMP_MMU_PAGE_TABLE,            /**< _mali_ukk_mem_dump_mmu_page_table() */
+	_MALI_UK_ATTACH_DMA_BUF,                 /**< _mali_ukk_attach_dma_buf() */
+	_MALI_UK_RELEASE_DMA_BUF,                /**< _mali_ukk_release_dma_buf() */
 	_MALI_UK_DMA_BUF_GET_SIZE,               /**< _mali_ukk_dma_buf_get_size() */
+	_MALI_UK_ATTACH_UMP_MEM,                 /**< _mali_ukk_attach_ump_mem() */
+	_MALI_UK_RELEASE_UMP_MEM,                /**< _mali_ukk_release_ump_mem() */
+	_MALI_UK_MAP_EXT_MEM,                    /**< _mali_uku_map_external_mem() */
+	_MALI_UK_UNMAP_EXT_MEM,                  /**< _mali_uku_unmap_external_mem() */
 	_MALI_UK_MEM_WRITE_SAFE,                 /**< _mali_uku_mem_write_safe() */
 
 	/** Common functions for each core */
@@ -618,7 +624,7 @@
  * The 16bit integer is stored twice in a 32bit integer
  * For example, for version 1 the value would be 0x00010001
  */
-#define _MALI_API_VERSION 800
+#define _MALI_API_VERSION 600
 #define _MALI_UK_API_VERSION _MAKE_VERSION_ID(_MALI_API_VERSION)
 
 /**
@@ -704,90 +710,34 @@
 /** @defgroup _mali_uk_memory U/K Memory
  * @{ */
 
-#define _MALI_MEMORY_ALLOCATE_RESIZEABLE  (1<<4) /* BUFFER can trim dow/grow*/
-#define _MALI_MEMORY_ALLOCATE_NO_BIND_GPU (1<<5) /*Not map to GPU when allocate, must call bind later*/
+/** Flag for _mali_uk_map_external_mem_s, _mali_uk_attach_ump_mem_s and _mali_uk_attach_dma_buf_s */
+#define _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE (1<<0)
 
 typedef struct {
-	u64 ctx;                                          /**< [in,out] user-kernel context (trashed on output) */
-	u32 gpu_vaddr;                            /**< [in] GPU virtual address */
-	u32 vsize;                                        /**< [in] vitrual size of the allocation */
-	u32 psize;                                        /**< [in] physical size of the allocation */
-	u32 flags;
-	u64 backend_handle;          /**< [out] backend handle */
-	struct {
-		/* buffer types*/
-		/* CPU read/write info*/
-	} buffer_info;
-} _mali_uk_alloc_mem_s;
-
+	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
+	u32 phys_addr;                  /**< [in] physical address */
+	u32 size;                       /**< [in] size */
+	u32 mali_address;               /**< [in] mali address to map the physical memory to */
+	u32 rights;                     /**< [in] rights necessary for accessing memory */
+	u32 flags;                      /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
+	u32 cookie;                     /**< [out] identifier for mapped memory object in kernel space  */
+} _mali_uk_map_external_mem_s;
 
 typedef struct {
-	u64 ctx;                                          /**< [in,out] user-kernel context (trashed on output) */
-	u32 gpu_vaddr;                /**< [in] use as handle to free allocation */
-} _mali_uk_free_mem_s;
-
-
-#define _MALI_MEMORY_BIND_BACKEND_UMP             (1<<8)
-#define _MALI_MEMORY_BIND_BACKEND_DMA_BUF         (1<<9)
-#define _MALI_MEMORY_BIND_BACKEND_MALI_MEMORY     (1<<10)
-#define _MALI_MEMORY_BIND_BACKEND_EXTERNAL_MEMORY (1<<11)
-#define _MALI_MEMORY_BIND_BACKEND_EXT_COW         (1<<12)
-#define _MALI_MEMORY_BIND_BACKEND_HAVE_ALLOCATION (1<<13)
-
-
-#define _MALI_MEMORY_BIND_BACKEND_MASK (_MALI_MEMORY_BIND_BACKEND_UMP| \
-					_MALI_MEMORY_BIND_BACKEND_DMA_BUF |\
-					_MALI_MEMORY_BIND_BACKEND_MALI_MEMORY |\
-					_MALI_MEMORY_BIND_BACKEND_EXTERNAL_MEMORY |\
-					_MALI_MEMORY_BIND_BACKEND_EXT_COW |\
-					_MALI_MEMORY_BIND_BACKEND_HAVE_ALLOCATION)
-
-
-#define _MALI_MEMORY_GPU_READ_ALLOCATE            (1<<16)
-
+	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
+	u32 cookie;                     /**< [out] identifier for mapped memory object in kernel space  */
+} _mali_uk_unmap_external_mem_s;
 
+/** @note This is identical to _mali_uk_map_external_mem_s above, however phys_addr is replaced by memory descriptor */
 typedef struct {
-	u64 ctx;                                          /**< [in,out] user-kernel context (trashed on output) */
-	u32 vaddr;                    /**< [in] mali address to map the physical memory to */
-	u32 size;                                         /**< [in] size */
-	u32 flags;                    /**< [in] see_MALI_MEMORY_BIND_BACKEND_* */
-	u32 padding;                              /** padding for 32/64 struct alignment */
-	union {
-		struct {
-			u32 secure_id;                                  /**< [in] secure id */
-			u32 rights;                                     /**< [in] rights necessary for accessing memory */
-			u32 flags;                                              /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
-		} bind_ump;
-		struct {
-			u32 mem_fd;                     /**< [in] Memory descriptor */
-			u32 rights;                     /**< [in] rights necessary for accessing memory */
-			u32 flags;                      /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
-		} bind_dma_buf;
-		struct {
-			/**/
-		} bind_mali_memory;
-		struct {
-			u32 phys_addr;                  /**< [in] physical address */
-			u32 rights;                     /**< [in] rights necessary for accessing memory */
-			u32 flags;                      /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
-		} bind_ext_memory;
-	} mem_union;
-} _mali_uk_bind_mem_s;
-
-typedef struct {
-	u64 ctx;                                          /**< [in,out] user-kernel context (trashed on output) */
-	u32 flags;                    /**< [in] see_MALI_MEMORY_BIND_BACKEND_* */
-	u32 vaddr;                   /**<  [in] identifier for mapped memory object in kernel space  */
-} _mali_uk_unbind_mem_s;
-
-typedef struct {
-	u64 ctx;                                                                /**< [in,out] user-kernel context (trashed on output) */
-	u32 target_handle;                                              /**< [in] handle of allocation need to do COW */
-	u32 range_start;                                                /**< [in] re allocate range start offset, offset from the start of allocation */
-	u32 size;                                                               /**< [in] re allocate size*/
-	u32 vaddr;                                                              /**< [in] mali address for the new allocaiton */
-	u32 backend_handle;                                             /**< [out] backend handle */
-} _mali_uk_cow_mem_s;
+	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
+	u32 mem_fd;                     /**< [in] Memory descriptor */
+	u32 size;                       /**< [in] size */
+	u32 mali_address;               /**< [in] mali address to map the physical memory to */
+	u32 rights;                     /**< [in] rights necessary for accessing memory */
+	u32 flags;                      /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
+	u32 cookie;                     /**< [out] identifier for mapped memory object in kernel space  */
+} _mali_uk_attach_dma_buf_s;
 
 typedef struct {
 	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
@@ -795,24 +745,26 @@
 	u32 size;                       /**< [out] size */
 } _mali_uk_dma_buf_get_size_s;
 
-/** Flag for _mali_uk_map_external_mem_s, _mali_uk_attach_ump_mem_s and _mali_uk_attach_dma_buf_s */
-#define _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE (1<<0)
-#if 0
 typedef struct {
 	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
-	u32 phys_addr;                  /**< [in] physical address */
+	u64 cookie;                     /**< [in] identifier for mapped memory object in kernel space  */
+} _mali_uk_release_dma_buf_s;
+
+/** @note This is identical to _mali_uk_map_external_mem_s above, however phys_addr is replaced by secure_id */
+typedef struct {
+	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
+	u32 secure_id;                  /**< [in] secure id */
 	u32 size;                       /**< [in] size */
 	u32 mali_address;               /**< [in] mali address to map the physical memory to */
 	u32 rights;                     /**< [in] rights necessary for accessing memory */
 	u32 flags;                      /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
 	u32 cookie;                     /**< [out] identifier for mapped memory object in kernel space  */
-} _mali_uk_map_external_mem_s;
+} _mali_uk_attach_ump_mem_s;
 
 typedef struct {
 	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
-	u32 cookie;                     /**< [out] identifier for mapped memory object in kernel space  */
-} _mali_uk_unmap_external_mem_s;
-#endif
+	u32 cookie;                     /**< [in] identifier for mapped memory object in kernel space  */
+} _mali_uk_release_ump_mem_s;
 
 /**
  * @brief Arguments for _mali_uk[uk]_mem_write_safe()
@@ -945,6 +897,7 @@
 	void *mapping;                  /**< [out] Returns user-space virtual address for the mapping */
 	u32 size;                       /**< [in] Size of the requested mapping */
 	u32 phys_addr;                  /**< [in] Physical address - could be offset, depending on caller+callee convention */
+	u32 cookie;                     /**< [out] Returns a cookie for use in munmap calls */
 } _mali_uk_mem_mmap_s;
 
 /** @brief Arguments to _mali_ukk_mem_munmap()
@@ -961,6 +914,7 @@
 	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
 	void *mapping;                  /**< [in] The mapping returned from mmap call */
 	u32 size;                       /**< [in] The size passed to mmap call */
+	u32 cookie;                     /**< [in] Cookie from mmap call */
 } _mali_uk_mem_munmap_s;
 /** @} */ /* end group _mali_uk_memory */
 
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/Kbuild linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/Kbuild
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/Kbuild	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/Kbuild	2016-04-04 16:25:31.068527000 +0300
@@ -9,79 +9,25 @@
 #
 
 # This file is called by the Linux build system.
-############## Kasin Added, for platform. ################
-TARGET_PLATFORM:=meson_m450
-ifeq ($(CONFIG_ARCH_MESON1),y)
-TARGET_PLATFORM:= meson_m400
-endif
-ifeq ($(CONFIG_ARCH_MESON3),y)
-TARGET_PLATFORM:= meson_m400
-endif
-ifeq ($(CONFIG_ARCH_MESON6),y)
-TARGET_PLATFORM:= meson_m400
-endif
-ifeq ($(CONFIG_ARCH_MESON6TV),y)
-TARGET_PLATFORM:= meson_m400
-endif
-##################### end Kasin Added. ###################
 
 # set up defaults if not defined by the user
+TARGET_PLATFORM := meson_m450
 TIMESTAMP ?= default
-ifeq ($(CONFIG_UMP), m)
-  USING_UMP ?= 1
-else
-  USING_UMP ?= 0
-endif
-
-ifneq ($(KBUILD_SRC),)
-	ifneq ($(wildcard $(KBUILD_SRC)/$(src)),)
-		TOP_KBUILD_SRC := $(KBUILD_SRC)/
-	endif
-endif
-
 OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB ?= 16
-
-#USING_GPU_UTILIZATION ?= 0
-#PROFILING_SKIP_PP_JOBS ?= 0
-#PROFILING_SKIP_PP_AND_GP_JOBS ?= 0
-
-USING_GPU_UTILIZATION=1
-USING_DVFS=0
+USING_GPU_UTILIZATION ?= 1
 PROFILING_SKIP_PP_JOBS ?= 0
 PROFILING_SKIP_PP_AND_GP_JOBS ?= 0
-############## Kasin Added, for platform. ################
-ifeq ($(CONFIG_MALI400_DEBUG),y)
-	BUILD ?= debug
-else
-	BUILD ?= release
-	ldflags-y += --strip-debug
-endif
-##################### end Kasin Added. ###################
-
-############## Kasin Added, useless now. ################
-ifeq ($(USING_UMP),1)
-	UMP_SYMVERS_FILE = ../ump/Module.symvers
-	KBUILD_EXTRA_SYMBOLS = $(srctree)/$(src)/$(UMP_SYMVERS_FILE)
-endif
-##################### end Kasin Added. ###################
-
 MALI_PP_SCHEDULER_FORCE_NO_JOB_OVERLAP ?= 0
 MALI_PP_SCHEDULER_KEEP_SUB_JOB_STARTS_ALIGNED ?= 0
 MALI_PP_SCHEDULER_FORCE_NO_JOB_OVERLAP_BETWEEN_APPS ?= 0
 MALI_UPPER_HALF_SCHEDULING ?= 1
-
-############## Kasin Added, useless now. ################
-# Get path to driver source from Linux build system
-DRIVER_DIR=$(src)
-##################### end Kasin Added. ###################
-
 MALI_ENABLE_CPU_CYCLES ?= 0
 
 # For customer releases the Linux Device Drivers will be provided as ARM proprietary and GPL releases:
 # The ARM proprietary product will only include the license/proprietary directory
 # The GPL product will only include the license/gpl directory
-ifeq ($(wildcard $(TOP_KBUILD_SRC)$(DRIVER_DIR)/linux/license/gpl/*),)
-    ccflags-y += -I$(TOP_KBUILD_SRC)$(DRIVER_DIR)/linux/license/proprietary
+ifeq ($(wildcard $(src)/linux/license/gpl/*),)
+    ccflags-y += -I$(src)/linux/license/proprietary
     ifeq ($(CONFIG_MALI400_PROFILING),y)
         $(error Profiling is incompatible with non-GPL license)
     endif
@@ -93,7 +39,7 @@
     endif
     $(error Linux Device integration is incompatible with non-GPL license)
 else
-    ccflags-y += -I$(TOP_KBUILD_SRC)$(DRIVER_DIR)/linux/license/gpl
+    ccflags-y += -I$(src)/linux/license/gpl
 endif
 
 ifeq ($(USING_GPU_UTILIZATION), 1)
@@ -122,10 +68,6 @@
 mali-y += linux/mali_memory_block_alloc.o
 
 mali-y += \
-	linux/mali_memory_manager.o \
-	linux/mali_memory_virtual.o \
-	linux/mali_memory_util.o
-mali-y += \
 	linux/mali_ukk_mem.o \
 	linux/mali_ukk_gp.o \
 	linux/mali_ukk_pp.o \
@@ -137,6 +79,7 @@
 mali-y += \
 	common/mali_kernel_core.o \
 	linux/mali_kernel_linux.o \
+	common/mali_kernel_descriptor_mapping.o \
 	common/mali_session.o \
 	linux/mali_device_pause_resume.o \
 	common/mali_kernel_vsync.o \
@@ -171,41 +114,16 @@
 	linux/mali_pmu_power_up_down.o \
 	__malidrv_build_info.o
 
-############## Kasin Added, for platform. ################
 mali-y += \
 	platform/meson_main.o \
 	platform/mali_pm_device.o \
 	platform/mali_clock.o \
 	platform/mpgpu.o \
-
-ifeq ($(TARGET_PLATFORM),meson_m400)
-MALI_PLATFORM_FILES:= \
-	platform/meson_m400/mali_fix.o \
-	platform/meson_m400/mali_platform.o \
-	platform/meson_m400/platform_mx.o
-endif
-
-ifeq ($(TARGET_PLATFORM),meson_m450)
-ccflags-y += -DCONFIG_MALI450=y
-mali-y += \
-	platform/meson_m450/scaling.o
-
-mali-$(CONFIG_ARCH_MESON8) += \
-	platform/meson_m450/platform_m8.o
-
-mali-$(CONFIG_ARCH_MESON6TVD) += \
-	platform/meson_m450/platform_m6tvd.o
-
-mali-$(CONFIG_ARCH_MESON8B) += \
+	platform/meson_m450/scaling.o \
 	platform/meson_m450/platform_m8b.o
 
-mali-$(CONFIG_ARCH_MESONG9TV) += \
-	platform/meson_m450/platform_m8.o
-
-mali-$(CONFIG_ARCH_MESONG9BB) += \
-	platform/meson_m450/platform_m8b.o
-endif
-##################### end Kasin Added. ###################
+ccflags-$(CONFIG_SYNC) += -Idrivers/staging/android
+ccflags-y += -I$(src)/../../../../include/ump
 
 ifneq ($(MALI_PLATFORM_FILES),)
 	mali-y += $(MALI_PLATFORM_FILES:.c=.o)
@@ -238,22 +156,21 @@
 ccflags-y += -DMALI_OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB=$(OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB)
 ccflags-y += -DUSING_GPU_UTILIZATION=$(USING_GPU_UTILIZATION)
 ccflags-y += -DMALI_ENABLE_CPU_CYCLES=$(MALI_ENABLE_CPU_CYCLES)
-ccflags-y += -DMALI_FAKE_PLATFORM_DEVICE
 
 ifeq ($(MALI_UPPER_HALF_SCHEDULING),1)
 	ccflags-y += -DMALI_UPPER_HALF_SCHEDULING
 endif
 
-ccflags-$(CONFIG_MALI400_UMP) += -I$(src)/../ump/include/ump
+ccflags-$(CONFIG_MALI400_UMP) += -I$(src)/../../ump/include/ump
 ccflags-$(CONFIG_MALI400_DEBUG) += -DDEBUG
 
 # Use our defines when compiling
 ccflags-y += -I$(src) -I$(src)/include -I$(src)/common -I$(src)/linux -I$(src)/platform
 
 # Get subversion revision number, fall back to only ${MALI_RELEASE_NAME} if no svn info is available
-MALI_RELEASE_NAME=$(shell cat $(TOP_KBUILD_SRC)$(DRIVER_DIR)/.version 2> /dev/null)
+MALI_RELEASE_NAME=$(shell cat $(src)/.version 2> /dev/null)
 
-SVN_INFO = (cd $(TOP_KBUILD_SRC)$(DRIVER_DIR); svn info 2>/dev/null)
+SVN_INFO = (cd $(src); svn info 2>/dev/null)
 
 ifneq ($(shell $(SVN_INFO) 2>/dev/null),)
 # SVN detected
@@ -264,13 +181,13 @@
 REPO_URL := $(shell $(SVN_INFO) | grep '^URL: ' | cut -d: -f2- | cut -b2-)
 
 else # SVN
-GIT_REV := $(shell cd $(TOP_KBUILD_SRC)$(DRIVER_DIR); git describe --always 2>/dev/null)
+GIT_REV := $(shell cd $(src); git describe --always 2>/dev/null)
 ifneq ($(GIT_REV),)
 # Git detected
 DRIVER_REV := $(MALI_RELEASE_NAME)-$(GIT_REV)
-CHANGE_DATE := $(shell cd $(TOP_KBUILD_SRC)$(DRIVER_DIR); git log -1 --format="%ci")
+CHANGE_DATE := $(shell cd $(src); git log -1 --format="%ci")
 CHANGED_REVISION := $(GIT_REV)
-REPO_URL := $(shell cd $(TOP_KBUILD_SRC)$(DRIVER_DIR); git describe --all --always 2>/dev/null)
+REPO_URL := $(shell cd $(src); git describe --all --always 2>/dev/null)
 
 else # Git
 # No Git or SVN detected
@@ -283,7 +200,7 @@
 ccflags-y += -DSVN_REV_STRING=\"$(DRIVER_REV)\"
 
 VERSION_STRINGS :=
-VERSION_STRINGS += API_VERSION=$(shell cd $(TOP_KBUILD_SRC)$(DRIVER_DIR);  grep "\#define _MALI_API_VERSION" $(FILES_PREFIX)include/linux/mali/mali_utgard_uk_types.h | cut -d' ' -f 3 )
+VERSION_STRINGS += API_VERSION=$(shell cd $(src); grep "\#define _MALI_API_VERSION" $(FILES_PREFIX)include/linux/mali/mali_utgard_uk_types.h | cut -d' ' -f 3 )
 VERSION_STRINGS += REPO_URL=$(REPO_URL)
 VERSION_STRINGS += REVISION=$(DRIVER_REV)
 VERSION_STRINGS += CHANGED_REVISION=$(CHANGED_REVISION)
@@ -293,6 +210,7 @@
 VERSION_STRINGS += BUILD=debug
 else
 VERSION_STRINGS += BUILD=release
+ldflags-y += --strip-debug
 endif
 VERSION_STRINGS += TARGET_PLATFORM=$(TARGET_PLATFORM)
 VERSION_STRINGS += MALI_PLATFORM=$(MALI_PLATFORM)
@@ -306,5 +224,5 @@
 VERSION_STRINGS += MALI_UPPER_HALF_SCHEDULING=$(MALI_UPPER_HALF_SCHEDULING)
 
 # Create file with Mali driver configuration
-$(TOP_KBUILD_SRC)$(DRIVER_DIR)/__malidrv_build_info.c:
-	@echo 'const char *__malidrv_build_info(void) { return "malidrv: $(VERSION_STRINGS)";}' > $(TOP_KBUILD_SRC)$(DRIVER_DIR)/__malidrv_build_info.c
+$(src)/__malidrv_build_info.c:
+	@echo 'const char *__malidrv_build_info(void) { return "malidrv: $(VERSION_STRINGS)";}' > $(src)/__malidrv_build_info.c
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/Kconfig linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/Kconfig
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/Kconfig	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/Kconfig	2016-04-04 16:25:31.128527000 +0300
@@ -1,8 +1,6 @@
-menu "Mali GPU OpenGL device driver"
 config MALI400
 	tristate "Mali-300/400/450 support"
-	depends on ARM || ARM64
-	default m
+	depends on ARM
 	select DMA_SHARED_BUFFER
 	---help---
 	  This enables support for the ARM Mali-300, Mali-400, and Mali-450
@@ -11,31 +9,23 @@
 	  To compile this driver as a module, choose M here: the module will be
 	  called mali.
 
+config MALI450
+	bool "Enable Mali-450 support"
+	depends on MALI400
+	---help---
+	  This enables support for Mali-450 specific features.
+
 config MALI400_DEBUG
 	bool "Enable debug in Mali driver"
 	depends on MALI400
-	default n
 	---help---
 	  This enabled extra debug checks and messages in the Mali driver.
 
-config MALI400_PROFILING_EXTRA_SUPPORT
-	bool "Select other items in kernel to support PROFILING."
-	depends on MALI400_PROFILING
-	select PROFILING
-	select FTRACE
-	select PERF_EVENTS
-	select ENABLE_DEFAULT_TRACERS
-	select DEBUG_MUTEXES
-	select HIGH_RES_TIMERS
-	select HW_PERF_EVENTS
-	select CPU_FREQ
-	select MALI400_DEBUG
-
 config MALI400_PROFILING
 	bool "Enable Mali profiling"
 	depends on MALI400
 	select TRACEPOINTS
-	default n
+	default y
 	---help---
 	  This enables gator profiling of Mali GPU events.
 
@@ -55,7 +45,7 @@
 config MALI_DVFS
 	bool "Enable Mali dynamically frequency change"
 	depends on MALI400
-	default n
+	default y
 	---help---
 	  This enables support for dynamic change frequency of Mali with the goal of lowering power consumption.
 
@@ -80,14 +70,6 @@
 	  works when the GPU is not using shared interrupts, but might have a slight performance
 	  impact.
 
-if ARCH_MESON6
-config	MESON6_GPU_EXTRA
-	bool "M6 fix"
-	depends on MALI400
-	default y
-	select MALI_SHARED_INTERRUPTS
-endif
-
 config MALI_PMU_PARALLEL_POWER_UP
 	bool "Power up Mali PMU domains in parallel"
 	depends on MALI400
@@ -100,7 +82,7 @@
 
 config MALI_DT
 	bool "Using device tree to initialize module"
-	depends on MALI400 && OF
+	depends on MALI400 && CONFIG_OF
 	default n
 	---help---
 	  This enable the Mali driver to choose the device tree path to get platform resoures
@@ -116,4 +98,3 @@
 	  This forces the Mali driver to never print any messages.
 
 	  If unsure, say N.
-endmenu
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/license/gpl/mali_kernel_license.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/license/gpl/mali_kernel_license.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/license/gpl/mali_kernel_license.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/license/gpl/mali_kernel_license.h	2016-04-04 16:25:32.408527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_device_pause_resume.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_device_pause_resume.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_device_pause_resume.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_device_pause_resume.c	2016-04-04 16:25:32.418527000 +0300
@@ -1,5 +1,5 @@
 /**
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_kernel_linux.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_kernel_linux.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_kernel_linux.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_kernel_linux.c	2016-04-04 16:25:32.428527000 +0300
@@ -1,5 +1,5 @@
 /**
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -38,7 +38,6 @@
 #include "mali_kernel_license.h"
 #include "mali_memory.h"
 #include "mali_memory_dma_buf.h"
-#include "mali_memory_manager.h"
 #if defined(CONFIG_MALI400_INTERNAL_PROFILING)
 #include "mali_profiling_internal.h"
 #endif
@@ -63,10 +62,6 @@
 
 /* from the __malidrv_build_info.c file that is generated during build */
 extern const char *__malidrv_build_info(void);
-extern void mali_post_init(void);
-extern int mali_pdev_dts_init(struct platform_device* mali_gpu_device);
-extern int mpgpu_class_init(void);
-extern void mpgpu_class_exit(void);
 
 /* Module parameter to control log level */
 int mali_debug_level = 2;
@@ -227,7 +222,7 @@
 		.pm = &mali_dev_pm_ops,
 #endif
 #ifdef CONFIG_MALI_DT
-		.of_match_table = of_match_ptr(base_dt_ids),
+		.of_match_table = amlogic_mesonstream_dt_match,
 #endif
 	},
 };
@@ -364,6 +359,9 @@
 }
 #endif
 
+extern int mpgpu_class_init(void);
+extern int mali_platform_device_register(void);
+
 int mali_module_init(void)
 {
 	int err = 0;
@@ -380,25 +378,22 @@
 #endif
 
 	/* Initialize module wide settings */
-#ifdef MALI_FAKE_PLATFORM_DEVICE
-#ifndef CONFIG_MALI_DT
 	MALI_DEBUG_PRINT(2, ("mali_module_init() registering device\n"));
 	err = mali_platform_device_register();
 	if (0 != err) {
 		return err;
 	}
-#endif
-#endif
 
 	MALI_DEBUG_PRINT(2, ("mali_module_init() registering driver\n"));
 
 	err = platform_driver_register(&mali_platform_driver);
+	//mpgpu_class_init();
 
 	if (0 != err) {
 		MALI_DEBUG_PRINT(2, ("mali_module_init() Failed to register driver (%d)\n", err));
 #ifdef MALI_FAKE_PLATFORM_DEVICE
 #ifndef CONFIG_MALI_DT
-		mali_platform_device_unregister();
+	mali_platform_device_unregister();
 #endif
 #endif
 		mali_platform_device = NULL;
@@ -418,16 +413,15 @@
 	/* Just call mali_get_current_gpu_clk_item(),to record current clk info.*/
 	mali_get_current_gpu_clk_item(&mali_gpu_clk[0]);
 	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-				      MALI_PROFILING_EVENT_CHANNEL_GPU |
-				      MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-				      mali_gpu_clk[0].clock,
-				      mali_gpu_clk[0].vol / 1000,
-				      0, 0, 0);
+					  MALI_PROFILING_EVENT_CHANNEL_GPU |
+					  MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+					  mali_gpu_clk[0].clock,
+					  mali_gpu_clk[0].vol / 1000,
+					  0, 0, 0);
 #endif
 
-	MALI_PRINT(("Mali device driver loaded\n"));
-
 	mpgpu_class_init();
+	MALI_PRINT(("Mali device driver loaded\n"));
 
 	return 0; /* Success */
 }
@@ -458,7 +452,6 @@
 #if defined(CONFIG_MALI400_INTERNAL_PROFILING)
 	_mali_internal_profiling_term();
 #endif
-	mpgpu_class_exit();
 
 	MALI_PRINT(("Mali device driver unloaded\n"));
 }
@@ -496,7 +489,6 @@
 				err = mali_sysfs_register(mali_dev_name);
 
 				if (0 == err) {
-					mali_post_init();
 					MALI_DEBUG_PRINT(2, ("mali_probe(): Successfully initialized driver for platform device %s\n", pdev->name));
 
 					return 0;
@@ -782,29 +774,19 @@
 
 #endif
 
-	case MALI_IOC_MEM_ALLOC:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_alloc_mem_s), sizeof(u64)));
-		err = mem_alloc_wrapper(session_data, (_mali_uk_alloc_mem_s __user *)arg);
-		break;
-
-	case MALI_IOC_MEM_FREE:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_free_mem_s), sizeof(u64)));
-		err = mem_free_wrapper(session_data, (_mali_uk_free_mem_s __user *)arg);
-		break;
-
-	case MALI_IOC_MEM_BIND:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_bind_mem_s), sizeof(u64)));
-		err = mem_bind_wrapper(session_data, (_mali_uk_bind_mem_s __user *)arg);
+	case MALI_IOC_MEM_WRITE_SAFE:
+		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_mem_write_safe_s), sizeof(u64)));
+		err = mem_write_safe_wrapper(session_data, (_mali_uk_mem_write_safe_s __user *)arg);
 		break;
 
-	case MALI_IOC_MEM_UNBIND:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_unbind_mem_s), sizeof(u64)));
-		err = mem_unbind_wrapper(session_data, (_mali_uk_unbind_mem_s __user *)arg);
+	case MALI_IOC_MEM_MAP_EXT:
+		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_map_external_mem_s), sizeof(u64)));
+		err = mem_map_ext_wrapper(session_data, (_mali_uk_map_external_mem_s __user *)arg);
 		break;
 
-	case MALI_IOC_MEM_WRITE_SAFE:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_mem_write_safe_s), sizeof(u64)));
-		err = mem_write_safe_wrapper(session_data, (_mali_uk_mem_write_safe_s __user *)arg);
+	case MALI_IOC_MEM_UNMAP_EXT:
+		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_unmap_external_mem_s), sizeof(u64)));
+		err = mem_unmap_ext_wrapper(session_data, (_mali_uk_unmap_external_mem_s __user *)arg);
 		break;
 
 	case MALI_IOC_MEM_QUERY_MMU_PAGE_TABLE_DUMP_SIZE:
@@ -817,15 +799,51 @@
 		err = mem_dump_mmu_page_table_wrapper(session_data, (_mali_uk_dump_mmu_page_table_s __user *)arg);
 		break;
 
-	case MALI_IOC_MEM_DMA_BUF_GET_SIZE:
+#if defined(CONFIG_MALI400_UMP)
+
+	case MALI_IOC_MEM_ATTACH_UMP:
+		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_attach_ump_mem_s), sizeof(u64)));
+		err = mem_attach_ump_wrapper(session_data, (_mali_uk_attach_ump_mem_s __user *)arg);
+		break;
+
+	case MALI_IOC_MEM_RELEASE_UMP:
+		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_release_ump_mem_s), sizeof(u64)));
+		err = mem_release_ump_wrapper(session_data, (_mali_uk_release_ump_mem_s __user *)arg);
+		break;
+
+#else
+
+	case MALI_IOC_MEM_ATTACH_UMP:
+	case MALI_IOC_MEM_RELEASE_UMP: /* FALL-THROUGH */
+		MALI_DEBUG_PRINT(2, ("UMP not supported\n"));
+		err = -ENOTTY;
+		break;
+#endif
+
 #ifdef CONFIG_DMA_SHARED_BUFFER
+	case MALI_IOC_MEM_ATTACH_DMA_BUF:
+		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_attach_dma_buf_s), sizeof(u64)));
+		err = mali_attach_dma_buf(session_data, (_mali_uk_attach_dma_buf_s __user *)arg);
+		break;
+
+	case MALI_IOC_MEM_RELEASE_DMA_BUF:
+		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_release_dma_buf_s), sizeof(u64)));
+		err = mali_release_dma_buf(session_data, (_mali_uk_release_dma_buf_s __user *)arg);
+		break;
+
+	case MALI_IOC_MEM_DMA_BUF_GET_SIZE:
 		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_dma_buf_get_size_s), sizeof(u64)));
 		err = mali_dma_buf_get_size(session_data, (_mali_uk_dma_buf_get_size_s __user *)arg);
+		break;
 #else
+
+	case MALI_IOC_MEM_ATTACH_DMA_BUF:   /* FALL-THROUGH */
+	case MALI_IOC_MEM_RELEASE_DMA_BUF:  /* FALL-THROUGH */
+	case MALI_IOC_MEM_DMA_BUF_GET_SIZE: /* FALL-THROUGH */
 		MALI_DEBUG_PRINT(2, ("DMA-BUF not supported\n"));
 		err = -ENOTTY;
-#endif
 		break;
+#endif
 
 	case MALI_IOC_PP_START_JOB:
 		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_pp_start_job_s), sizeof(u64)));
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_kernel_linux.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_kernel_linux.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_kernel_linux.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_kernel_linux.h	2016-04-04 16:25:32.448527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -16,8 +16,6 @@
 #endif
 
 #include <linux/cdev.h>     /* character device definitions */
-#include <linux/idr.h>
-#include <linux/rbtree.h>
 #include "mali_kernel_license.h"
 #include "mali_osk_types.h"
 
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_kernel_sysfs.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_kernel_sysfs.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_kernel_sysfs.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_kernel_sysfs.c	2016-04-04 16:25:32.458527000 +0300
@@ -1,5 +1,5 @@
 /**
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -526,13 +526,13 @@
 
 static ssize_t power_power_events_write(struct file *filp, const char __user *ubuf, size_t cnt, loff_t *ppos)
 {
-	if (!strncmp(ubuf, mali_power_events[_MALI_DEVICE_SUSPEND], strlen(mali_power_events[_MALI_DEVICE_SUSPEND]) - 1)) {
+	if (!strncmp(ubuf, mali_power_events[_MALI_DEVICE_SUSPEND], strlen(mali_power_events[_MALI_DEVICE_SUSPEND])-1)) {
 		mali_pm_os_suspend(MALI_TRUE);
-	} else if (!strncmp(ubuf, mali_power_events[_MALI_DEVICE_RESUME], strlen(mali_power_events[_MALI_DEVICE_RESUME]) - 1)) {
+	} else if (!strncmp(ubuf, mali_power_events[_MALI_DEVICE_RESUME], strlen(mali_power_events[_MALI_DEVICE_RESUME])-1)) {
 		mali_pm_os_resume();
-	} else if (!strncmp(ubuf, mali_power_events[_MALI_DEVICE_DVFS_PAUSE], strlen(mali_power_events[_MALI_DEVICE_DVFS_PAUSE]) - 1)) {
+	} else if (!strncmp(ubuf, mali_power_events[_MALI_DEVICE_DVFS_PAUSE], strlen(mali_power_events[_MALI_DEVICE_DVFS_PAUSE])-1)) {
 		mali_dev_pause();
-	} else if (!strncmp(ubuf, mali_power_events[_MALI_DEVICE_DVFS_RESUME], strlen(mali_power_events[_MALI_DEVICE_DVFS_RESUME]) - 1)) {
+	} else if (!strncmp(ubuf, mali_power_events[_MALI_DEVICE_DVFS_RESUME], strlen(mali_power_events[_MALI_DEVICE_DVFS_RESUME])-1)) {
 		mali_dev_resume();
 	}
 	*ppos += cnt;
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_kernel_sysfs.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_kernel_sysfs.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_kernel_sysfs.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_kernel_sysfs.h	2016-04-04 16:25:32.468527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_linux_trace.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_linux_trace.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_linux_trace.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_linux_trace.h	2016-04-04 16:25:32.478527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_block_alloc.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_block_alloc.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_block_alloc.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_block_alloc.c	2016-04-04 16:25:32.508527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -7,139 +7,42 @@
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
-
 #include "mali_kernel_common.h"
 #include "mali_memory.h"
 #include "mali_memory_block_alloc.h"
 #include "mali_osk.h"
 #include <linux/mutex.h>
+#define MALI_BLOCK_SIZE (256UL * 1024UL)  /* 256 kB, remember to keep the ()s */
 
+struct block_info {
+	struct block_info *next;
+};
 
-struct mali_block_node *_mali_block_node_allocate(mali_page_node_type type)
-{
-	mali_block_node *block_node = NULL;
-
-	block_node = kzalloc(sizeof(mali_block_node), GFP_KERNEL);
-	MALI_DEBUG_ASSERT(NULL != block_node);
-
-	if (block_node) {
-		block_node->type = type;
-		INIT_LIST_HEAD(&block_node->list);
-	}
-
-	return block_node;
-}
-
-void _mali_block_node_ref(struct mali_block_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_BLOCK) {
-		mali_mem_block_add_ref(node);
-	} else
-		MALI_DEBUG_ASSERT(0);
-}
-
-void _mali_block_node_unref(struct mali_block_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_BLOCK) {
-		mali_mem_block_dec_ref(node);
-	} else
-		MALI_DEBUG_ASSERT(0);
-}
-
-
-
-void _mali_block_node_add_block_item(struct mali_block_node *node, mali_block_item *item)
-{
-	MALI_DEBUG_ASSERT(MALI_PAGE_NODE_BLOCK == node->type);
-	node->blk_it = item;
-}
-
-
-int _mali_block_node_get_ref_count(struct mali_block_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_BLOCK) {
-		return mali_mem_block_get_ref_count(node);
-	} else {
-		MALI_DEBUG_ASSERT(0);
-	}
-	return -1;
-}
-
-
-dma_addr_t _mali_block_node_get_phy_addr(struct mali_block_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_BLOCK) {
-		return _mali_blk_item_get_phy_addr(node->blk_it);
-	} else {
-		MALI_DEBUG_ASSERT(0);
-	}
-	return 0;
-}
-
-
-unsigned long _mali_block_node_get_pfn(struct mali_block_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_BLOCK) {
-		/* get phy addr for BLOCK page*/
-		return _mali_blk_item_get_pfn(node->blk_it);
-	} else {
-		MALI_DEBUG_ASSERT(0);
-	}
-	return 0;
-}
-
-
-static mali_block_allocator *mali_mem_block_gobal_allocator = NULL;
-
-unsigned long _mali_blk_item_get_phy_addr(mali_block_item *item)
-{
-	return (item->phy_addr & ~(MALI_BLOCK_REF_MASK));
-}
-
-
-unsigned long _mali_blk_item_get_pfn(mali_block_item *item)
-{
-	return (item->phy_addr / MALI_BLOCK_SIZE);
-}
-
-
-u32 mali_mem_block_get_ref_count(mali_block_node *node)
-{
-	MALI_DEBUG_ASSERT(node->type == MALI_PAGE_NODE_BLOCK);
-	return (node->blk_it->phy_addr & MALI_BLOCK_REF_MASK);
-}
+typedef struct block_info block_info;
 
 
-/* Increase the refence count
-* It not atomic, so it need to get sp_lock before call this function
-*/
+typedef struct block_allocator {
+	struct mutex mutex;
+	block_info *all_blocks;
+	block_info *first_free;
+	u32 base;
+	u32 cpu_usage_adjust;
+	u32 num_blocks;
+	u32 free_blocks;
+} block_allocator;
 
-u32 mali_mem_block_add_ref(mali_block_node *node)
-{
-	MALI_DEBUG_ASSERT(node->type == MALI_PAGE_NODE_BLOCK);
-	MALI_DEBUG_ASSERT(mali_mem_block_get_ref_count(node) < MALI_BLOCK_MAX_REF_COUNT);
-	return (node->blk_it->phy_addr++ & MALI_BLOCK_REF_MASK);
-}
+static block_allocator *mali_mem_block_gobal_allocator = NULL;
 
-/* Decase the refence count
-* It not atomic, so it need to get sp_lock before call this function
-*/
-u32 mali_mem_block_dec_ref(mali_block_node *node)
+MALI_STATIC_INLINE u32 get_phys(block_allocator *info, block_info *block)
 {
-	MALI_DEBUG_ASSERT(node->type == MALI_PAGE_NODE_BLOCK);
-	MALI_DEBUG_ASSERT(mali_mem_block_get_ref_count(node) > 0);
-	return (node->blk_it->phy_addr-- & MALI_BLOCK_REF_MASK);
+	return info->base + ((block - info->all_blocks) * MALI_BLOCK_SIZE);
 }
 
-
-static mali_block_allocator *mali_mem_block_allocator_create(u32 base_address, u32 size)
+static mali_mem_allocator *mali_mem_block_allocator_create(u32 base_address, u32 cpu_usage_adjust, u32 size)
 {
-	mali_block_allocator *info;
+	block_allocator *info;
 	u32 usable_size;
 	u32 num_blocks;
-	mali_block_node *m_node;
-	mali_block_item *mali_blk_items = NULL;
-	int i = 0;
 
 	usable_size = size & ~(MALI_BLOCK_SIZE - 1);
 	MALI_DEBUG_PRINT(3, ("Mali block allocator create for region starting at 0x%08X length 0x%08X\n", base_address, size));
@@ -152,215 +55,246 @@
 		return NULL;
 	}
 
-	info = _mali_osk_calloc(1, sizeof(mali_block_allocator));
+	info = _mali_osk_malloc(sizeof(block_allocator));
 	if (NULL != info) {
-		INIT_LIST_HEAD(&info->free);
-		spin_lock_init(&info->sp_lock);
-		info->total_num = num_blocks;
-		mali_blk_items = _mali_osk_calloc(1, sizeof(mali_block_item) * num_blocks);
-
-		if (mali_blk_items) {
-			info->items = mali_blk_items;
-			/* add blocks(4k size) to free list*/
-			for (i = 0 ; i < num_blocks ; i++) {
-				/* add block information*/
-				mali_blk_items[i].phy_addr = base_address + (i * MALI_BLOCK_SIZE);
-				/* add  to free list */
-				m_node = _mali_block_node_allocate(MALI_PAGE_NODE_BLOCK);
-				if (m_node == NULL)
-					goto fail;
-				_mali_block_node_add_block_item(m_node, &(mali_blk_items[i]));
-				list_add_tail(&m_node->list, &info->free);
-				atomic_add(1, &info->free_num);
+		mutex_init(&info->mutex);
+		info->all_blocks = _mali_osk_malloc(sizeof(block_info) * num_blocks);
+		if (NULL != info->all_blocks) {
+			u32 i;
+			info->first_free = NULL;
+			info->num_blocks = num_blocks;
+			info->free_blocks = num_blocks;
+
+			info->base = base_address;
+			info->cpu_usage_adjust = cpu_usage_adjust;
+
+			for (i = 0; i < num_blocks; i++) {
+				info->all_blocks[i].next = info->first_free;
+				info->first_free = &info->all_blocks[i];
 			}
-			return info;
+
+			return (mali_mem_allocator *)info;
 		}
+		_mali_osk_free(info);
 	}
-fail:
-	mali_mem_block_allocator_destroy();
+
 	return NULL;
 }
 
-void mali_mem_block_allocator_destroy(void)
+void mali_mem_block_allocator_destroy(mali_mem_allocator *allocator)
 {
-	struct mali_block_node *m_page, *m_tmp;
-	mali_block_allocator *info = mali_mem_block_gobal_allocator;
-	MALI_DEBUG_ASSERT_POINTER(info);
-	MALI_DEBUG_PRINT(4, ("Memory block destroy !\n"));
+	block_allocator *info = (block_allocator *)allocator;
 
-	if (NULL == info)
-		return;
+	info = mali_mem_block_gobal_allocator;
+	if (NULL == info) return;
 
-	list_for_each_entry_safe(m_page, m_tmp , &info->free, list) {
-		MALI_DEBUG_ASSERT(m_page->type == MALI_PAGE_NODE_BLOCK);
-		list_del(&m_page->list);
-		kfree(m_page);
-	}
+	MALI_DEBUG_ASSERT_POINTER(info);
 
-	_mali_osk_free(info->items);
+	_mali_osk_free(info->all_blocks);
 	_mali_osk_free(info);
 }
 
-void mali_mem_block_release(mali_mem_backend *mem_bkend)
+static void mali_mem_block_mali_map(mali_mem_allocation *descriptor, u32 phys, u32 virt, u32 size)
 {
-	mali_mem_allocation *alloc = mem_bkend->mali_allocation;;
-	MALI_DEBUG_PRINT(4, ("BLOCK Mem: Release size = 0x%x\n", mem_bkend->size));
+	struct mali_page_directory *pagedir = descriptor->session->page_directory;
+	u32 prop = descriptor->mali_mapping.properties;
+	u32 offset = 0;
 
-	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_BLOCK);
+	while (size) {
+		mali_mmu_pagedir_update(pagedir, virt + offset, phys + offset, MALI_MMU_PAGE_SIZE, prop);
 
-	/* Unmap the memory from the mali virtual address space. */
-	mali_mem_block_mali_unmap(alloc);
-	mali_mem_block_free(&mem_bkend->block_mem);
+		size -= MALI_MMU_PAGE_SIZE;
+		offset += MALI_MMU_PAGE_SIZE;
+	}
 }
 
-
-int mali_mem_block_alloc(mali_mem_block_mem *block_mem, u32 size)
+static int mali_mem_block_cpu_map(mali_mem_allocation *descriptor, struct vm_area_struct *vma, u32 mali_phys, u32 mapping_offset, u32 size, u32 cpu_usage_adjust)
 {
-	struct mali_block_node *m_page, *m_tmp;
-	size_t page_count = PAGE_ALIGN(size) / _MALI_OSK_MALI_PAGE_SIZE;
-	mali_block_allocator *info = mali_mem_block_gobal_allocator;
-	MALI_DEBUG_ASSERT_POINTER(info);
+	u32 virt = vma->vm_start + mapping_offset;
+	u32 cpu_phys = mali_phys + cpu_usage_adjust;
+	u32 offset = 0;
+	int ret;
 
-	MALI_DEBUG_PRINT(4, ("BLOCK Mem: Allocate size = 0x%x\n", size));
-	/*do some init */
-	INIT_LIST_HEAD(&block_mem->pfns);
-
-	spin_lock(&info->sp_lock);
-	/*check if have enough space*/
-	if (atomic_read(&info->free_num) > page_count) {
-		list_for_each_entry_safe(m_page, m_tmp , &info->free, list) {
-			if (page_count > 0) {
-				MALI_DEBUG_ASSERT(m_page->type == MALI_PAGE_NODE_BLOCK);
-				MALI_DEBUG_ASSERT(mali_mem_block_get_ref_count(m_page) == 0);
-				list_move(&m_page->list, &block_mem->pfns);
-				block_mem->count++;
-				atomic_dec(&info->free_num);
-				_mali_block_node_ref(m_page);
-			} else {
-				break;
-			}
-			page_count--;
+	while (size) {
+		ret = vm_insert_pfn(vma, virt + offset, __phys_to_pfn(cpu_phys + offset));
+
+		if (unlikely(ret)) {
+			MALI_DEBUG_PRINT(1, ("Block allocator: Failed to insert pfn into vma\n"));
+			return 1;
 		}
-	} else {
-		/* can't allocate from BLOCK memory*/
-		spin_unlock(&info->sp_lock);
-		return -1;
+
+		size -= MALI_MMU_PAGE_SIZE;
+		offset += MALI_MMU_PAGE_SIZE;
 	}
 
-	spin_unlock(&info->sp_lock);
 	return 0;
 }
 
-void mali_mem_block_free(mali_mem_block_mem *block_mem)
+mali_mem_allocation *mali_mem_block_alloc(u32 mali_addr, u32 size, struct vm_area_struct *vma, struct mali_session_data *session)
 {
-	mali_mem_block_free_list(&block_mem->pfns);
-	MALI_DEBUG_PRINT(4, ("BLOCK Mem free : size = 0x%x\n", block_mem->count * _MALI_OSK_MALI_PAGE_SIZE));
-	block_mem->count = 0;
-	MALI_DEBUG_ASSERT(list_empty(&block_mem->pfns));
-}
+	_mali_osk_errcode_t err;
+	mali_mem_allocation *descriptor;
+	block_allocator *info;
+	u32 left;
+	block_info *last_allocated = NULL;
+	block_allocator_allocation *ret_allocation;
+	u32 offset = 0;
+
+	size = ALIGN(size, MALI_BLOCK_SIZE);
 
+	info = mali_mem_block_gobal_allocator;
+	if (NULL == info) return NULL;
 
-void mali_mem_block_free_list(struct list_head *list)
-{
-	struct mali_block_node *m_page, *m_tmp;
-	mali_block_allocator *info = mali_mem_block_gobal_allocator;
+	left = size;
+	MALI_DEBUG_ASSERT(0 != left);
 
-	if (info) {
-		spin_lock(&info->sp_lock);
-		list_for_each_entry_safe(m_page, m_tmp , list, list) {
-			mali_mem_block_free_node(m_page);
-		}
-		spin_unlock(&info->sp_lock);
+	descriptor = mali_mem_descriptor_create(session, MALI_MEM_BLOCK);
+	if (NULL == descriptor) {
+		return NULL;
 	}
-}
 
-/* free the node,*/
-void mali_mem_block_free_node(struct mali_block_node *node)
-{
-	mali_block_allocator *info = mali_mem_block_gobal_allocator;
+	descriptor->mali_mapping.addr = mali_addr;
+	descriptor->size = size;
+	descriptor->cpu_mapping.addr = (void __user *)vma->vm_start;
+	descriptor->cpu_mapping.ref = 1;
+
+	if (VM_SHARED == (VM_SHARED & vma->vm_flags)) {
+		descriptor->mali_mapping.properties = MALI_MMU_FLAGS_DEFAULT;
+	} else {
+		/* Cached Mali memory mapping */
+		descriptor->mali_mapping.properties = MALI_MMU_FLAGS_FORCE_GP_READ_ALLOCATE;
+		vma->vm_flags |= VM_SHARED;
+	}
+
+	ret_allocation = &descriptor->block_mem.mem;
+
+	ret_allocation->mapping_length = 0;
+
+	_mali_osk_mutex_wait(session->memory_lock);
+	mutex_lock(&info->mutex);
 
-	/* only handle BLOCK node */
-	if (node->type == MALI_PAGE_NODE_BLOCK && info) {
-		/*Need to make this atomic?*/
-		if (1 == _mali_block_node_get_ref_count(node)) {
-			/*Move to free list*/
-			_mali_block_node_unref(node);
-			list_move_tail(&node->list, &info->free);
-			atomic_add(1, &info->free_num);
+	if (left > (info->free_blocks * MALI_BLOCK_SIZE)) {
+		MALI_DEBUG_PRINT(2, ("Mali block allocator: not enough free blocks to service allocation (%u)\n", left));
+		mutex_unlock(&info->mutex);
+		_mali_osk_mutex_signal(session->memory_lock);
+		mali_mem_descriptor_destroy(descriptor);
+		return NULL;
+	}
+
+	err = mali_mem_mali_map_prepare(descriptor);
+	if (_MALI_OSK_ERR_OK != err) {
+		mutex_unlock(&info->mutex);
+		_mali_osk_mutex_signal(session->memory_lock);
+		mali_mem_descriptor_destroy(descriptor);
+		return NULL;
+	}
+
+	while ((left > 0) && (info->first_free)) {
+		block_info *block;
+		u32 phys_addr;
+		u32 current_mapping_size;
+
+		block = info->first_free;
+		info->first_free = info->first_free->next;
+		block->next = last_allocated;
+		last_allocated = block;
+
+		phys_addr = get_phys(info, block);
+
+		if (MALI_BLOCK_SIZE < left) {
+			current_mapping_size = MALI_BLOCK_SIZE;
 		} else {
-			_mali_block_node_unref(node);
-			list_del(&node->list);
-			kfree(node);
+			current_mapping_size = left;
 		}
-	}
-}
 
+		mali_mem_block_mali_map(descriptor, phys_addr, mali_addr + offset, current_mapping_size);
+		if (mali_mem_block_cpu_map(descriptor, vma, phys_addr, offset, current_mapping_size, info->cpu_usage_adjust)) {
+			/* release all memory back to the pool */
+			while (last_allocated) {
+				/* This relinks every block we've just allocated back into the free-list */
+				block = last_allocated->next;
+				last_allocated->next = info->first_free;
+				info->first_free = last_allocated;
+				last_allocated = block;
+			}
 
-int mali_mem_block_mali_map(mali_mem_block_mem *block_mem, struct mali_session_data *session, u32 vaddr, u32 props)
-{
-	struct mali_page_directory *pagedir = session->page_directory;
-	struct mali_block_node *m_page;
-	dma_addr_t phys;
-	u32 virt = vaddr;
-	u32 prop = props;
-
-	list_for_each_entry(m_page, &block_mem->pfns, list) {
-		MALI_DEBUG_ASSERT(m_page->type == MALI_PAGE_NODE_BLOCK);
-		phys = _mali_block_node_get_phy_addr(m_page);
-#if defined(CONFIG_ARCH_DMA_ADDR_T_64BIT)
-		/* Verify that the "physical" address is 32-bit and
-		 * usable for Mali, when on a system with bus addresses
-		 * wider than 32-bit. */
-		MALI_DEBUG_ASSERT(0 == (phys >> 32));
-#endif
-		mali_mmu_pagedir_update(pagedir, virt, (mali_dma_addr)phys, MALI_MMU_PAGE_SIZE, prop);
-		virt += MALI_MMU_PAGE_SIZE;
+			mutex_unlock(&info->mutex);
+			_mali_osk_mutex_signal(session->memory_lock);
+
+			mali_mem_mali_map_free(descriptor);
+			mali_mem_descriptor_destroy(descriptor);
+
+			return NULL;
+		}
+
+		left -= current_mapping_size;
+		offset += current_mapping_size;
+		ret_allocation->mapping_length += current_mapping_size;
+
+		--info->free_blocks;
 	}
 
-	return 0;
+	mutex_unlock(&info->mutex);
+	_mali_osk_mutex_signal(session->memory_lock);
+
+	MALI_DEBUG_ASSERT(0 == left);
+
+	/* Record all the information about this allocation */
+	ret_allocation->last_allocated = last_allocated;
+	ret_allocation->info = info;
+
+	return descriptor;
 }
 
-void mali_mem_block_mali_unmap(mali_mem_allocation *alloc)
+void mali_mem_block_release(mali_mem_allocation *descriptor)
 {
-	struct mali_session_data *session;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-	session = alloc->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	mali_session_memory_lock(session);
-	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
-			       alloc->flags);
-	session->mali_mem_array[alloc->type] -= alloc->psize;
-	mali_session_memory_unlock(session);
-}
+	block_allocator *info = descriptor->block_mem.mem.info;
+	block_info *block, *next;
+	block_allocator_allocation *allocation = &descriptor->block_mem.mem;
 
+	MALI_DEBUG_ASSERT(MALI_MEM_BLOCK == descriptor->type);
 
-int mali_mem_block_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma)
-{
-	int ret;
-	mali_mem_block_mem *block_mem = &mem_bkend->block_mem;
-	unsigned long addr = vma->vm_start;
-	struct mali_block_node *m_page;
-	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_BLOCK);
-
-	list_for_each_entry(m_page, &block_mem->pfns, list) {
-		MALI_DEBUG_ASSERT(m_page->type == MALI_PAGE_NODE_BLOCK);
-		ret = vm_insert_pfn(vma, addr, _mali_block_node_get_pfn(m_page));
+	block = allocation->last_allocated;
 
-		if (unlikely(0 != ret)) {
-			return -EFAULT;
-		}
-		addr += _MALI_OSK_MALI_PAGE_SIZE;
+	MALI_DEBUG_ASSERT_POINTER(block);
+
+	/* unmap */
+	mali_mem_mali_map_free(descriptor);
+
+	mutex_lock(&info->mutex);
+
+	while (block) {
+		MALI_DEBUG_ASSERT(!((block < info->all_blocks) || (block > (info->all_blocks + info->num_blocks))));
 
+		next = block->next;
+
+		/* relink into free-list */
+		block->next = info->first_free;
+		info->first_free = block;
+
+		/* advance the loop */
+		block = next;
+
+		++info->free_blocks;
 	}
 
-	return 0;
+	mutex_unlock(&info->mutex);
 }
 
+u32 mali_mem_block_allocator_stat(void)
+{
+	block_allocator *info = (block_allocator *)mali_mem_block_gobal_allocator;
+
+	if (NULL == info) return 0;
+
+	MALI_DEBUG_ASSERT_POINTER(info);
+
+	return (info->num_blocks - info->free_blocks) * MALI_BLOCK_SIZE;
+}
 
 _mali_osk_errcode_t mali_memory_core_resource_dedicated_memory(u32 start, u32 size)
 {
-	mali_block_allocator *allocator;
+	mali_mem_allocator *allocator;
 
 	/* Do the low level linux operation first */
 
@@ -371,7 +305,7 @@
 	}
 
 	/* Create generic block allocator object to handle it */
-	allocator = mali_mem_block_allocator_create(start, size);
+	allocator = mali_mem_block_allocator_create(start, 0 /* cpu_usage_adjust */, size);
 
 	if (NULL == allocator) {
 		MALI_DEBUG_PRINT(1, ("Memory bank registration failed\n"));
@@ -379,20 +313,7 @@
 		MALI_ERROR(_MALI_OSK_ERR_FAULT);
 	}
 
-	mali_mem_block_gobal_allocator = (mali_block_allocator *)allocator;
+	mali_mem_block_gobal_allocator = (block_allocator *)allocator;
 
 	return _MALI_OSK_ERR_OK;
 }
-
-mali_bool mali_memory_have_dedicated_memory(void)
-{
-	return mali_mem_block_gobal_allocator ? MALI_TRUE : MALI_FALSE;
-}
-
-u32 mali_mem_block_allocator_stat(void)
-{
-	mali_block_allocator *allocator = mali_mem_block_gobal_allocator;
-	MALI_DEBUG_ASSERT_POINTER(allocator);
-
-	return (allocator->total_num - atomic_read(&allocator->free_num)) * _MALI_OSK_MALI_PAGE_SIZE;
-}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_block_alloc.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_block_alloc.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_block_alloc.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_block_alloc.h	2016-04-04 16:25:32.528527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -13,45 +13,17 @@
 
 #include "mali_session.h"
 #include "mali_memory.h"
-#include <linux/spinlock.h>
 
 #include "mali_memory_types.h"
 
-#define MALI_BLOCK_SIZE (PAGE_SIZE)  /* 4 kB, manage BLOCK memory as page size */
-#define MALI_BLOCK_REF_MASK (0xFFF)
-#define MALI_BLOCK_MAX_REF_COUNT (0xFFF)
+typedef struct mali_mem_allocator mali_mem_allocator;
 
+mali_mem_allocator *mali_block_allocator_create(u32 base_address, u32 cpu_usage_adjust, u32 size);
+void mali_mem_block_allocator_destroy(mali_mem_allocator *allocator);
 
+mali_mem_allocation *mali_mem_block_alloc(u32 mali_addr, u32 size, struct vm_area_struct *vma, struct mali_session_data *session);
+void mali_mem_block_release(mali_mem_allocation *descriptor);
 
-typedef struct mali_block_allocator {
-	/*
-	* In free list, each node's ref_count is 0,
-	* ref_count added when allocated or referenced in COW
-	*/
-	mali_block_item *items; /* information for each block item*/
-	struct list_head free; /*free list of mali_memory_node*/
-	spinlock_t sp_lock; /*lock for reference count & free list opertion*/
-	u32 total_num; /* Number of total pages*/
-	atomic_t free_num; /*number of free pages*/
-} mali_block_allocator;
-
-unsigned long _mali_blk_item_get_phy_addr(mali_block_item *item);
-unsigned long _mali_blk_item_get_pfn(mali_block_item *item);
-u32 mali_mem_block_get_ref_count(mali_block_node *node);
-u32 mali_mem_block_add_ref(mali_block_node *node);
-u32 mali_mem_block_dec_ref(mali_block_node *node);
-void mali_mem_block_release(mali_mem_backend *mem_bkend);
-int mali_mem_block_alloc(mali_mem_block_mem *block_mem, u32 size);
-int mali_mem_block_mali_map(mali_mem_block_mem *block_mem, struct mali_session_data *session, u32 vaddr, u32 props);
-void mali_mem_block_mali_unmap(mali_mem_allocation *alloc);
-
-int mali_mem_block_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma);
-_mali_osk_errcode_t mali_memory_core_resource_dedicated_memory(u32 start, u32 size);
-mali_bool mali_memory_have_dedicated_memory(void);
-void mali_mem_block_free(mali_mem_block_mem *block_mem);
-void mali_mem_block_free_list(struct list_head *list);
-void mali_mem_block_free_node(struct mali_block_node *node);
-void mali_mem_block_allocator_destroy(void);
 u32 mali_mem_block_allocator_stat(void);
 
 #endif /* __MALI_BLOCK_ALLOCATOR_H__ */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory.c	2016-04-04 16:25:32.488527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -16,73 +16,136 @@
 #include <linux/slab.h>
 #include <linux/version.h>
 #include <linux/platform_device.h>
-#include <linux/idr.h>
 
 #include "mali_osk.h"
+#include "mali_osk_mali.h"
+#include "mali_kernel_linux.h"
+#include "mali_scheduler.h"
 #include "mali_executor.h"
+#include "mali_kernel_descriptor_mapping.h"
 
 #include "mali_memory.h"
+#include "mali_memory_dma_buf.h"
 #include "mali_memory_os_alloc.h"
 #include "mali_memory_block_alloc.h"
-#include "mali_memory_util.h"
-#include "mali_memory_virtual.h"
-#include "mali_memory_manager.h"
 
 extern unsigned int mali_dedicated_mem_size;
 extern unsigned int mali_shared_mem_size;
 
 /* session->memory_lock must be held when calling this function */
+static void mali_mem_release(mali_mem_allocation *descriptor)
+{
+	MALI_DEBUG_ASSERT_POINTER(descriptor);
+	MALI_DEBUG_ASSERT_LOCK_HELD(descriptor->session->memory_lock);
+
+	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == descriptor->magic);
+
+	switch (descriptor->type) {
+	case MALI_MEM_OS:
+		mali_mem_os_release(descriptor);
+		break;
+	case MALI_MEM_DMA_BUF:
+#if defined(CONFIG_DMA_SHARED_BUFFER)
+		mali_mem_dma_buf_release(descriptor);
+#endif
+		break;
+	case MALI_MEM_UMP:
+#if defined(CONFIG_MALI400_UMP)
+		mali_mem_ump_release(descriptor);
+#endif
+		break;
+	case MALI_MEM_EXTERNAL:
+		mali_mem_external_release(descriptor);
+		break;
+	case MALI_MEM_BLOCK:
+		mali_mem_block_release(descriptor);
+		break;
+	default:
+		MALI_DEBUG_PRINT(1, ("mem type %d is not in the mali_mem_type enum.\n", descriptor->type));
+		break;
+	}
+}
+
 static void mali_mem_vma_open(struct vm_area_struct *vma)
 {
-	mali_mem_allocation *alloc = (mali_mem_allocation *)vma->vm_private_data;
+	mali_mem_allocation *descriptor = (mali_mem_allocation *)vma->vm_private_data;
 	MALI_DEBUG_PRINT(4, ("Open called on vma %p\n", vma));
 
-	/* If need to share the allocation, add ref_count here */
-	mali_allocation_ref(alloc);
+	descriptor->cpu_mapping.ref++;
+
 	return;
 }
+
 static void mali_mem_vma_close(struct vm_area_struct *vma)
 {
-	/* If need to share the allocation, unref ref_count here */
-	mali_mem_allocation *alloc = (mali_mem_allocation *)vma->vm_private_data;
+	mali_mem_allocation *descriptor;
+	struct mali_session_data *session;
+	mali_mem_virt_cpu_mapping *mapping;
+
+	MALI_DEBUG_PRINT(3, ("Close called on vma %p\n", vma));
+
+	descriptor = (mali_mem_allocation *)vma->vm_private_data;
+	BUG_ON(!descriptor);
+
+	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == descriptor->magic);
+
+	mapping = &descriptor->cpu_mapping;
+	BUG_ON(0 == mapping->ref);
+
+	mapping->ref--;
+	if (0 != mapping->ref) {
+		MALI_DEBUG_PRINT(3, ("Ignoring this close, %d references still exists\n", mapping->ref));
+		return;
+	}
 
-	mali_allocation_unref(&alloc);
-	vma->vm_private_data = NULL;
+	session = descriptor->session;
+
+	mali_descriptor_mapping_free(session->descriptor_mapping, descriptor->id);
+
+	_mali_osk_mutex_wait(session->memory_lock);
+	mali_mem_release(descriptor);
+	_mali_osk_mutex_signal(session->memory_lock);
+
+	mali_mem_descriptor_destroy(descriptor);
 }
 
-static int mali_mem_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+static int mali_kernel_memory_cpu_page_fault_handler(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
-	/* Not support yet */
-	MALI_DEBUG_ASSERT(0);
-	return 0;
+	void __user *address;
+	mali_mem_allocation *descriptor;
+
+	address = vmf->virtual_address;
+	descriptor = (mali_mem_allocation *)vma->vm_private_data;
+
+	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == descriptor->magic);
+
+	/*
+	 * We always fail the call since all memory is pre-faulted when assigned to the process.
+	 * Only the Mali cores can use page faults to extend buffers.
+	*/
+
+	MALI_DEBUG_PRINT(1, ("Page-fault in Mali memory region caused by the CPU.\n"));
+	MALI_DEBUG_PRINT(1, ("Tried to access %p (process local virtual address) which is not currently mapped to any Mali memory.\n", (void *)address));
+
+	MALI_IGNORE(address);
+	MALI_IGNORE(descriptor);
+
+	return VM_FAULT_SIGBUS;
 }
 
 static struct vm_operations_struct mali_kernel_vm_ops = {
 	.open = mali_mem_vma_open,
 	.close = mali_mem_vma_close,
-	.fault = mali_mem_vma_fault,
+	.fault = mali_kernel_memory_cpu_page_fault_handler
 };
 
-
-/** @ map mali allocation to CPU address
-*
-* Supported backend types:
-* --MALI_MEM_OS
-* -- need to add COW?
- *Not supported backend types:
-* -_MALI_MEMORY_BIND_BACKEND_UMP
-* -_MALI_MEMORY_BIND_BACKEND_DMA_BUF
-* -_MALI_MEMORY_BIND_BACKEND_EXTERNAL_MEMORY
-*
-*/
+/** @note munmap handler is done by vma close handler */
 int mali_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	struct mali_session_data *session;
-	mali_mem_allocation *mali_alloc = NULL;
+	mali_mem_allocation *descriptor;
+	u32 size = vma->vm_end - vma->vm_start;
 	u32 mali_addr = vma->vm_pgoff << PAGE_SHIFT;
-	struct mali_vma_node *mali_vma_node = NULL;
-	mali_mem_backend *mem_bkend = NULL;
-	int ret;
 
 	session = (struct mali_session_data *)filp->private_data;
 	if (NULL == session) {
@@ -111,58 +174,68 @@
 #endif
 
 	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
-	vma->vm_ops = &mali_kernel_vm_ops;
-	/* Operations used on any memory system */
+	vma->vm_ops = &mali_kernel_vm_ops; /* Operations used on any memory system */
 
-	/* find mali allocation structure by vaddress*/
-	mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, mali_addr, 0);
-	if (likely(mali_vma_node)) {
-		mali_alloc = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
-		MALI_DEBUG_ASSERT(mali_addr == mali_vma_node->vm_node.start);
-		if (unlikely(mali_addr != mali_vma_node->vm_node.start)) {
-			/* only allow to use start address for mmap */
-			return -EFAULT;
+	descriptor = mali_mem_block_alloc(mali_addr, size, vma, session);
+	if (NULL == descriptor) {
+		descriptor = mali_mem_os_alloc(mali_addr, size, vma, session);
+		if (NULL == descriptor) {
+			MALI_DEBUG_PRINT(3, ("MMAP failed\n"));
+			return -ENOMEM;
 		}
-	} else {
-		MALI_DEBUG_ASSERT(NULL == mali_vma_node);
-		return -EFAULT;
 	}
 
-	mali_alloc->cpu_mapping.addr = (void __user *)vma->vm_start;
+	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == descriptor->magic);
+
+	vma->vm_private_data = (void *)descriptor;
 
-	/* Get backend memory & Map on CPU */
-	mutex_lock(&mali_idr_mutex);
-	if (!(mem_bkend = idr_find(&mali_backend_idr, mali_alloc->backend_handle))) {
-		MALI_DEBUG_PRINT(1, ("Can't find memory backend in mmap!\n"));
-		mutex_unlock(&mali_idr_mutex);
+	/* Put on descriptor map */
+	if (_MALI_OSK_ERR_OK != mali_descriptor_mapping_allocate_mapping(session->descriptor_mapping, descriptor, &descriptor->id)) {
+		_mali_osk_mutex_wait(session->memory_lock);
+		if (MALI_MEM_OS == descriptor->type) {
+			mali_mem_os_release(descriptor);
+		} else if (MALI_MEM_BLOCK == descriptor->type) {
+			mali_mem_block_release(descriptor);
+		}
+		_mali_osk_mutex_signal(session->memory_lock);
 		return -EFAULT;
 	}
-	mutex_unlock(&mali_idr_mutex);
 
-	if (mem_bkend->type == MALI_MEM_OS) {
-		ret = mali_mem_os_cpu_map(&mem_bkend->os_mem, vma);
-	} else if (mem_bkend->type == MALI_MEM_BLOCK) {
-		ret = mali_mem_block_cpu_map(mem_bkend, vma);
-	} else {
-		/* Not support yet*/
-		MALI_DEBUG_ASSERT(0);
-		ret = -EFAULT;
+	return 0;
+}
+
+
+/* Prepare memory descriptor */
+mali_mem_allocation *mali_mem_descriptor_create(struct mali_session_data *session, mali_mem_type type)
+{
+	mali_mem_allocation *descriptor;
+
+	descriptor = (mali_mem_allocation *)kzalloc(sizeof(mali_mem_allocation), GFP_KERNEL);
+	if (NULL == descriptor) {
+		MALI_DEBUG_PRINT(3, ("mali_ukk_mem_mmap: descriptor was NULL\n"));
+		return NULL;
 	}
 
-	if (ret != 0)
-		return -EFAULT;
+	MALI_DEBUG_CODE(descriptor->magic = MALI_MEM_ALLOCATION_VALID_MAGIC);
+
+	descriptor->flags = 0;
+	descriptor->type = type;
+	descriptor->session = session;
 
-	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == mali_alloc->magic);
+	return descriptor;
+}
 
-	vma->vm_private_data = (void *)mali_alloc;
-	mali_allocation_ref(mali_alloc);
+void mali_mem_descriptor_destroy(mali_mem_allocation *descriptor)
+{
+	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == descriptor->magic);
+	MALI_DEBUG_CODE(descriptor->magic = MALI_MEM_ALLOCATION_FREED_MAGIC);
 
-	return 0;
+	kfree(descriptor);
 }
 
 _mali_osk_errcode_t mali_mem_mali_map_prepare(mali_mem_allocation *descriptor)
 {
-	u32 size = descriptor->psize;
+	u32 size = descriptor->size;
 	struct mali_session_data *session = descriptor->session;
 
 	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == descriptor->magic);
@@ -173,18 +246,23 @@
 		size += MALI_MMU_PAGE_SIZE;
 	}
 
-	return mali_mmu_pagedir_map(session->page_directory, descriptor->mali_vma_node.vm_node.start, size);
+	return mali_mmu_pagedir_map(session->page_directory, descriptor->mali_mapping.addr, size);
 }
 
-
-void mali_mem_mali_map_free(struct mali_session_data *session, u32 size, mali_address_t vaddr, u32 flags)
+void mali_mem_mali_map_free(mali_mem_allocation *descriptor)
 {
-	if (flags & MALI_MEM_FLAG_MALI_GUARD_PAGE) {
+	u32 size = descriptor->size;
+	struct mali_session_data *session = descriptor->session;
+
+	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == descriptor->magic);
+
+	if (descriptor->flags & MALI_MEM_FLAG_MALI_GUARD_PAGE) {
 		size += MALI_MMU_PAGE_SIZE;
 	}
 
 	/* Umap and flush L2 */
-	mali_mmu_pagedir_unmap(session->page_directory, vaddr, size);
+	mali_mmu_pagedir_unmap(session->page_directory, descriptor->mali_mapping.addr, descriptor->size);
+
 	mali_executor_zap_all_active(session);
 }
 
@@ -192,10 +270,7 @@
 {
 	u32 sum = 0;
 
-	if (MALI_TRUE == mali_memory_have_dedicated_memory()) {
-		sum += mali_mem_block_allocator_stat();
-	}
-
+	sum += mali_mem_block_allocator_stat();
 	sum += mali_mem_os_stat();
 
 	return sum;
@@ -217,20 +292,45 @@
 {
 	MALI_DEBUG_PRINT(5, ("Memory session begin\n"));
 
+	/* Create descriptor mapping table */
+	session_data->descriptor_mapping = mali_descriptor_mapping_create(MALI_MEM_DESCRIPTORS_INIT, MALI_MEM_DESCRIPTORS_MAX);
+
+	if (NULL == session_data->descriptor_mapping) {
+		MALI_ERROR(_MALI_OSK_ERR_NOMEM);
+	}
+
 	session_data->memory_lock = _mali_osk_mutex_init(_MALI_OSK_LOCKFLAG_ORDERED,
 				    _MALI_OSK_LOCK_ORDER_MEM_SESSION);
 
 	if (NULL == session_data->memory_lock) {
+		mali_descriptor_mapping_destroy(session_data->descriptor_mapping);
 		_mali_osk_free(session_data);
 		MALI_ERROR(_MALI_OSK_ERR_FAULT);
 	}
 
-	mali_memory_manager_init(&session_data->allocation_mgr);
-
 	MALI_DEBUG_PRINT(5, ("MMU session begin: success\n"));
 	MALI_SUCCESS;
 }
 
+/** @brief Callback function that releases memory
+ *
+ * session->memory_lock must be held when calling this function.
+ */
+static void descriptor_table_cleanup_callback(int descriptor_id, void *map_target)
+{
+	mali_mem_allocation *descriptor;
+
+	descriptor = (mali_mem_allocation *)map_target;
+
+	MALI_DEBUG_ASSERT_LOCK_HELD(descriptor->session->memory_lock);
+
+	MALI_DEBUG_PRINT(3, ("Cleanup of descriptor %d mapping to 0x%x in descriptor table\n", descriptor_id, map_target));
+	MALI_DEBUG_ASSERT(descriptor);
+
+	mali_mem_release(descriptor);
+	mali_mem_descriptor_destroy(descriptor);
+}
+
 void mali_memory_session_end(struct mali_session_data *session)
 {
 	MALI_DEBUG_PRINT(3, ("MMU session end\n"));
@@ -239,10 +339,18 @@
 		MALI_DEBUG_PRINT(1, ("No session data found during session end\n"));
 		return;
 	}
-	/* free allocation */
-	mali_free_session_allocations(session);
-	/* do some check in unint*/
-	mali_memory_manager_uninit(&session->allocation_mgr);
+
+	/* Lock the session so we can modify the memory list */
+	_mali_osk_mutex_wait(session->memory_lock);
+
+	/* Free all allocations still in the descriptor map, and terminate the map */
+	if (NULL != session->descriptor_mapping) {
+		mali_descriptor_mapping_call_for_each(session->descriptor_mapping, descriptor_table_cleanup_callback);
+		mali_descriptor_mapping_destroy(session->descriptor_mapping);
+		session->descriptor_mapping = NULL;
+	}
+
+	_mali_osk_mutex_signal(session->memory_lock);
 
 	/* Free the lock */
 	_mali_osk_mutex_term(session->memory_lock);
@@ -252,17 +360,11 @@
 
 _mali_osk_errcode_t mali_memory_initialize(void)
 {
-	idr_init(&mali_backend_idr);
-	mutex_init(&mali_idr_mutex);
 	return mali_mem_os_init();
 }
 
 void mali_memory_terminate(void)
 {
 	mali_mem_os_term();
-	if (mali_memory_have_dedicated_memory()) {
-		mali_mem_block_allocator_destroy();
-	}
+	mali_mem_block_allocator_destroy(NULL);
 }
-
-
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_dma_buf.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_dma_buf.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_dma_buf.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_dma_buf.c	2016-04-04 16:25:32.538527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -26,28 +26,35 @@
 
 #include "mali_memory.h"
 #include "mali_memory_dma_buf.h"
-#include "mali_memory_virtual.h"
+
 #include "mali_pp_job.h"
 
-static void mali_dma_buf_unmap(mali_mem_allocation *alloc, struct mali_dma_buf_attachment *mem);
+static void mali_dma_buf_unmap(struct mali_dma_buf_attachment *mem);
+
+struct mali_dma_buf_attachment {
+	struct dma_buf *buf;
+	struct dma_buf_attachment *attachment;
+	struct sg_table *sgt;
+	struct mali_session_data *session;
+	int map_ref;
+	struct mutex map_lock;
+	mali_bool is_mapped;
+	wait_queue_head_t wait_queue;
+};
 
-void mali_mem_dma_buf_release(mali_mem_backend *mem_backend)
+static void mali_dma_buf_release(struct mali_dma_buf_attachment *mem)
 {
-	struct mali_dma_buf_attachment *mem;
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	MALI_DEBUG_ASSERT(MALI_MEM_DMA_BUF == mem_backend->type);
+	MALI_DEBUG_PRINT(3, ("Mali DMA-buf: release attachment %p\n", mem));
 
-	mem = mem_backend->dma_buf.attachment;
 	MALI_DEBUG_ASSERT_POINTER(mem);
 	MALI_DEBUG_ASSERT_POINTER(mem->attachment);
 	MALI_DEBUG_ASSERT_POINTER(mem->buf);
-	MALI_DEBUG_PRINT(3, ("Mali DMA-buf: release attachment %p\n", mem));
 
 #if defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
-	MALI_DEBUG_ASSERT_POINTER(mem_backend->mali_allocation);
 	/* We mapped implicitly on attach, so we need to unmap on release */
-	mali_dma_buf_unmap(mem_backend->mali_allocation, mem);
+	mali_dma_buf_unmap(mem);
 #endif
+
 	/* Wait for buffer to become unmapped */
 	wait_event(mem->wait_queue, !mem->is_mapped);
 	MALI_DEBUG_ASSERT(!mem->is_mapped);
@@ -58,64 +65,45 @@
 	_mali_osk_free(mem);
 }
 
+void mali_mem_dma_buf_release(mali_mem_allocation *descriptor)
+{
+	struct mali_dma_buf_attachment *mem = descriptor->dma_buf.attachment;
+
+	mali_dma_buf_release(mem);
+}
+
 /*
  * Map DMA buf attachment \a mem into \a session at virtual address \a virt.
  */
-static int mali_dma_buf_map(mali_mem_backend *mem_backend)
+static int mali_dma_buf_map(struct mali_dma_buf_attachment *mem, struct mali_session_data *session, u32 virt, u32 flags)
 {
-	mali_mem_allocation *alloc;
-	struct mali_dma_buf_attachment *mem;
-	struct  mali_session_data *session;
 	struct mali_page_directory *pagedir;
-	_mali_osk_errcode_t err;
 	struct scatterlist *sg;
-	u32 virt, flags;
 	int i;
 
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-
-	alloc = mem_backend->mali_allocation;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-
-	mem = mem_backend->dma_buf.attachment;
 	MALI_DEBUG_ASSERT_POINTER(mem);
-
-	session = alloc->session;
 	MALI_DEBUG_ASSERT_POINTER(session);
 	MALI_DEBUG_ASSERT(mem->session == session);
 
-	virt = alloc->mali_vma_node.vm_node.start;
-	flags = alloc->flags;
+	mutex_lock(&mem->map_lock);
 
-	mali_session_memory_lock(session);
 	mem->map_ref++;
 
 	MALI_DEBUG_PRINT(5, ("Mali DMA-buf: map attachment %p, new map_ref = %d\n", mem, mem->map_ref));
 
 	if (1 == mem->map_ref) {
-
 		/* First reference taken, so we need to map the dma buf */
 		MALI_DEBUG_ASSERT(!mem->is_mapped);
 
+		pagedir = mali_session_get_page_directory(session);
+		MALI_DEBUG_ASSERT_POINTER(pagedir);
+
 		mem->sgt = dma_buf_map_attachment(mem->attachment, DMA_BIDIRECTIONAL);
 		if (IS_ERR_OR_NULL(mem->sgt)) {
 			MALI_DEBUG_PRINT_ERROR(("Failed to map dma-buf attachment\n"));
-			mem->map_ref--;
-			mali_session_memory_unlock(session);
 			return -EFAULT;
 		}
 
-		err = mali_mem_mali_map_prepare(alloc);
-		if (_MALI_OSK_ERR_OK != err) {
-			MALI_DEBUG_PRINT(1, ("Mapping of DMA memory failed\n"));
-			mem->map_ref--;
-			mali_session_memory_unlock(session);
-			return -ENOMEM;
-		}
-
-		pagedir = mali_session_get_page_directory(session);
-		MALI_DEBUG_ASSERT_POINTER(pagedir);
-
 		for_each_sg(mem->sgt->sgl, sg, mem->sgt->nents, i) {
 			u32 size = sg_dma_len(sg);
 			dma_addr_t phys = sg_dma_address(sg);
@@ -138,41 +126,38 @@
 		}
 
 		mem->is_mapped = MALI_TRUE;
-		session->mali_mem_array[mem_backend->type] += mem_backend->size;
-		mali_session_memory_unlock(session);
+		mutex_unlock(&mem->map_lock);
+
 		/* Wake up any thread waiting for buffer to become mapped */
 		wake_up_all(&mem->wait_queue);
 	} else {
 		MALI_DEBUG_ASSERT(mem->is_mapped);
-		mali_session_memory_unlock(session);
+		mutex_unlock(&mem->map_lock);
 	}
 
 	return 0;
 }
 
-static void mali_dma_buf_unmap(mali_mem_allocation *alloc, struct mali_dma_buf_attachment *mem)
+static void mali_dma_buf_unmap(struct mali_dma_buf_attachment *mem)
 {
-	MALI_DEBUG_ASSERT_POINTER(alloc);
 	MALI_DEBUG_ASSERT_POINTER(mem);
 	MALI_DEBUG_ASSERT_POINTER(mem->attachment);
 	MALI_DEBUG_ASSERT_POINTER(mem->buf);
-	MALI_DEBUG_ASSERT_POINTER(alloc->session);
 
-	mali_session_memory_lock(alloc->session);
+	mutex_lock(&mem->map_lock);
+
 	mem->map_ref--;
 
 	MALI_DEBUG_PRINT(5, ("Mali DMA-buf: unmap attachment %p, new map_ref = %d\n", mem, mem->map_ref));
 
 	if (0 == mem->map_ref) {
 		dma_buf_unmap_attachment(mem->attachment, mem->sgt, DMA_BIDIRECTIONAL);
-		if (MALI_TRUE == mem->is_mapped) {
-			mali_mem_mali_map_free(alloc->session, alloc->psize, alloc->mali_vma_node.vm_node.start,
-					       alloc->flags);
-		}
+
 		mem->is_mapped = MALI_FALSE;
-		alloc->session->mali_mem_array[alloc->type] -= alloc->psize;
 	}
-	mali_session_memory_unlock(alloc->session);
+
+	mutex_unlock(&mem->map_lock);
+
 	/* Wake up any thread waiting for buffer to become unmapped */
 	wake_up_all(&mem->wait_queue);
 }
@@ -180,15 +165,13 @@
 #if !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
 int mali_dma_buf_map_job(struct mali_pp_job *job)
 {
+	mali_mem_allocation *descriptor;
 	struct mali_dma_buf_attachment *mem;
 	_mali_osk_errcode_t err;
 	int i;
 	int ret = 0;
 	u32 num_memory_cookies;
 	struct mali_session_data *session;
-	struct mali_vma_node *mali_vma_node = NULL;
-	mali_mem_allocation *mali_alloc = NULL;
-	mali_mem_backend *mem_bkend = NULL;
 
 	MALI_DEBUG_ASSERT_POINTER(job);
 
@@ -198,92 +181,104 @@
 
 	MALI_DEBUG_ASSERT_POINTER(session);
 
+	mali_session_memory_lock(session);
+
 	for (i = 0; i < num_memory_cookies; i++) {
-		u32 mali_addr  = mali_pp_job_get_memory_cookie(job, i);
-		mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, mali_addr, 0);
-		MALI_DEBUG_ASSERT(NULL != mali_vma_node);
-		mali_alloc = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
-		MALI_DEBUG_ASSERT(NULL != mali_alloc);
-		if (MALI_MEM_DMA_BUF != mali_alloc->type) {
+		u32 cookie = mali_pp_job_get_memory_cookie(job, i);
+
+		if (0 == cookie) {
+			/* 0 is not a valid cookie */
+			MALI_DEBUG_ASSERT(NULL ==
+					  mali_pp_job_get_dma_buf(job, i));
+			continue;
+		}
+
+		MALI_DEBUG_ASSERT(0 < cookie);
+
+		err = mali_descriptor_mapping_get(
+			      mali_pp_job_get_session(job)->descriptor_mapping,
+			      cookie, (void **)&descriptor);
+
+		if (_MALI_OSK_ERR_OK != err) {
+			MALI_DEBUG_PRINT_ERROR(("Mali DMA-buf: Failed to get descriptor for cookie %d\n", cookie));
+			ret = -EFAULT;
+			MALI_DEBUG_ASSERT(NULL ==
+					  mali_pp_job_get_dma_buf(job, i));
 			continue;
 		}
 
-		/* Get backend memory & Map on CPU */
-		mutex_lock(&mali_idr_mutex);
-		mem_bkend = idr_find(&mali_backend_idr, mali_alloc->backend_handle);
-		mutex_unlock(&mali_idr_mutex);
-		MALI_DEBUG_ASSERT(NULL != mem_bkend);
+		if (MALI_MEM_DMA_BUF != descriptor->type) {
+			/* Not a DMA-buf */
+			MALI_DEBUG_ASSERT(NULL ==
+					  mali_pp_job_get_dma_buf(job, i));
+			continue;
+		}
 
-		mem = mem_bkend->dma_buf.attachment;
+		mem = descriptor->dma_buf.attachment;
 
 		MALI_DEBUG_ASSERT_POINTER(mem);
 		MALI_DEBUG_ASSERT(mem->session == mali_pp_job_get_session(job));
 
-		err = mali_dma_buf_map(mem_bkend);
+		err = mali_dma_buf_map(mem, mem->session, descriptor->mali_mapping.addr, descriptor->flags);
 		if (0 != err) {
-			MALI_DEBUG_PRINT_ERROR(("Mali DMA-buf: Failed to map dma-buf for mali address %x\n", mali_addr));
+			MALI_DEBUG_PRINT_ERROR(("Mali DMA-buf: Failed to map dma-buf for cookie %d at mali address %x\b",
+						cookie, descriptor->mali_mapping.addr));
 			ret = -EFAULT;
+			MALI_DEBUG_ASSERT(NULL ==
+					  mali_pp_job_get_dma_buf(job, i));
 			continue;
 		}
+
+		/* Add mem to list of DMA-bufs mapped for this job */
+		mali_pp_job_set_dma_buf(job, i, mem);
 	}
+
+	mali_session_memory_unlock(session);
+
 	return ret;
 }
 
 void mali_dma_buf_unmap_job(struct mali_pp_job *job)
 {
-	struct mali_dma_buf_attachment *mem;
-	int i;
-	u32 num_memory_cookies;
-	struct mali_session_data *session;
-	struct mali_vma_node *mali_vma_node = NULL;
-	mali_mem_allocation *mali_alloc = NULL;
-	mali_mem_backend *mem_bkend = NULL;
-
-	MALI_DEBUG_ASSERT_POINTER(job);
+	u32 i;
+	u32 num_dma_bufs = mali_pp_job_num_dma_bufs(job);
 
-	num_memory_cookies = mali_pp_job_num_memory_cookies(job);
-
-	session = mali_pp_job_get_session(job);
-
-	MALI_DEBUG_ASSERT_POINTER(session);
+	for (i = 0; i < num_dma_bufs; i++) {
+		struct mali_dma_buf_attachment *mem;
 
-	for (i = 0; i < num_memory_cookies; i++) {
-		u32 mali_addr  = mali_pp_job_get_memory_cookie(job, i);
-		mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, mali_addr, 0);
-		MALI_DEBUG_ASSERT(NULL != mali_vma_node);
-		mali_alloc = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
-		MALI_DEBUG_ASSERT(NULL != mali_alloc);
-		if (MALI_MEM_DMA_BUF != mali_alloc->type) {
-			continue;
+		mem = mali_pp_job_get_dma_buf(job, i);
+		if (NULL != mem) {
+			mali_dma_buf_unmap(mem);
+			mali_pp_job_set_dma_buf(job, i, NULL);
 		}
-
-		/* Get backend memory & Map on CPU */
-		mutex_lock(&mali_idr_mutex);
-		mem_bkend = idr_find(&mali_backend_idr, mali_alloc->backend_handle);
-		mutex_unlock(&mali_idr_mutex);
-		MALI_DEBUG_ASSERT(NULL != mem_bkend);
-
-		mem = mem_bkend->dma_buf.attachment;
-
-		MALI_DEBUG_ASSERT_POINTER(mem);
-		MALI_DEBUG_ASSERT(mem->session == mali_pp_job_get_session(job));
-		mali_dma_buf_unmap(mem_bkend->mali_allocation, mem);
 	}
 }
 #endif /* !CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH */
 
-int mali_dma_buf_get_size(struct mali_session_data *session, _mali_uk_dma_buf_get_size_s __user *user_arg)
+int mali_attach_dma_buf(struct mali_session_data *session, _mali_uk_attach_dma_buf_s __user *user_arg)
 {
-	_mali_uk_dma_buf_get_size_s args;
-	int fd;
 	struct dma_buf *buf;
+	struct mali_dma_buf_attachment *mem;
+	_mali_uk_attach_dma_buf_s args;
+	mali_mem_allocation *descriptor;
+	int md;
+	int fd;
 
-	/* get call arguments from user space. copy_from_user returns how many bytes which where NOT copied */
-	if (0 != copy_from_user(&args, (void __user *)user_arg, sizeof(_mali_uk_dma_buf_get_size_s))) {
+	/* Get call arguments from user space. copy_from_user returns how many bytes which where NOT copied */
+	if (0 != copy_from_user(&args, (void __user *)user_arg, sizeof(_mali_uk_attach_dma_buf_s))) {
 		return -EFAULT;
 	}
 
-	/* Do DMA-BUF stuff */
+	if (args.mali_address & ~PAGE_MASK) {
+		MALI_DEBUG_PRINT_ERROR(("Requested address (0x%08x) is not page aligned\n", args.mali_address));
+		return -EINVAL;
+	}
+
+	if (args.mali_address >= args.mali_address + args.size) {
+		MALI_DEBUG_PRINT_ERROR(("Requested address and size (0x%08x + 0x%08x) is too big\n", args.mali_address, args.size));
+		return -EINVAL;
+	}
+
 	fd = args.mem_fd;
 
 	buf = dma_buf_get(fd);
@@ -292,91 +287,169 @@
 		return PTR_RET(buf);
 	}
 
-	if (0 != put_user(buf->size, &user_arg->size)) {
+	/* Currently, mapping of the full buffer are supported. */
+	if (args.size != buf->size) {
+		MALI_DEBUG_PRINT_ERROR(("dma-buf size doesn't match mapping size.\n"));
 		dma_buf_put(buf);
-		return -EFAULT;
+		return -EINVAL;
 	}
 
-	dma_buf_put(buf);
+	mem = _mali_osk_calloc(1, sizeof(struct mali_dma_buf_attachment));
+	if (NULL == mem) {
+		MALI_DEBUG_PRINT_ERROR(("Failed to allocate dma-buf tracing struct\n"));
+		dma_buf_put(buf);
+		return -ENOMEM;
+	}
 
-	return 0;
-}
+	mem->buf = buf;
+	mem->session = session;
+	mem->map_ref = 0;
+	mutex_init(&mem->map_lock);
+	init_waitqueue_head(&mem->wait_queue);
+
+	mem->attachment = dma_buf_attach(mem->buf, &mali_platform_device->dev);
+	if (NULL == mem->attachment) {
+		MALI_DEBUG_PRINT_ERROR(("Failed to attach to dma-buf %d\n", fd));
+		dma_buf_put(mem->buf);
+		_mali_osk_free(mem);
+		return -EFAULT;
+	}
 
-_mali_osk_errcode_t mali_memory_bind_dma_buf(mali_mem_allocation *alloc,
-		mali_mem_backend *mem_backend,
-		int fd, u32 flags)
-{
-	struct dma_buf *buf;
-	struct mali_dma_buf_attachment *dma_mem;
-	struct  mali_session_data *session = alloc->session;
+	/* Set up Mali memory descriptor */
+	descriptor = mali_mem_descriptor_create(session, MALI_MEM_DMA_BUF);
+	if (NULL == descriptor) {
+		MALI_DEBUG_PRINT_ERROR(("Failed to allocate descriptor dma-buf %d\n", fd));
+		mali_dma_buf_release(mem);
+		return -ENOMEM;
+	}
+
+	descriptor->size = args.size;
+	descriptor->mali_mapping.addr = args.mali_address;
+
+	descriptor->dma_buf.attachment = mem;
+
+	descriptor->flags |= MALI_MEM_FLAG_DONT_CPU_MAP;
+	if (args.flags & _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE) {
+		descriptor->flags = MALI_MEM_FLAG_MALI_GUARD_PAGE;
+	}
 
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	MALI_DEBUG_ASSERT_POINTER(alloc);
+	mali_session_memory_lock(session);
 
-	/* get dma buffer */
-	buf = dma_buf_get(fd);
-	if (IS_ERR_OR_NULL(buf)) {
-		return _MALI_OSK_ERR_FAULT;
+	/* Map dma-buf into this session's page tables */
+	if (_MALI_OSK_ERR_OK != mali_mem_mali_map_prepare(descriptor)) {
+		mali_session_memory_unlock(session);
+		MALI_DEBUG_PRINT_ERROR(("Failed to map dma-buf on Mali\n"));
+		mali_mem_descriptor_destroy(descriptor);
+		mali_dma_buf_release(mem);
+		return -ENOMEM;
 	}
 
-	/* Currently, mapping of the full buffer are supported. */
-	if (alloc->psize != buf->size) {
-		goto failed_alloc_mem;
+#if defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
+	/* Map memory into session's Mali virtual address space. */
+
+	if (0 != mali_dma_buf_map(mem, session, descriptor->mali_mapping.addr, descriptor->flags)) {
+		mali_mem_mali_map_free(descriptor);
+		mali_session_memory_unlock(session);
+
+		MALI_DEBUG_PRINT_ERROR(("Failed to map dma-buf %d into Mali address space\n", fd));
+		mali_mem_descriptor_destroy(descriptor);
+		mali_dma_buf_release(mem);
+		return -ENOMEM;
 	}
 
-	dma_mem = _mali_osk_calloc(1, sizeof(struct mali_dma_buf_attachment));
-	if (NULL == dma_mem) {
-		goto failed_alloc_mem;
+#endif
+
+	mali_session_memory_unlock(session);
+
+	/* Get descriptor mapping for memory. */
+	if (_MALI_OSK_ERR_OK != mali_descriptor_mapping_allocate_mapping(session->descriptor_mapping, descriptor, &md)) {
+		mali_session_memory_lock(session);
+		mali_mem_mali_map_free(descriptor);
+		mali_session_memory_unlock(session);
+
+		MALI_DEBUG_PRINT_ERROR(("Failed to create descriptor mapping for dma-buf %d\n", fd));
+		mali_mem_descriptor_destroy(descriptor);
+		mali_dma_buf_release(mem);
+		return -EFAULT;
 	}
 
-	dma_mem->buf = buf;
-	dma_mem->session = session;
-	dma_mem->map_ref = 0;
-	init_waitqueue_head(&dma_mem->wait_queue);
+	/* Return stuff to user space */
+	if (0 != put_user(md, &user_arg->cookie)) {
+		mali_session_memory_lock(session);
+		mali_mem_mali_map_free(descriptor);
+		mali_session_memory_unlock(session);
 
-	dma_mem->attachment = dma_buf_attach(dma_mem->buf, &mali_platform_device->dev);
-	if (NULL == dma_mem->attachment) {
-		goto failed_dma_attach;
+		MALI_DEBUG_PRINT_ERROR(("Failed to return descriptor to user space for dma-buf %d\n", fd));
+		mali_descriptor_mapping_free(session->descriptor_mapping, md);
+		mali_dma_buf_release(mem);
+		return -EFAULT;
 	}
 
-	mem_backend->dma_buf.attachment = dma_mem;
+	return 0;
+}
+
+int mali_release_dma_buf(struct mali_session_data *session, _mali_uk_release_dma_buf_s __user *user_arg)
+{
+	int ret = 0;
+	_mali_uk_release_dma_buf_s args;
+	mali_mem_allocation *descriptor;
 
-	alloc->flags |= MALI_MEM_FLAG_DONT_CPU_MAP;
-	if (flags & _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE) {
-		alloc->flags |= MALI_MEM_FLAG_MALI_GUARD_PAGE;
+	/* get call arguments from user space. copy_from_user returns how many bytes which where NOT copied */
+	if (0 != copy_from_user(&args, (void __user *)user_arg, sizeof(_mali_uk_release_dma_buf_s))) {
+		return -EFAULT;
 	}
 
+	MALI_DEBUG_PRINT(3, ("Mali DMA-buf: release descriptor cookie %ld\n", args.cookie));
 
-#if defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
-	/* Map memory into session's Mali virtual address space. */
-	if (0 != mali_dma_buf_map(mem_backend)) {
-		goto Failed_dma_map;
+	mali_session_memory_lock(session);
+
+	descriptor = mali_descriptor_mapping_free(session->descriptor_mapping, (u32)args.cookie);
+
+	if (NULL != descriptor) {
+		MALI_DEBUG_PRINT(3, ("Mali DMA-buf: Releasing dma-buf at mali address %x\n", descriptor->mali_mapping.addr));
+
+		mali_mem_mali_map_free(descriptor);
+
+		mali_dma_buf_release(descriptor->dma_buf.attachment);
+
+		mali_mem_descriptor_destroy(descriptor);
+	} else {
+		MALI_DEBUG_PRINT_ERROR(("Invalid memory descriptor %ld used to release dma-buf\n", args.cookie));
+		ret = -EINVAL;
 	}
-#endif
 
-	return _MALI_OSK_ERR_OK;
+	mali_session_memory_unlock(session);
 
-#if defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
-Failed_dma_map:
-	mali_dma_buf_unmap(alloc, dma_mem);
-#endif
-	/* Wait for buffer to become unmapped */
-	wait_event(dma_mem->wait_queue, !dma_mem->is_mapped);
-	MALI_DEBUG_ASSERT(!dma_mem->is_mapped);
-	dma_buf_detach(dma_mem->buf, dma_mem->attachment);
-failed_dma_attach:
-	_mali_osk_free(dma_mem);
-failed_alloc_mem:
-	dma_buf_put(buf);
-	return _MALI_OSK_ERR_FAULT;
+	/* Return the error that _mali_ukk_map_external_ump_mem produced */
+	return ret;
 }
 
-
-void mali_memory_unbind_dma_buf(mali_mem_backend *mem_backend)
+int mali_dma_buf_get_size(struct mali_session_data *session, _mali_uk_dma_buf_get_size_s __user *user_arg)
 {
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	mali_mem_dma_buf_release(mem_backend);
-}
+	_mali_uk_dma_buf_get_size_s args;
+	int fd;
+	struct dma_buf *buf;
+
+	/* get call arguments from user space. copy_from_user returns how many bytes which where NOT copied */
+	if (0 != copy_from_user(&args, (void __user *)user_arg, sizeof(_mali_uk_dma_buf_get_size_s))) {
+		return -EFAULT;
+	}
+
+	/* Do DMA-BUF stuff */
+	fd = args.mem_fd;
+
+	buf = dma_buf_get(fd);
+	if (IS_ERR_OR_NULL(buf)) {
+		MALI_DEBUG_PRINT_ERROR(("Failed to get dma-buf from fd: %d\n", fd));
+		return PTR_RET(buf);
+	}
+
+	if (0 != put_user(buf->size, &user_arg->size)) {
+		dma_buf_put(buf);
+		return -EFAULT;
+	}
 
+	dma_buf_put(buf);
 
+	return 0;
+}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_dma_buf.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_dma_buf.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_dma_buf.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_dma_buf.h	2016-04-04 16:25:32.548527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -22,26 +22,12 @@
 struct mali_pp_job;
 
 struct mali_dma_buf_attachment;
-struct mali_dma_buf_attachment {
-	struct dma_buf *buf;
-	struct dma_buf_attachment *attachment;
-	struct sg_table *sgt;
-	struct mali_session_data *session;
-	int map_ref;
-	struct mutex map_lock;
-	mali_bool is_mapped;
-	wait_queue_head_t wait_queue;
-};
 
+int mali_attach_dma_buf(struct mali_session_data *session, _mali_uk_attach_dma_buf_s __user *arg);
+int mali_release_dma_buf(struct mali_session_data *session, _mali_uk_release_dma_buf_s __user *arg);
 int mali_dma_buf_get_size(struct mali_session_data *session, _mali_uk_dma_buf_get_size_s __user *arg);
 
-void mali_mem_dma_buf_release(mali_mem_backend *mem_backend);
-
-_mali_osk_errcode_t mali_memory_bind_dma_buf(mali_mem_allocation *alloc,
-		mali_mem_backend *mem_backend,
-		int fd, u32 flags);
-
-void mali_memory_unbind_dma_buf(mali_mem_backend *mem_backend);
+void mali_mem_dma_buf_release(mali_mem_allocation *descriptor);
 
 #if !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
 int mali_dma_buf_map_job(struct mali_pp_job *job);
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_external.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_external.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_external.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_external.c	2016-04-04 16:25:32.558527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -12,87 +12,114 @@
 #include "mali_osk.h"
 #include "mali_ukk.h"
 #include "mali_memory.h"
+#include "mali_kernel_descriptor_mapping.h"
 #include "mali_mem_validation.h"
 #include "mali_uk_types.h"
 
-void mali_mem_external_release(mali_mem_backend *mem_backend)
+void mali_mem_external_release(mali_mem_allocation *descriptor)
 {
-	mali_mem_allocation *alloc;
-	struct mali_session_data *session;
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	alloc = mem_backend->mali_allocation;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-	MALI_DEBUG_ASSERT(MALI_MEM_EXTERNAL == mem_backend->type);
-
-	session = alloc->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-	mali_session_memory_lock(session);
-	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
-			       alloc->flags);
-	session->mali_mem_array[mem_backend->type] -= mem_backend->size;
-	mali_session_memory_unlock(session);
+	MALI_DEBUG_ASSERT(MALI_MEM_EXTERNAL == descriptor->type);
+
+	mali_mem_mali_map_free(descriptor);
 }
 
-_mali_osk_errcode_t mali_memory_bind_ext_mem(mali_mem_allocation *alloc,
-		mali_mem_backend *mem_backend,
-		u32 phys_addr,
-		u32 flag)
+_mali_osk_errcode_t _mali_ukk_map_external_mem(_mali_uk_map_external_mem_s *args)
 {
 	struct mali_session_data *session;
+	mali_mem_allocation *descriptor;
+	int md;
 	_mali_osk_errcode_t err;
-	u32 virt, phys, size;
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-	size = alloc->psize;
-	session = (struct mali_session_data *)(uintptr_t)alloc->session;
+
+	MALI_DEBUG_ASSERT_POINTER(args);
+
+	session = (struct mali_session_data *)(uintptr_t)args->ctx;
 	MALI_CHECK_NON_NULL(session, _MALI_OSK_ERR_INVALID_ARGS);
 
 	/* check arguments */
 	/* NULL might be a valid Mali address */
-	if (!size) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
+	if (! args->size) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
 
 	/* size must be a multiple of the system page size */
-	if (size % _MALI_OSK_MALI_PAGE_SIZE) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
+	if (args->size % _MALI_OSK_MALI_PAGE_SIZE) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
+
+	MALI_DEBUG_PRINT(3,
+			 ("Requested to map physical memory 0x%x-0x%x into virtual memory 0x%x\n",
+			  args->phys_addr, (args->phys_addr + args->size - 1),
+			  args->mali_address));
 
 	/* Validate the mali physical range */
-	if (_MALI_OSK_ERR_OK != mali_mem_validation_check(phys_addr, size)) {
+	if (_MALI_OSK_ERR_OK != mali_mem_validation_check(args->phys_addr, args->size)) {
 		return _MALI_OSK_ERR_FAULT;
 	}
 
-	if (flag & _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE) {
-		alloc->flags |= MALI_MEM_FLAG_MALI_GUARD_PAGE;
-	}
-
-	mali_session_memory_lock(session);
+	descriptor = mali_mem_descriptor_create(session, MALI_MEM_EXTERNAL);
+	if (NULL == descriptor) MALI_ERROR(_MALI_OSK_ERR_NOMEM);
 
-	virt = alloc->mali_vma_node.vm_node.start;
-	phys = phys_addr;
+	descriptor->mali_mapping.addr = args->mali_address;
+	descriptor->size = args->size;
 
-	err = mali_mem_mali_map_prepare(alloc);
-	if (_MALI_OSK_ERR_OK != err) {
-		mali_session_memory_unlock(session);
-		return _MALI_OSK_ERR_NOMEM;
+	if (args->flags & _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE) {
+		descriptor->flags = MALI_MEM_FLAG_MALI_GUARD_PAGE;
 	}
 
-	mali_mmu_pagedir_update(session->page_directory, virt, phys, size, MALI_MMU_FLAGS_DEFAULT);
+	_mali_osk_mutex_wait(session->memory_lock);
+	{
+		u32 virt = descriptor->mali_mapping.addr;
+		u32 phys = args->phys_addr;
+		u32 size = args->size;
+
+		err = mali_mem_mali_map_prepare(descriptor);
+		if (_MALI_OSK_ERR_OK != err) {
+			_mali_osk_mutex_signal(session->memory_lock);
+			mali_mem_descriptor_destroy(descriptor);
+			return _MALI_OSK_ERR_NOMEM;
+		}
+
+		mali_mmu_pagedir_update(session->page_directory, virt, phys, size, MALI_MMU_FLAGS_DEFAULT);
+
+		if (descriptor->flags & MALI_MEM_FLAG_MALI_GUARD_PAGE) {
+			mali_mmu_pagedir_update(session->page_directory, virt + size, phys, _MALI_OSK_MALI_PAGE_SIZE, MALI_MMU_FLAGS_DEFAULT);
+		}
+	}
+	_mali_osk_mutex_signal(session->memory_lock);
 
-	if (alloc->flags & MALI_MEM_FLAG_MALI_GUARD_PAGE) {
-		mali_mmu_pagedir_update(session->page_directory, virt + size, phys, _MALI_OSK_MALI_PAGE_SIZE, MALI_MMU_FLAGS_DEFAULT);
+	if (_MALI_OSK_ERR_OK != mali_descriptor_mapping_allocate_mapping(session->descriptor_mapping, descriptor, &md)) {
+		_mali_osk_mutex_wait(session->memory_lock);
+		mali_mem_external_release(descriptor);
+		_mali_osk_mutex_signal(session->memory_lock);
+		mali_mem_descriptor_destroy(descriptor);
+		MALI_ERROR(_MALI_OSK_ERR_FAULT);
 	}
-	MALI_DEBUG_PRINT(3,
-			 ("Requested to map physical memory 0x%x-0x%x into virtual memory 0x%x\n",
-			  phys_addr, (phys_addr + size - 1),
-			  virt));
-	session->mali_mem_array[mem_backend->type] += mem_backend->size;
-	mali_session_memory_unlock(session);
+
+	args->cookie = md;
 
 	MALI_SUCCESS;
 }
 
-
-void mali_memory_unbind_ext_mem(mali_mem_backend *mem_backend)
+_mali_osk_errcode_t _mali_ukk_unmap_external_mem(_mali_uk_unmap_external_mem_s *args)
 {
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	mali_mem_external_release(mem_backend);
-}
+	mali_mem_allocation *descriptor;
+	void *old_value;
+	struct mali_session_data *session;
+
+	MALI_DEBUG_ASSERT_POINTER(args);
 
+	session = (struct mali_session_data *)(uintptr_t)args->ctx;
+	MALI_CHECK_NON_NULL(session, _MALI_OSK_ERR_INVALID_ARGS);
+
+	if (_MALI_OSK_ERR_OK != mali_descriptor_mapping_get(session->descriptor_mapping, args->cookie, (void **)&descriptor)) {
+		MALI_DEBUG_PRINT(1, ("Invalid memory descriptor %d used to unmap external memory\n", args->cookie));
+		MALI_ERROR(_MALI_OSK_ERR_FAULT);
+	}
+
+	old_value = mali_descriptor_mapping_free(session->descriptor_mapping, args->cookie);
+
+	if (NULL != old_value) {
+		_mali_osk_mutex_wait(session->memory_lock);
+		mali_mem_external_release(descriptor);
+		_mali_osk_mutex_signal(session->memory_lock);
+		mali_mem_descriptor_destroy(descriptor);
+	}
+
+	MALI_SUCCESS;
+}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory.h	2016-04-04 16:25:32.498527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -58,6 +58,22 @@
  */
 int mali_mmap(struct file *filp, struct vm_area_struct *vma);
 
+/** @brief Allocate and initialize a Mali memory descriptor
+ *
+ * @param session Pointer to the session allocating the descriptor
+ * @param type Type of memory the descriptor will represent
+ */
+mali_mem_allocation *mali_mem_descriptor_create(struct mali_session_data *session, mali_mem_type type);
+
+/** @brief Destroy a Mali memory descriptor
+ *
+ * This function will only free the descriptor itself, and not the memory it
+ * represents.
+ *
+ * @param descriptor Pointer to the descriptor to destroy
+ */
+void mali_mem_descriptor_destroy(mali_mem_allocation *descriptor);
+
 /** @brief Start a new memory session
  *
  * Called when a process opens the Mali device node.
@@ -96,8 +112,7 @@
  *
  * @param descriptor Pointer to the memory descriptor to unmap
  */
-void mali_mem_mali_map_free(struct mali_session_data *session, u32 size, mali_address_t vaddr, u32 flags);
-
+void mali_mem_mali_map_free(mali_mem_allocation *descriptor);
 
 /** @brief Parse resource and prepare the OS memory allocator
  *
@@ -115,4 +130,7 @@
 _mali_osk_errcode_t mali_memory_core_resource_dedicated_memory(u32 start, u32 size);
 
 
+void mali_mem_ump_release(mali_mem_allocation *descriptor);
+void mali_mem_external_release(mali_mem_allocation *descriptor);
+
 #endif /* __MALI_MEMORY_H__ */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_os_alloc.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_os_alloc.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_os_alloc.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_os_alloc.c	2016-04-04 16:25:32.568527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -46,8 +46,6 @@
 #endif
 #endif
 static void mali_mem_os_trim_pool(struct work_struct *work);
-static void mali_mem_os_free_page(struct mali_page_node *m_page);
-
 
 static struct mali_mem_os_allocator {
 	spinlock_t pool_lock;
@@ -84,19 +82,21 @@
 #endif
 };
 
-void mali_mem_os_free(mali_mem_os_mem *os_mem)
+static void mali_mem_os_free(mali_mem_allocation *descriptor)
 {
 	LIST_HEAD(pages);
 
-	atomic_sub(os_mem->count, &mali_mem_os_allocator.allocated_pages);
+	MALI_DEBUG_ASSERT(MALI_MEM_OS == descriptor->type);
+
+	atomic_sub(descriptor->os_mem.count, &mali_mem_os_allocator.allocated_pages);
 
 	/* Put pages on pool. */
-	list_cut_position(&pages, &os_mem->pages, os_mem->pages.prev);
+	list_cut_position(&pages, &descriptor->os_mem.pages, descriptor->os_mem.pages.prev);
 
 	spin_lock(&mali_mem_os_allocator.pool_lock);
 
 	list_splice(&pages, &mali_mem_os_allocator.pool_pages);
-	mali_mem_os_allocator.pool_count += os_mem->count;
+	mali_mem_os_allocator.pool_count += descriptor->os_mem.count;
 
 	spin_unlock(&mali_mem_os_allocator.pool_lock);
 
@@ -106,36 +106,19 @@
 	}
 }
 
-/**
-* free memory without put it into page pool
-
-void mali_mem_os_free_not_pooled(mali_mem_os_mem *os_mem)
-{
-
-}
-*/
-
-int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size)
+static int mali_mem_os_alloc_pages(mali_mem_allocation *descriptor, u32 size)
 {
-	struct page *new_page;
-	LIST_HEAD(pages_list);
+	struct page *new_page, *tmp;
+	LIST_HEAD(pages);
 	size_t page_count = PAGE_ALIGN(size) / _MALI_OSK_MALI_PAGE_SIZE;
 	size_t remaining = page_count;
-	struct mali_page_node *m_page, *m_tmp;
 	u32 i;
 
-	MALI_DEBUG_ASSERT_POINTER(os_mem);
+	MALI_DEBUG_ASSERT_POINTER(descriptor);
+	MALI_DEBUG_ASSERT(MALI_MEM_OS == descriptor->type);
 
-	if (atomic_read(&mali_mem_os_allocator.allocated_pages) * _MALI_OSK_MALI_PAGE_SIZE + size > mali_mem_os_allocator.allocation_limit) {
-		MALI_DEBUG_PRINT(2, ("Mali Mem: Unable to allocate %u bytes. Currently allocated: %lu, max limit %lu\n",
-				     size,
-				     atomic_read(&mali_mem_os_allocator.allocated_pages) * _MALI_OSK_MALI_PAGE_SIZE,
-				     mali_mem_os_allocator.allocation_limit));
-		return -ENOMEM;
-	}
-
-	INIT_LIST_HEAD(&os_mem->pages);
-	os_mem->count = page_count;
+	INIT_LIST_HEAD(&descriptor->os_mem.pages);
+	descriptor->os_mem.count = page_count;
 
 	/* Grab pages from pool. */
 	{
@@ -144,7 +127,7 @@
 		pool_pages = min(remaining, mali_mem_os_allocator.pool_count);
 		for (i = pool_pages; i > 0; i--) {
 			BUG_ON(list_empty(&mali_mem_os_allocator.pool_pages));
-			list_move(mali_mem_os_allocator.pool_pages.next, &pages_list);
+			list_move(mali_mem_os_allocator.pool_pages.next, &pages);
 		}
 		mali_mem_os_allocator.pool_count -= pool_pages;
 		remaining -= pool_pages;
@@ -153,23 +136,22 @@
 
 	/* Process pages from pool. */
 	i = 0;
-	list_for_each_entry_safe(m_page, m_tmp, &pages_list, list) {
-		BUG_ON(NULL == m_page);
+	list_for_each_entry_safe(new_page, tmp, &pages, lru) {
+		BUG_ON(NULL == new_page);
 
-		list_move_tail(&m_page->list, &os_mem->pages);
+		list_move_tail(&new_page->lru, &descriptor->os_mem.pages);
 	}
 
 	/* Allocate new pages, if needed. */
 	for (i = 0; i < remaining; i++) {
 		dma_addr_t dma_addr;
-		struct mali_page_node *new_page_node = NULL;
-		gfp_t flags = __GFP_ZERO | __GFP_NORETRY | __GFP_NOWARN | __GFP_COLD;
+		gfp_t flags = __GFP_ZERO | __GFP_REPEAT | __GFP_NOWARN | __GFP_COLD;
 		int err;
 
 #if defined(CONFIG_ARM) && !defined(CONFIG_ARM_LPAE)
 		flags |= GFP_HIGHUSER;
 #else
-		/* After 3.15.0 kernel use ZONE_DMA replace ZONE_DMA32 */
+	/* After 3.15.0 kernel use ZONE_DMA replace ZONE_DMA32 */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
 		flags |= GFP_DMA32;
 #else
@@ -181,9 +163,9 @@
 
 		if (unlikely(NULL == new_page)) {
 			/* Calculate the number of pages actually allocated, and free them. */
-			os_mem->count = (page_count - remaining) + i;
-			atomic_add(os_mem->count, &mali_mem_os_allocator.allocated_pages);
-			mali_mem_os_free(os_mem);
+			descriptor->os_mem.count = (page_count - remaining) + i;
+			atomic_add(descriptor->os_mem.count, &mali_mem_os_allocator.allocated_pages);
+			mali_mem_os_free(descriptor);
 			return -ENOMEM;
 		}
 
@@ -196,9 +178,9 @@
 			MALI_DEBUG_PRINT_ERROR(("OS Mem: Failed to DMA map page %p: %u",
 						new_page, err));
 			__free_page(new_page);
-			os_mem->count = (page_count - remaining) + i;
-			atomic_add(os_mem->count, &mali_mem_os_allocator.allocated_pages);
-			mali_mem_os_free(os_mem);
+			descriptor->os_mem.count = (page_count - remaining) + i;
+			atomic_add(descriptor->os_mem.count, &mali_mem_os_allocator.allocated_pages);
+			mali_mem_os_free(descriptor);
 			return -EFAULT;
 		}
 
@@ -206,22 +188,7 @@
 		SetPagePrivate(new_page);
 		set_page_private(new_page, dma_addr);
 
-		new_page_node = kmalloc(sizeof(mali_page_node), GFP_KERNEL);
-		if (unlikely(NULL == new_page_node)) {
-			MALI_PRINT_ERROR(("OS Mem: Can't allocate mali_page node! \n"));
-			dma_unmap_page(&mali_platform_device->dev, page_private(new_page),
-				       _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
-			ClearPagePrivate(new_page);
-			__free_page(new_page);
-			os_mem->count = (page_count - remaining) + i;
-			atomic_add(os_mem->count, &mali_mem_os_allocator.allocated_pages);
-			mali_mem_os_free(os_mem);
-			return -EFAULT;
-		}
-		new_page_node->page = new_page;
-		INIT_LIST_HEAD(&new_page_node->list);
-
-		list_add_tail(&new_page_node->list, &os_mem->pages);
+		list_add_tail(&new_page->lru, &descriptor->os_mem.pages);
 	}
 
 	atomic_add(page_count, &mali_mem_os_allocator.allocated_pages);
@@ -234,24 +201,23 @@
 	return 0;
 }
 
-
-void mali_mem_os_mali_map(mali_mem_backend *mem_bkend, u32 vaddr, u32 props)
+static int mali_mem_os_mali_map(mali_mem_allocation *descriptor, struct mali_session_data *session)
 {
-	struct mali_session_data *session;
-	struct mali_page_directory *pagedir;
-	struct mali_page_node *m_page;
-	u32 virt = vaddr;
-	u32 prop = props;
-
-	MALI_DEBUG_ASSERT_POINTER(mem_bkend);
-	MALI_DEBUG_ASSERT_POINTER(mem_bkend->mali_allocation);
-
-	session = mem_bkend->mali_allocation->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-	pagedir = session->page_directory;
+	struct mali_page_directory *pagedir = session->page_directory;
+	struct page *page;
+	_mali_osk_errcode_t err;
+	u32 virt = descriptor->mali_mapping.addr;
+	u32 prop = descriptor->mali_mapping.properties;
+
+	MALI_DEBUG_ASSERT(MALI_MEM_OS == descriptor->type);
+
+	err = mali_mem_mali_map_prepare(descriptor);
+	if (_MALI_OSK_ERR_OK != err) {
+		return -ENOMEM;
+	}
 
-	list_for_each_entry(m_page, &mem_bkend->os_mem.pages, list) {
-		dma_addr_t phys = page_private(m_page->page);
+	list_for_each_entry(page, &descriptor->os_mem.pages, lru) {
+		dma_addr_t phys = page_private(page);
 
 #if defined(CONFIG_ARCH_DMA_ADDR_T_64BIT)
 		/* Verify that the "physical" address is 32-bit and
@@ -263,36 +229,26 @@
 		mali_mmu_pagedir_update(pagedir, virt, (mali_dma_addr)phys, MALI_MMU_PAGE_SIZE, prop);
 		virt += MALI_MMU_PAGE_SIZE;
 	}
-}
 
+	return 0;
+}
 
-static void mali_mem_os_mali_unmap(mali_mem_allocation *alloc)
+static void mali_mem_os_mali_unmap(struct mali_session_data *session, mali_mem_allocation *descriptor)
 {
-	struct mali_session_data *session;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-	session = alloc->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	mali_session_memory_lock(session);
-	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
-			       alloc->flags);
-	session->mali_mem_array[alloc->type] -= alloc->psize;
-	mali_session_memory_unlock(session);
+	mali_mem_mali_map_free(descriptor);
 }
 
-int mali_mem_os_cpu_map(mali_mem_os_mem *os_mem, struct vm_area_struct *vma)
+static int mali_mem_os_cpu_map(mali_mem_allocation *descriptor, struct vm_area_struct *vma)
 {
-	struct mali_page_node *m_page;
 	struct page *page;
 	int ret;
 	unsigned long addr = vma->vm_start;
 
-	list_for_each_entry(m_page, &os_mem->pages, list) {
+	list_for_each_entry(page, &descriptor->os_mem.pages, lru) {
 		/* We should use vm_insert_page, but it does a dcache
 		 * flush which makes it way slower than remap_pfn_range or vm_insert_pfn.
 		ret = vm_insert_page(vma, addr, page);
 		*/
-		page = m_page->page;
 		ret = vm_insert_pfn(vma, addr, page_to_pfn(page));
 
 		if (unlikely(0 != ret)) {
@@ -304,21 +260,70 @@
 	return 0;
 }
 
-void mali_mem_os_release(mali_mem_backend *mem_bkend)
+mali_mem_allocation *mali_mem_os_alloc(u32 mali_addr, u32 size, struct vm_area_struct *vma, struct mali_session_data *session)
 {
+	mali_mem_allocation *descriptor;
+	int err;
 
-	mali_mem_allocation *alloc;
-	MALI_DEBUG_ASSERT_POINTER(mem_bkend);
-	MALI_DEBUG_ASSERT(MALI_MEM_OS == mem_bkend->type);
+	if (atomic_read(&mali_mem_os_allocator.allocated_pages) * _MALI_OSK_MALI_PAGE_SIZE + size > mali_mem_os_allocator.allocation_limit) {
+		MALI_DEBUG_PRINT(2, ("Mali Mem: Unable to allocate %u bytes. Currently allocated: %lu, max limit %lu\n",
+				     size,
+				     atomic_read(&mali_mem_os_allocator.allocated_pages) * _MALI_OSK_MALI_PAGE_SIZE,
+				     mali_mem_os_allocator.allocation_limit));
+		return NULL;
+	}
+
+	descriptor = mali_mem_descriptor_create(session, MALI_MEM_OS);
+	if (NULL == descriptor) return NULL;
 
-	alloc = mem_bkend->mali_allocation;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
+	descriptor->mali_mapping.addr = mali_addr;
+	descriptor->size = size;
+	descriptor->cpu_mapping.addr = (void __user *)vma->vm_start;
+	descriptor->cpu_mapping.ref = 1;
+
+	if (VM_SHARED == (VM_SHARED & vma->vm_flags)) {
+		descriptor->mali_mapping.properties = MALI_MMU_FLAGS_DEFAULT;
+	} else {
+		/* Cached Mali memory mapping */
+		descriptor->mali_mapping.properties = MALI_MMU_FLAGS_FORCE_GP_READ_ALLOCATE;
+		vma->vm_flags |= VM_SHARED;
+	}
+
+	err = mali_mem_os_alloc_pages(descriptor, size); /* Allocate pages */
+	if (0 != err) goto alloc_failed;
+
+	/* Take session memory lock */
+	_mali_osk_mutex_wait(session->memory_lock);
+
+	err = mali_mem_os_mali_map(descriptor, session); /* Map on Mali */
+	if (0 != err) goto mali_map_failed;
+
+	err = mali_mem_os_cpu_map(descriptor, vma); /* Map on CPU */
+	if (0 != err) goto cpu_map_failed;
+
+	_mali_osk_mutex_signal(session->memory_lock);
+	return descriptor;
+
+cpu_map_failed:
+	mali_mem_os_mali_unmap(session, descriptor);
+mali_map_failed:
+	_mali_osk_mutex_signal(session->memory_lock);
+	mali_mem_os_free(descriptor);
+alloc_failed:
+	mali_mem_descriptor_destroy(descriptor);
+	MALI_DEBUG_PRINT(2, ("OS allocator: Failed to allocate memory (%d)\n", err));
+	return NULL;
+}
+
+void mali_mem_os_release(mali_mem_allocation *descriptor)
+{
+	struct mali_session_data *session = descriptor->session;
 
 	/* Unmap the memory from the mali virtual address space. */
-	mali_mem_os_mali_unmap(alloc);
+	mali_mem_os_mali_unmap(session, descriptor);
 
 	/* Free pages */
-	mali_mem_os_free(&mem_bkend->os_mem);
+	mali_mem_os_free(descriptor);
 }
 
 
@@ -401,9 +406,8 @@
 	}
 }
 
-static void mali_mem_os_free_page(struct mali_page_node *m_page)
+static void mali_mem_os_free_page(struct page *page)
 {
-	struct page *page = m_page->page;
 	BUG_ON(page_count(page) != 1);
 
 	dma_unmap_page(&mali_platform_device->dev, page_private(page),
@@ -412,7 +416,6 @@
 	ClearPagePrivate(page);
 
 	__free_page(page);
-	kfree(m_page);
 }
 
 /* The maximum number of page table pool pages to free in one go. */
@@ -495,7 +498,7 @@
 #endif /* Linux < 3.12.0 */
 #endif /* Linux < 3.0.0 */
 {
-	struct mali_page_node *m_page, *m_tmp;
+	struct page *page, *tmp;
 	unsigned long flags;
 	struct list_head *le, pages;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0)
@@ -529,8 +532,8 @@
 	list_cut_position(&pages, &mali_mem_os_allocator.pool_pages, le);
 	spin_unlock_irqrestore(&mali_mem_os_allocator.pool_lock, flags);
 
-	list_for_each_entry_safe(m_page, m_tmp, &pages, list) {
-		mali_mem_os_free_page(m_page);
+	list_for_each_entry_safe(page, tmp, &pages, lru) {
+		mali_mem_os_free_page(page);
 	}
 
 	if (MALI_OS_MEMORY_KERNEL_BUFFER_SIZE_IN_PAGES > mali_mem_os_allocator.pool_count) {
@@ -548,7 +551,7 @@
 
 static void mali_mem_os_trim_pool(struct work_struct *data)
 {
-	struct mali_page_node *m_page, *m_tmp;
+	struct page *page, *tmp;
 	struct list_head *le;
 	LIST_HEAD(pages);
 	size_t nr_to_free;
@@ -575,8 +578,8 @@
 	}
 	spin_unlock(&mali_mem_os_allocator.pool_lock);
 
-	list_for_each_entry_safe(m_page, m_tmp, &pages, list) {
-		mali_mem_os_free_page(m_page);
+	list_for_each_entry_safe(page, tmp, &pages, lru) {
+		mali_mem_os_free_page(page);
 	}
 
 	/* Release some pages from page table page pool */
@@ -606,7 +609,8 @@
 
 void mali_mem_os_term(void)
 {
-	struct mali_page_node *m_page, *m_tmp;
+	struct page *page, *tmp;
+
 	unregister_shrinker(&mali_mem_os_allocator.shrinker);
 	cancel_delayed_work_sync(&mali_mem_os_allocator.timed_shrinker);
 
@@ -616,8 +620,8 @@
 	}
 
 	spin_lock(&mali_mem_os_allocator.pool_lock);
-	list_for_each_entry_safe(m_page, m_tmp, &mali_mem_os_allocator.pool_pages, list) {
-		mali_mem_os_free_page(m_page);
+	list_for_each_entry_safe(page, tmp, &mali_mem_os_allocator.pool_pages, lru) {
+		mali_mem_os_free_page(page);
 
 		--mali_mem_os_allocator.pool_count;
 	}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_os_alloc.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_os_alloc.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_os_alloc.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_os_alloc.h	2016-04-04 16:25:32.588527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -12,15 +12,29 @@
 #define __MALI_MEMORY_OS_ALLOC_H__
 
 #include "mali_osk.h"
+#include "mali_session.h"
+
 #include "mali_memory_types.h"
 
+/* OS memory allocator */
+/** @brief Allocate memory from OS
+ *
+ * This function will create a descriptor, allocate pages and map these on the CPU and Mali.
+ *
+ * @param mali_addr Mali virtual address to use for Mali mapping
+ * @param size Size to allocate
+ * @param vma Pointer to vma for CPU mapping
+ * @param session Pointer to session doing the allocation
+ */
+mali_mem_allocation *mali_mem_os_alloc(u32 mali_addr, u32 size, struct vm_area_struct *vma, struct mali_session_data *session);
+
 /** @brief Release Mali OS memory
  *
  * The session memory_lock must be held when calling this function.
  *
- * @param mem_bkend Pointer to the mali_mem_backend to release
+ * @param descriptor Pointer to the descriptor to release
  */
-void mali_mem_os_release(mali_mem_backend *mem_bkend);
+void mali_mem_os_release(mali_mem_allocation *descriptor);
 
 _mali_osk_errcode_t mali_mem_os_get_table_page(mali_dma_addr *phys, mali_io_address *mapping);
 
@@ -30,10 +44,4 @@
 void mali_mem_os_term(void);
 u32 mali_mem_os_stat(void);
 
-int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size);
-void mali_mem_os_free(mali_mem_os_mem *os_mem);
-void mali_mem_os_mali_map(mali_mem_backend *mem_bkend, u32 vaddr, u32 props);
-int mali_mem_os_cpu_map(mali_mem_os_mem *os_mem, struct vm_area_struct *vma);
-
-
 #endif /* __MALI_MEMORY_OS_ALLOC_H__ */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_types.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_types.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_types.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_types.h	2016-04-04 16:37:51.898527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -12,7 +12,7 @@
 #define __MALI_MEMORY_TYPES_H__
 
 #if defined(CONFIG_MALI400_UMP)
-#include "ump_kernel_interface.h"
+#include "../ump/include/ump/ump_kernel_interface.h"
 #endif
 
 typedef u32 mali_address_t;
@@ -26,29 +26,6 @@
 	MALI_MEM_TYPE_MAX,
 } mali_mem_type;
 
-typedef struct mali_block_item {
-	/* for block type, the block_phy is alway page size align
-	* so use low 12bit used for ref_cout.
-	*/
-	unsigned long phy_addr;
-} mali_block_item;
-
-typedef enum mali_page_node_type {
-	MALI_PAGE_NODE_OS,
-	MALI_PAGE_NODE_BLOCK,
-} mali_page_node_type;
-
-typedef struct mali_block_node {
-	struct list_head list;
-	mali_block_item *blk_it; /*pointer to block item*/
-	u32 type;
-} mali_block_node;
-
-typedef struct mali_page_node {
-	struct list_head list;
-	struct page *page;
-} mali_page_node;
-
 typedef struct mali_mem_os_mem {
 	struct list_head pages;
 	u32 count;
@@ -79,8 +56,7 @@
 } block_allocator_allocation;
 
 typedef struct mali_mem_block_mem {
-	struct list_head pfns;
-	u32 count;
+	block_allocator_allocation mem;
 } mali_mem_block_mem;
 
 typedef struct mali_mem_virt_mali_mapping {
@@ -96,19 +72,6 @@
 #define MALI_MEM_ALLOCATION_VALID_MAGIC 0xdeda110c
 #define MALI_MEM_ALLOCATION_FREED_MAGIC 0x10101010
 
-typedef struct mali_mm_node {
-	/* MALI GPU vaddr start, use u32 for mmu only support 32bit address*/
-	uint32_t start; /* GPU vaddr */
-	uint32_t size;  /* GPU allocation virtual size */
-	unsigned allocated : 1;
-} mali_mm_node;
-
-typedef struct mali_vma_node {
-	struct mali_mm_node vm_node;
-	struct rb_node vm_rb;
-} mali_vma_node;
-
-
 typedef struct mali_mem_allocation {
 	MALI_DEBUG_CODE(u32 magic);
 	mali_mem_type type;                /**< Type of memory */
@@ -130,40 +93,8 @@
 
 	mali_mem_virt_cpu_mapping cpu_mapping; /**< CPU mapping */
 	mali_mem_virt_mali_mapping mali_mapping; /**< Mali mapping */
-
-	/* add for new memory system */
-	struct mali_vma_node mali_vma_node;
-	u32 vsize; /* virtual size*/
-	u32 psize; /* physical backend memory size*/
-	struct list_head list;
-	s32 backend_handle; /* idr for mem_backend */
-	struct kref ref;
 } mali_mem_allocation;
 
-
-/* COW backend memory type */
-typedef struct mali_mem_cow {
-	struct list_head pages;  /**< all pages for this cow backend allocation,
-                                                                including new allocated pages for modified range*/
-	u32 count;               /**< number of pages */
-} mali_mem_cow;
-
-typedef struct mali_mem_backend {
-	mali_mem_type type;                /**< Type of backend memory */
-	u32 flags;                         /**< Flags for this allocation */
-	u32 size;
-	/* Union selected by type. */
-	union {
-		mali_mem_os_mem os_mem;       /**< MALI_MEM_OS */
-		mali_mem_external ext_mem;    /**< MALI_MEM_EXTERNAL */
-		mali_mem_dma_buf dma_buf;     /**< MALI_MEM_DMA_BUF */
-		mali_mem_ump ump_mem;         /**< MALI_MEM_UMP */
-		mali_mem_block_mem block_mem; /**< MALI_MEM_BLOCK */
-		mali_mem_cow cow_mem;
-	};
-	mali_mem_allocation *mali_allocation;
-} mali_mem_backend;
-
 #define MALI_MEM_FLAG_MALI_GUARD_PAGE (1 << 0)
 #define MALI_MEM_FLAG_DONT_CPU_MAP    (1 << 1)
 
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_ump.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_ump.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_memory_ump.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_memory_ump.c	2016-04-04 16:42:09.328527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -13,31 +13,27 @@
 #include "mali_kernel_common.h"
 #include "mali_session.h"
 #include "mali_kernel_linux.h"
+
 #include "mali_memory.h"
-#include "ump_kernel_interface.h"
 
-static int mali_mem_ump_map(mali_mem_backend *mem_backend)
+#include "../../ump/include/ump/ump_kernel_interface.h"
+
+static int mali_ump_map(struct mali_session_data *session, mali_mem_allocation *descriptor)
 {
 	ump_dd_handle ump_mem;
-	mali_mem_allocation *alloc;
-	struct mali_session_data *session;
 	u32 nr_blocks;
 	u32 i;
 	ump_dd_physical_block *ump_blocks;
 	struct mali_page_directory *pagedir;
 	u32 offset = 0;
+	u32 prop;
 	_mali_osk_errcode_t err;
 
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	MALI_DEBUG_ASSERT(MALI_MEM_UMP == mem_backend->type);
-
-	alloc = mem_backend->mali_allocation;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-
-	session = alloc->session;
 	MALI_DEBUG_ASSERT_POINTER(session);
+	MALI_DEBUG_ASSERT_POINTER(descriptor);
+	MALI_DEBUG_ASSERT(MALI_MEM_UMP == descriptor->type);
 
-	ump_mem = mem_backend->ump_mem.handle;
+	ump_mem = descriptor->ump_mem.handle;
 	MALI_DEBUG_ASSERT(UMP_DD_HANDLE_INVALID != ump_mem);
 
 	nr_blocks = ump_dd_phys_block_count_get(ump_mem);
@@ -57,108 +53,161 @@
 	}
 
 	pagedir = session->page_directory;
+	prop = descriptor->mali_mapping.properties;
 
-	mali_session_memory_lock(session);
-
-	err = mali_mem_mali_map_prepare(alloc);
+	err = mali_mem_mali_map_prepare(descriptor);
 	if (_MALI_OSK_ERR_OK != err) {
 		MALI_DEBUG_PRINT(1, ("Mapping of UMP memory failed\n"));
 
 		_mali_osk_free(ump_blocks);
-		mali_session_memory_unlock(session);
 		return -ENOMEM;
 	}
 
 	for (i = 0; i < nr_blocks; ++i) {
-		u32 virt = alloc->mali_vma_node.vm_node.start + offset;
+		u32 virt = descriptor->mali_mapping.addr + offset;
 
 		MALI_DEBUG_PRINT(7, ("Mapping in 0x%08x size %d\n", ump_blocks[i].addr , ump_blocks[i].size));
 
 		mali_mmu_pagedir_update(pagedir, virt, ump_blocks[i].addr,
-					ump_blocks[i].size, MALI_MMU_FLAGS_DEFAULT);
+					ump_blocks[i].size, prop);
 
 		offset += ump_blocks[i].size;
 	}
 
-	if (alloc->flags & _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE) {
-		u32 virt = alloc->mali_vma_node.vm_node.start + offset;
+	if (descriptor->flags & _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE) {
+		u32 virt = descriptor->mali_mapping.addr + offset;
 
 		/* Map in an extra virtual guard page at the end of the VMA */
 		MALI_DEBUG_PRINT(6, ("Mapping in extra guard page\n"));
 
-		mali_mmu_pagedir_update(pagedir, virt, ump_blocks[0].addr, _MALI_OSK_MALI_PAGE_SIZE, MALI_MMU_FLAGS_DEFAULT);
+		mali_mmu_pagedir_update(pagedir, virt, ump_blocks[0].addr, _MALI_OSK_MALI_PAGE_SIZE, prop);
 
 		offset += _MALI_OSK_MALI_PAGE_SIZE;
 	}
-	session->mali_mem_array[mem_backend->type] += mem_backend->size;
-	mali_session_memory_unlock(session);
+
 	_mali_osk_free(ump_blocks);
+
 	return 0;
 }
 
-static void mali_mem_ump_unmap(mali_mem_allocation *alloc)
+void mali_ump_unmap(struct mali_session_data *session, mali_mem_allocation *descriptor)
 {
-	struct mali_session_data *session;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-	session = alloc->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-	mali_session_memory_lock(session);
-	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
-			       alloc->flags);
+	ump_dd_handle ump_mem;
+	struct mali_page_directory *pagedir;
+
+	ump_mem = descriptor->ump_mem.handle;
+	pagedir = session->page_directory;
+
+	MALI_DEBUG_ASSERT(UMP_DD_HANDLE_INVALID != ump_mem);
+
+	mali_mem_mali_map_free(descriptor);
 
-	session->mali_mem_array[alloc->type] -= alloc->psize;
-	mali_session_memory_unlock(session);
+	ump_dd_reference_release(ump_mem);
+	return;
 }
 
-int mali_memory_bind_ump_buf(mali_mem_allocation *alloc, mali_mem_backend *mem_backend, u32  secure_id, u32 flags)
+_mali_osk_errcode_t _mali_ukk_attach_ump_mem(_mali_uk_attach_ump_mem_s *args)
 {
 	ump_dd_handle ump_mem;
-	int ret;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	MALI_DEBUG_ASSERT(MALI_MEM_UMP == mem_backend->type);
+	struct mali_session_data *session;
+	mali_mem_allocation *descriptor;
+	int md, ret;
+
+	MALI_DEBUG_ASSERT_POINTER(args);
+	MALI_DEBUG_ASSERT(NULL != (void *)(uintptr_t)args->ctx);
+
+	session = (struct mali_session_data *)(uintptr_t)args->ctx;
+
+	/* check arguments */
+	/* NULL might be a valid Mali address */
+	if (!args->size) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
+
+	/* size must be a multiple of the system page size */
+	if (args->size % _MALI_OSK_MALI_PAGE_SIZE) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
 
 	MALI_DEBUG_PRINT(3,
 			 ("Requested to map ump memory with secure id %d into virtual memory 0x%08X, size 0x%08X\n",
-			  secure_id, alloc->mali_vma_node.vm_node.start, alloc->mali_vma_node.vm_node.size));
+			  args->secure_id, args->mali_address, args->size));
+
+	ump_mem = ump_dd_handle_create_from_secure_id((int)args->secure_id);
 
-	ump_mem = ump_dd_handle_create_from_secure_id(secure_id);
 	if (UMP_DD_HANDLE_INVALID == ump_mem) MALI_ERROR(_MALI_OSK_ERR_FAULT);
-	alloc->flags |= MALI_MEM_FLAG_DONT_CPU_MAP;
-	if (flags & _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE) {
-		alloc->flags |= MALI_MEM_FLAG_MALI_GUARD_PAGE;
+
+	descriptor = mali_mem_descriptor_create(session, MALI_MEM_UMP);
+	if (NULL == descriptor) {
+		ump_dd_reference_release(ump_mem);
+		MALI_ERROR(_MALI_OSK_ERR_NOMEM);
 	}
 
-	mem_backend->ump_mem.handle = ump_mem;
+	descriptor->ump_mem.handle = ump_mem;
+	descriptor->mali_mapping.addr = args->mali_address;
+	descriptor->size = args->size;
+	descriptor->mali_mapping.properties = MALI_MMU_FLAGS_DEFAULT;
+	descriptor->flags |= MALI_MEM_FLAG_DONT_CPU_MAP;
 
-	ret = mali_mem_ump_map(mem_backend);
+	if (args->flags & _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE) {
+		descriptor->flags = MALI_MEM_FLAG_MALI_GUARD_PAGE;
+	}
+
+	_mali_osk_mutex_wait(session->memory_lock);
+
+	ret = mali_ump_map(session, descriptor);
 	if (0 != ret) {
+		_mali_osk_mutex_signal(session->memory_lock);
 		ump_dd_reference_release(ump_mem);
-		return _MALI_OSK_ERR_FAULT;
+		mali_mem_descriptor_destroy(descriptor);
+		MALI_ERROR(_MALI_OSK_ERR_NOMEM);
 	}
-	MALI_DEBUG_PRINT(3, ("Returning from UMP bind\n"));
-	return _MALI_OSK_ERR_OK;
+
+	_mali_osk_mutex_signal(session->memory_lock);
+
+
+	if (_MALI_OSK_ERR_OK != mali_descriptor_mapping_allocate_mapping(session->descriptor_mapping, descriptor, &md)) {
+		ump_dd_reference_release(ump_mem);
+		mali_mem_descriptor_destroy(descriptor);
+		MALI_ERROR(_MALI_OSK_ERR_FAULT);
+	}
+
+	args->cookie = md;
+
+	MALI_DEBUG_PRINT(5, ("Returning from UMP attach\n"));
+
+	MALI_SUCCESS;
 }
 
-void mali_mem_ump_release(mali_mem_backend *mem_backend)
+void mali_mem_ump_release(mali_mem_allocation *descriptor)
 {
-	ump_dd_handle ump_mem;
-	mali_mem_allocation *alloc;
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	MALI_DEBUG_ASSERT(MALI_MEM_UMP == mem_backend->type);
-	ump_mem = mem_backend->ump_mem.handle;
-	MALI_DEBUG_ASSERT(UMP_DD_HANDLE_INVALID != ump_mem);
+	struct mali_session_data *session = descriptor->session;
 
-	alloc = mem_backend->mali_allocation;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-	mali_mem_ump_unmap(alloc);
-	ump_dd_reference_release(ump_mem);
+	MALI_DEBUG_ASSERT(MALI_MEM_UMP == descriptor->type);
+
+	mali_ump_unmap(session, descriptor);
 }
 
-int mali_memory_unbind_ump_buf(mali_mem_backend *mem_backend)
+_mali_osk_errcode_t _mali_ukk_release_ump_mem(_mali_uk_release_ump_mem_s *args)
 {
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	mali_mem_ump_release(mem_backend);
-	return _MALI_OSK_ERR_OK;
-}
+	mali_mem_allocation *descriptor;
+	struct mali_session_data *session;
 
+	MALI_DEBUG_ASSERT_POINTER(args);
+	MALI_DEBUG_ASSERT(NULL != (void *)(uintptr_t)args->ctx);
+
+	session = (struct mali_session_data *)(uintptr_t)args->ctx;
+
+	if (_MALI_OSK_ERR_OK != mali_descriptor_mapping_get(session->descriptor_mapping, args->cookie, (void **)&descriptor)) {
+		MALI_DEBUG_PRINT(1, ("Invalid memory descriptor %d used to release ump memory\n", args->cookie));
+		MALI_ERROR(_MALI_OSK_ERR_FAULT);
+	}
+
+	descriptor = mali_descriptor_mapping_free(session->descriptor_mapping, args->cookie);
+
+	if (NULL != descriptor) {
+		_mali_osk_mutex_wait(session->memory_lock);
+		mali_mem_ump_release(descriptor);
+		_mali_osk_mutex_signal(session->memory_lock);
+
+		mali_mem_descriptor_destroy(descriptor);
+	}
+
+	MALI_SUCCESS;
+}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_atomics.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_atomics.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_atomics.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_atomics.c	2016-04-04 16:25:32.608527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_irq.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_irq.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_irq.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_irq.c	2016-04-04 16:25:32.618527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -13,9 +13,7 @@
  * Implementation of the OS abstraction layer for the kernel device driver
  */
 
-#include <linux/types.h>
-#include <mach/cpu.h>
-#include <linux/slab.h>	/* For memory allocation */
+#include <linux/slab.h> /* For memory allocation */
 #include <linux/interrupt.h>
 #include <linux/wait.h>
 #include <linux/sched.h>
@@ -32,16 +30,6 @@
 typedef irqreturn_t (*irq_handler_func_t)(int, void *, struct pt_regs *);
 static irqreturn_t irq_handler_upper_half(int port_name, void *dev_id);   /* , struct pt_regs *regs*/
 
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-u32 get_irqnum(struct _mali_osk_irq_t_struct* irq)
-{
-	if (irq)
-		return irq->irqnum;
-	else
-		return 0;
-}
-#endif
-
 #if defined(DEBUG)
 
 struct test_interrupt_data {
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_locks.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_locks.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_locks.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_locks.c	2016-04-04 16:25:32.628527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_locks.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_locks.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_locks.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_locks.h	2016-04-04 16:25:32.638527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_low_level_mem.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_low_level_mem.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_low_level_mem.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_low_level_mem.c	2016-04-04 16:25:32.648527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_mali.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_mali.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_mali.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_mali.c	2016-04-04 16:25:32.658527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -53,33 +53,33 @@
 #define MALI_OSK_RESOURCE_l2_LOCATION_END 22
 
 static _mali_osk_resource_t mali_osk_resource_bank[MALI_OSK_MAX_RESOURCE_NUMBER] = {
-	{.description = "Mali_GP", .base = MALI_OFFSET_GP, .irq_name = "IRQGP",},
-	{.description = "Mali_GP_MMU", .base = MALI_OFFSET_GP_MMU, .irq_name = "IRQGPMMU",},
-	{.description = "Mali_PP0", .base = MALI_OFFSET_PP0, .irq_name = "IRQPP0",},
-	{.description = "Mali_PP0_MMU", .base = MALI_OFFSET_PP0_MMU, .irq_name = "IRQPPMMU0",},
-	{.description = "Mali_PP1", .base = MALI_OFFSET_PP1, .irq_name = "IRQPP1",},
-	{.description = "Mali_PP1_MMU", .base = MALI_OFFSET_PP1_MMU, .irq_name = "IRQPPMMU1",},
-	{.description = "Mali_PP2", .base = MALI_OFFSET_PP2, .irq_name = "IRQPP2",},
-	{.description = "Mali_PP2_MMU", .base = MALI_OFFSET_PP2_MMU, .irq_name = "IRQPPMMU2",},
-	{.description = "Mali_PP3", .base = MALI_OFFSET_PP3, .irq_name = "IRQPP3",},
-	{.description = "Mali_PP3_MMU", .base = MALI_OFFSET_PP3_MMU, .irq_name = "IRQPPMMU3",},
-	{.description = "Mali_PP4", .base = MALI_OFFSET_PP4, .irq_name = "IRQPP4",},
-	{.description = "Mali_PP4_MMU", .base = MALI_OFFSET_PP4_MMU, .irq_name = "IRQPPMMU4",},
-	{.description = "Mali_PP5", .base = MALI_OFFSET_PP5, .irq_name = "IRQPP5",},
-	{.description = "Mali_PP5_MMU", .base = MALI_OFFSET_PP5_MMU, .irq_name = "IRQPPMMU5",},
-	{.description = "Mali_PP6", .base = MALI_OFFSET_PP6, .irq_name = "IRQPP6",},
-	{.description = "Mali_PP6_MMU", .base = MALI_OFFSET_PP6_MMU, .irq_name = "IRQPPMMU6",},
-	{.description = "Mali_PP7", .base = MALI_OFFSET_PP7, .irq_name = "IRQPP7",},
-	{.description = "Mali_PP7_MMU", .base = MALI_OFFSET_PP7_MMU, .irq_name = "IRQPPMMU",},
-	{.description = "Mali_PP_Broadcast", .base = MALI_OFFSET_PP_BCAST, .irq_name = "IRQPP",},
-	{.description = "Mali_PMU", .base = MALI_OFFSET_PMU, .irq_name = "IRQPMU",},
-	{.description = "Mali_L2", .base = MALI_OFFSET_L2_RESOURCE0,},
-	{.description = "Mali_L2", .base = MALI_OFFSET_L2_RESOURCE1,},
-	{.description = "Mali_L2", .base = MALI_OFFSET_L2_RESOURCE2,},
-	{.description = "Mali_PP_MMU_Broadcast", .base = MALI_OFFSET_PP_BCAST_MMU,},
-	{.description = "Mali_Broadcast", .base = MALI_OFFSET_BCAST,},
-	{.description = "Mali_DLBU", .base = MALI_OFFSET_DLBU,},
-	{.description = "Mali_DMA", .base = MALI_OFFSET_DMA,},
+{.description = "Mali_GP", .base = MALI_OFFSET_GP, .irq_name = "IRQGP",},
+{.description = "Mali_GP_MMU", .base = MALI_OFFSET_GP_MMU, .irq_name = "IRQGPMMU",},
+{.description = "Mali_PP0", .base = MALI_OFFSET_PP0, .irq_name = "IRQPP0",},
+{.description = "Mali_PP0_MMU", .base = MALI_OFFSET_PP0_MMU, .irq_name = "IRQPPMMU0",},
+{.description = "Mali_PP1", .base = MALI_OFFSET_PP1, .irq_name = "IRQPP1",},
+{.description = "Mali_PP1_MMU", .base = MALI_OFFSET_PP1_MMU, .irq_name = "IRQPPMMU1",},
+{.description = "Mali_PP2", .base = MALI_OFFSET_PP2, .irq_name = "IRQPP2",},
+{.description = "Mali_PP2_MMU", .base = MALI_OFFSET_PP2_MMU, .irq_name = "IRQPPMMU2",},
+{.description = "Mali_PP3", .base = MALI_OFFSET_PP3, .irq_name = "IRQPP3",},
+{.description = "Mali_PP3_MMU", .base = MALI_OFFSET_PP3_MMU, .irq_name = "IRQPPMMU3",},
+{.description = "Mali_PP4", .base = MALI_OFFSET_PP4, .irq_name = "IRQPP4",},
+{.description = "Mali_PP4_MMU", .base = MALI_OFFSET_PP4_MMU, .irq_name = "IRQPPMMU4",},
+{.description = "Mali_PP5", .base = MALI_OFFSET_PP5, .irq_name = "IRQPP5",},
+{.description = "Mali_PP5_MMU", .base = MALI_OFFSET_PP5_MMU, .irq_name = "IRQPPMMU5",},
+{.description = "Mali_PP6", .base = MALI_OFFSET_PP6, .irq_name = "IRQPP6",},
+{.description = "Mali_PP6_MMU", .base = MALI_OFFSET_PP6_MMU, .irq_name = "IRQPPMMU6",},
+{.description = "Mali_PP7", .base = MALI_OFFSET_PP7, .irq_name = "IRQPP7",},
+{.description = "Mali_PP7_MMU", .base = MALI_OFFSET_PP7_MMU, .irq_name = "IRQPPMMU",},
+{.description = "Mali_PP_Broadcast", .base = MALI_OFFSET_PP_BCAST, .irq_name = "IRQPP",},
+{.description = "Mali_PMU", .base = MALI_OFFSET_PMU, .irq_name = "IRQPMU",},
+{.description = "Mali_L2", .base = MALI_OFFSET_L2_RESOURCE0,},
+{.description = "Mali_L2", .base = MALI_OFFSET_L2_RESOURCE1,},
+{.description = "Mali_L2", .base = MALI_OFFSET_L2_RESOURCE2,},
+{.description = "Mali_PP_MMU_Broadcast", .base = MALI_OFFSET_PP_BCAST_MMU,},
+{.description = "Mali_Broadcast", .base = MALI_OFFSET_BCAST,},
+{.description = "Mali_DLBU", .base = MALI_OFFSET_DLBU,},
+{.description = "Mali_DMA", .base = MALI_OFFSET_DMA,},
 };
 
 _mali_osk_errcode_t _mali_osk_resource_initialize(void)
@@ -93,7 +93,7 @@
 		if (res) {
 			mali_osk_resource_bank[i].irq = res->start;
 			if (0 == strncmp("Mali_PP_Broadcast", mali_osk_resource_bank[i].description,
-					 strlen(mali_osk_resource_bank[i].description))) {
+					strlen(mali_osk_resource_bank[i].description))) {
 				mali_is_450 = MALI_TRUE;
 			}
 		} else {
@@ -186,15 +186,13 @@
 	int length = 0, i = 0;
 	u32 u;
 
-	MALI_DEBUG_PRINT(2, ("Get pmu config from device tree configuration.\n"));
-
 	MALI_DEBUG_ASSERT(NULL != node);
 
 	if (!of_get_property(node, "pmu_domain_config", &length)) {
 		return;
 	}
 
-	if (array_size != length / sizeof(u32)) {
+	if (array_size != length/sizeof(u32)) {
 		MALI_PRINT_ERROR(("Wrong pmu domain config in device tree."));
 		return;
 	}
@@ -281,7 +279,6 @@
 {
 	_mali_osk_device_data data = { 0, };
 
-	MALI_DEBUG_PRINT(2, ("Get pmu config from platform device data.\n"));
 	if (_MALI_OSK_ERR_OK == _mali_osk_device_data_get(&data)) {
 		/* Copy the custom customer power domain config */
 		_mali_osk_memcpy(domain_config_array, data.pmu_domain_config, sizeof(data.pmu_domain_config));
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_math.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_math.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_math.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_math.c	2016-04-04 16:25:32.658527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_memory.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_memory.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_memory.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_memory.c	2016-04-04 16:25:32.668527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2011, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_misc.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_misc.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_misc.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_misc.c	2016-04-04 16:25:32.678527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_notification.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_notification.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_notification.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_notification.c	2016-04-04 16:25:32.688527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_pm.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_pm.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_pm.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_pm.c	2016-04-04 16:25:32.698527000 +0300
@@ -1,5 +1,5 @@
 /**
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_profiling.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_profiling.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_profiling.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_profiling.c	2016-04-04 16:25:32.698527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_specific.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_specific.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_specific.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_specific.h	2016-04-04 16:25:32.708527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_time.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_time.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_time.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_time.c	2016-04-04 16:25:32.718527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_timers.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_timers.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_timers.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_timers.c	2016-04-04 16:25:32.728527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_wait_queue.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_wait_queue.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_wait_queue.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_wait_queue.c	2016-04-04 16:25:32.738527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_wq.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_wq.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_osk_wq.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_osk_wq.c	2016-04-04 16:25:32.748527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_pmu_power_up_down.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_pmu_power_up_down.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_pmu_power_up_down.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_pmu_power_up_down.c	2016-04-04 16:25:32.758527000 +0300
@@ -1,5 +1,5 @@
 /**
- * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -17,11 +17,7 @@
 
 int mali_perf_set_num_pp_cores(unsigned int num_cores)
 {
-#ifndef CONFIG_MALI_DVFS
-	return mali_executor_set_perf_level(num_cores, MALI_TRUE);
-#else
 	return mali_executor_set_perf_level(num_cores, MALI_FALSE);
-#endif
 }
 
 EXPORT_SYMBOL(mali_perf_set_num_pp_cores);
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_profiling_events.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_profiling_events.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_profiling_events.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_profiling_events.h	2016-04-04 16:25:32.768527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012, 2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_profiling_gator_api.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_profiling_gator_api.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_profiling_gator_api.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_profiling_gator_api.h	2016-04-04 16:25:32.768527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_profiling_internal.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_profiling_internal.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_profiling_internal.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_profiling_internal.c	2016-04-04 16:25:32.788527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_profiling_internal.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_profiling_internal.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_profiling_internal.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_profiling_internal.h	2016-04-04 16:25:32.798527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_sync.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_sync.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_sync.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_sync.c	2016-04-04 16:25:32.798527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -59,11 +59,6 @@
 	struct mali_sync_pt *mpt, *new_mpt;
 	struct sync_pt *new_pt;
 
-	if (NULL == pt) {
-		dump_stack();
-		return NULL;
-	}
-
 	MALI_DEBUG_ASSERT_POINTER(pt);
 	mpt = to_mali_sync_pt(pt);
 
@@ -181,7 +176,7 @@
 
 	if (NULL != mali_sync_tl->timeline) {
 		_mali_osk_snprintf(str, size, "oldest (%u)  next (%u)\n", mali_sync_tl->timeline->point_oldest,
-				   mali_sync_tl->timeline->point_next);
+			mali_sync_tl->timeline->point_next);
 	}
 }
 #endif
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_sync.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_sync.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_sync.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_sync.h	2016-04-04 16:25:32.818527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_core.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_core.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_core.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_core.c	2016-04-04 16:25:32.828527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_gp.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_gp.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_gp.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_gp.c	2016-04-04 16:25:32.838527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_mem.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_mem.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_mem.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_mem.c	2016-04-04 16:25:32.848527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -16,138 +16,159 @@
 #include "mali_session.h"
 #include "mali_ukk_wrappers.h"
 
-int mem_alloc_wrapper(struct mali_session_data *session_data, _mali_uk_alloc_mem_s __user *uargs)
+int mem_write_safe_wrapper(struct mali_session_data *session_data, _mali_uk_mem_write_safe_s __user *uargs)
 {
-	_mali_uk_alloc_mem_s kargs;
+	_mali_uk_mem_write_safe_s kargs;
 	_mali_osk_errcode_t err;
 
 	MALI_CHECK_NON_NULL(uargs, -EINVAL);
 	MALI_CHECK_NON_NULL(session_data, -EINVAL);
 
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_alloc_mem_s))) {
+	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_mem_write_safe_s))) {
 		return -EFAULT;
 	}
+
 	kargs.ctx = (uintptr_t)session_data;
 
-	err = _mali_ukk_mem_allocate(&kargs);
+	/* Check if we can access the buffers */
+	if (!access_ok(VERIFY_WRITE, kargs.dest, kargs.size)
+	    || !access_ok(VERIFY_READ, kargs.src, kargs.size)) {
+		return -EINVAL;
+	}
+
+	/* Check if size wraps */
+	if ((kargs.size + kargs.dest) <= kargs.dest
+	    || (kargs.size + kargs.src) <= kargs.src) {
+		return -EINVAL;
+	}
 
+	err = _mali_ukk_mem_write_safe(&kargs);
 	if (_MALI_OSK_ERR_OK != err) {
 		return map_errcode(err);
 	}
 
-	if (0 != put_user(kargs.backend_handle, &uargs->backend_handle)) {
+	if (0 != put_user(kargs.size, &uargs->size)) {
 		return -EFAULT;
 	}
 
 	return 0;
 }
 
-int mem_free_wrapper(struct mali_session_data *session_data, _mali_uk_free_mem_s __user *uargs)
+int mem_map_ext_wrapper(struct mali_session_data *session_data, _mali_uk_map_external_mem_s __user *argument)
 {
-	_mali_uk_free_mem_s kargs;
-	_mali_osk_errcode_t err;
+	_mali_uk_map_external_mem_s uk_args;
+	_mali_osk_errcode_t err_code;
 
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-	MALI_CHECK_NON_NULL(session_data, -EINVAL);
+	/* validate input */
+	/* the session_data pointer was validated by caller */
+	MALI_CHECK_NON_NULL(argument, -EINVAL);
 
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_free_mem_s))) {
+	/* get call arguments from user space. copy_from_user returns how many bytes which where NOT copied */
+	if (0 != copy_from_user(&uk_args, (void __user *)argument, sizeof(_mali_uk_map_external_mem_s))) {
 		return -EFAULT;
 	}
-	kargs.ctx = (uintptr_t)session_data;
 
-	err = _mali_ukk_mem_free(&kargs);
+	uk_args.ctx = (uintptr_t)session_data;
+	err_code = _mali_ukk_map_external_mem(&uk_args);
 
-	if (_MALI_OSK_ERR_OK != err) {
-		return map_errcode(err);
+	if (0 != put_user(uk_args.cookie, &argument->cookie)) {
+		if (_MALI_OSK_ERR_OK == err_code) {
+			/* Rollback */
+			_mali_uk_unmap_external_mem_s uk_args_unmap;
+
+			uk_args_unmap.ctx = (uintptr_t)session_data;
+			uk_args_unmap.cookie = uk_args.cookie;
+			err_code = _mali_ukk_unmap_external_mem(&uk_args_unmap);
+			if (_MALI_OSK_ERR_OK != err_code) {
+				MALI_DEBUG_PRINT(4, ("reverting _mali_ukk_unmap_external_mem, as a result of failing put_user(), failed\n"));
+			}
+		}
+		return -EFAULT;
 	}
 
-	return 0;
+	/* Return the error that _mali_ukk_free_big_block produced */
+	return map_errcode(err_code);
 }
 
-int mem_bind_wrapper(struct mali_session_data *session_data, _mali_uk_bind_mem_s __user *uargs)
+int mem_unmap_ext_wrapper(struct mali_session_data *session_data, _mali_uk_unmap_external_mem_s __user *argument)
 {
-	_mali_uk_bind_mem_s kargs;
-	_mali_osk_errcode_t err;
+	_mali_uk_unmap_external_mem_s uk_args;
+	_mali_osk_errcode_t err_code;
 
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-	MALI_CHECK_NON_NULL(session_data, -EINVAL);
+	/* validate input */
+	/* the session_data pointer was validated by caller */
+	MALI_CHECK_NON_NULL(argument, -EINVAL);
 
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_bind_mem_s))) {
+	/* get call arguments from user space. copy_from_user returns how many bytes which where NOT copied */
+	if (0 != copy_from_user(&uk_args, (void __user *)argument, sizeof(_mali_uk_unmap_external_mem_s))) {
 		return -EFAULT;
 	}
-	kargs.ctx = (uintptr_t)session_data;
 
-	err = _mali_ukk_mem_bind(&kargs);
+	uk_args.ctx = (uintptr_t)session_data;
+	err_code = _mali_ukk_unmap_external_mem(&uk_args);
 
-	if (_MALI_OSK_ERR_OK != err) {
-		return map_errcode(err);
-	}
-
-	return 0;
+	/* Return the error that _mali_ukk_free_big_block produced */
+	return map_errcode(err_code);
 }
 
-int mem_unbind_wrapper(struct mali_session_data *session_data, _mali_uk_unbind_mem_s __user *uargs)
+#if defined(CONFIG_MALI400_UMP)
+int mem_release_ump_wrapper(struct mali_session_data *session_data, _mali_uk_release_ump_mem_s __user *argument)
 {
-	_mali_uk_unbind_mem_s kargs;
-	_mali_osk_errcode_t err;
+	_mali_uk_release_ump_mem_s uk_args;
+	_mali_osk_errcode_t err_code;
 
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-	MALI_CHECK_NON_NULL(session_data, -EINVAL);
+	/* validate input */
+	/* the session_data pointer was validated by caller */
+	MALI_CHECK_NON_NULL(argument, -EINVAL);
 
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_unbind_mem_s))) {
+	/* get call arguments from user space. copy_from_user returns how many bytes which where NOT copied */
+	if (0 != copy_from_user(&uk_args, (void __user *)argument, sizeof(_mali_uk_release_ump_mem_s))) {
 		return -EFAULT;
 	}
-	kargs.ctx = (uintptr_t)session_data;
 
-	err = _mali_ukk_mem_unbind(&kargs);
+	uk_args.ctx = (uintptr_t)session_data;
+	err_code = _mali_ukk_release_ump_mem(&uk_args);
 
-	if (_MALI_OSK_ERR_OK != err) {
-		return map_errcode(err);
-	}
-
-	return 0;
+	/* Return the error that _mali_ukk_free_big_block produced */
+	return map_errcode(err_code);
 }
 
-
-int mem_write_safe_wrapper(struct mali_session_data *session_data, _mali_uk_mem_write_safe_s __user *uargs)
+int mem_attach_ump_wrapper(struct mali_session_data *session_data, _mali_uk_attach_ump_mem_s __user *argument)
 {
-	_mali_uk_mem_write_safe_s kargs;
-	_mali_osk_errcode_t err;
+	_mali_uk_attach_ump_mem_s uk_args;
+	_mali_osk_errcode_t err_code;
 
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-	MALI_CHECK_NON_NULL(session_data, -EINVAL);
+	/* validate input */
+	/* the session_data pointer was validated by caller */
+	MALI_CHECK_NON_NULL(argument, -EINVAL);
 
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_mem_write_safe_s))) {
+	/* get call arguments from user space. copy_from_user returns how many bytes which where NOT copied */
+	if (0 != copy_from_user(&uk_args, (void __user *)argument, sizeof(_mali_uk_attach_ump_mem_s))) {
 		return -EFAULT;
 	}
 
-	kargs.ctx = (uintptr_t)session_data;
-
-	/* Check if we can access the buffers */
-	if (!access_ok(VERIFY_WRITE, kargs.dest, kargs.size)
-	    || !access_ok(VERIFY_READ, kargs.src, kargs.size)) {
-		return -EINVAL;
-	}
-
-	/* Check if size wraps */
-	if ((kargs.size + kargs.dest) <= kargs.dest
-	    || (kargs.size + kargs.src) <= kargs.src) {
-		return -EINVAL;
-	}
+	uk_args.ctx = (uintptr_t)session_data;
+	err_code = _mali_ukk_attach_ump_mem(&uk_args);
 
-	err = _mali_ukk_mem_write_safe(&kargs);
-	if (_MALI_OSK_ERR_OK != err) {
-		return map_errcode(err);
-	}
+	if (0 != put_user(uk_args.cookie, &argument->cookie)) {
+		if (_MALI_OSK_ERR_OK == err_code) {
+			/* Rollback */
+			_mali_uk_release_ump_mem_s uk_args_unmap;
 
-	if (0 != put_user(kargs.size, &uargs->size)) {
+			uk_args_unmap.ctx = (uintptr_t)session_data;
+			uk_args_unmap.cookie = uk_args.cookie;
+			err_code = _mali_ukk_release_ump_mem(&uk_args_unmap);
+			if (_MALI_OSK_ERR_OK != err_code) {
+				MALI_DEBUG_PRINT(4, ("reverting _mali_ukk_attach_mem, as a result of failing put_user(), failed\n"));
+			}
+		}
 		return -EFAULT;
 	}
 
-	return 0;
+	/* Return the error that _mali_ukk_map_external_ump_mem produced */
+	return map_errcode(err_code);
 }
-
-
+#endif /* CONFIG_MALI400_UMP */
 
 int mem_query_mmu_page_table_dump_size_wrapper(struct mali_session_data *session_data, _mali_uk_query_mmu_page_table_dump_size_s __user *uargs)
 {
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_pp.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_pp.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_pp.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_pp.c	2016-04-04 16:25:32.858527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_profiling.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_profiling.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_profiling.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_profiling.c	2016-04-04 16:25:32.858527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_soft_job.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_soft_job.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_soft_job.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_soft_job.c	2016-04-04 16:25:32.868527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_timeline.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_timeline.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_timeline.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_timeline.c	2016-04-04 16:25:32.878527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_vsync.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_vsync.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_vsync.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_vsync.c	2016-04-04 16:25:32.888527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2011-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_wrappers.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_wrappers.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_ukk_wrappers.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_ukk_wrappers.h	2016-04-04 16:25:32.898527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -30,12 +30,9 @@
 int post_notification_wrapper(struct mali_session_data *session_data, _mali_uk_post_notification_s __user *uargs);
 int request_high_priority_wrapper(struct mali_session_data *session_data, _mali_uk_request_high_priority_s __user *uargs);
 
-int mem_alloc_wrapper(struct mali_session_data *session_data, _mali_uk_alloc_mem_s __user *uargs);
-int mem_free_wrapper(struct mali_session_data *session_data, _mali_uk_free_mem_s __user *uargs);
-int mem_bind_wrapper(struct mali_session_data *session_data, _mali_uk_bind_mem_s __user *uargs);
-int mem_unbind_wrapper(struct mali_session_data *session_data, _mali_uk_unbind_mem_s __user *uargs);
-
 int mem_write_safe_wrapper(struct mali_session_data *session_data, _mali_uk_mem_write_safe_s __user *uargs);
+int mem_map_ext_wrapper(struct mali_session_data *session_data, _mali_uk_map_external_mem_s __user *argument);
+int mem_unmap_ext_wrapper(struct mali_session_data *session_data, _mali_uk_unmap_external_mem_s __user *argument);
 int mem_query_mmu_page_table_dump_size_wrapper(struct mali_session_data *session_data, _mali_uk_query_mmu_page_table_dump_size_s __user *uargs);
 int mem_dump_mmu_page_table_wrapper(struct mali_session_data *session_data, _mali_uk_dump_mmu_page_table_s __user *uargs);
 
@@ -44,6 +41,12 @@
 int timeline_create_sync_fence_wrapper(struct mali_session_data *session, _mali_uk_timeline_create_sync_fence_s __user *uargs);
 int soft_job_start_wrapper(struct mali_session_data *session, _mali_uk_soft_job_start_s __user *uargs);
 int soft_job_signal_wrapper(struct mali_session_data *session, _mali_uk_soft_job_signal_s __user *uargs);
+
+#if defined(CONFIG_MALI400_UMP)
+int mem_attach_ump_wrapper(struct mali_session_data *session_data, _mali_uk_attach_ump_mem_s __user *argument);
+int mem_release_ump_wrapper(struct mali_session_data *session_data, _mali_uk_release_ump_mem_s __user *argument);
+#endif
+
 int pp_start_job_wrapper(struct mali_session_data *session_data, _mali_uk_pp_start_job_s __user *uargs);
 int pp_and_gp_start_job_wrapper(struct mali_session_data *session_data, _mali_uk_pp_and_gp_start_job_s __user *uargs);
 int pp_get_number_of_cores_wrapper(struct mali_session_data *session_data, _mali_uk_get_pp_number_of_cores_s __user *uargs);
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_uk_types.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_uk_types.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/linux/mali_uk_types.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/linux/mali_uk_types.h	2016-04-04 16:25:32.828527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2012, 2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/Makefile linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/Makefile
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/Makefile	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/Makefile	2016-04-04 16:25:31.198527000 +0300
@@ -1,5 +1,5 @@
 #
-# Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+# Copyright (C) 2010-2014 ARM Limited. All rights reserved.
 #
 # This program is free software and is provided to you under the terms of the GNU General Public License version 2
 # as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
@@ -105,6 +105,7 @@
 
 export EXTRA_DEFINES += -DCONFIG_MALI400=1
 export EXTRA_DEFINES += -DCONFIG_MALI450=1
+export EXTRA_DEFINES += -DMALI_FAKE_PLATFORM_DEVICE=1
 
 ifneq ($(MALI_PLATFORM),)
 export EXTRA_DEFINES += -DMALI_FAKE_PLATFORM_DEVICE=1
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/__malidrv_build_info.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/__malidrv_build_info.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/__malidrv_build_info.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/__malidrv_build_info.c	2016-04-04 16:25:33.078527000 +0300
@@ -0,0 +1 @@
+const char *__malidrv_build_info(void) { return "malidrv:  API_VERSION=600 REPO_URL=heads/odroidc-3.10.y REVISION=-jenkins-deb_kernel_c1-143-10-g66340df CHANGED_REVISION=jenkins-deb_kernel_c1-143-10-g66340df CHANGE_DATE=2016-03-28 13:07:38 +0900 BUILD_DATE=Fri  1 Apr 20:36:33 MSK 2016 BUILD=release TARGET_PLATFORM=meson_m450 MALI_PLATFORM= KDIR= OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB=16 USING_UMP=y USING_PROFILING= USING_INTERNAL_PROFILING= USING_GPU_UTILIZATION=1 USING_DVFS= MALI_UPPER_HALF_SCHEDULING=1";}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mali_clock.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mali_clock.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mali_clock.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mali_clock.c	2016-04-04 16:25:32.908527000 +0300
@@ -12,6 +12,7 @@
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TVD
 
 #define FCLK_MPLL2 (2 << 9)
+
 static DEFINE_SPINLOCK(lock);
 static mali_plat_info_t* pmali_plat = NULL;
 static u32 mali_extr_backup = 0;
@@ -97,11 +98,7 @@
 
 u32 get_mali_freq(u32 idx)
 {
-    if (!mali_pm_statue) {
 	return pmali_plat->clk_sample[idx];
-    } else {
-        return 0;
-    }
 }
 
 void set_str_src(u32 data)
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mali_platform.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mali_platform.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mali_platform.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mali_platform.h	2016-04-04 16:25:32.928527000 +0300
@@ -9,7 +9,6 @@
 #ifndef MALI_PLATFORM_H_
 #define MALI_PLATFORM_H_
 
-extern u32 mali_gp_reset_fail;
-extern u32 mali_core_timeout;
+
 
 #endif /* MALI_PLATFORM_H_ */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mali_pm_device.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mali_pm_device.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mali_pm_device.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mali_pm_device.c	2016-04-04 16:25:32.928527000 +0300
@@ -12,7 +12,6 @@
 #include <common/mali_kernel_common.h>
 #include <common/mali_osk_profiling.h>
 #include <common/mali_pmu.h>
-#include <linux/mali/mali_utgard.h>
 
 static int mali_os_suspend(struct device *device)
 {
@@ -29,7 +28,6 @@
 	int ret = 0;
 
 	MALI_DEBUG_PRINT(4, ("mali_os_resume() called\n"));
-
 	ret = mali_deep_resume(device);
 
 	return ret;
@@ -51,34 +49,12 @@
 
 	return ret;
 }
-//copy from r4p1 linux/mali_pmu_power_up_down.c
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-static int mali_pmu_powerup(void)
-{
-	struct mali_pmu_core *pmu = mali_pmu_get_global_pmu_core();
-
-	MALI_DEBUG_PRINT(5, ("Mali PMU: Power up\n"));
-
-	MALI_DEBUG_ASSERT_POINTER(pmu);
-	if (NULL == pmu) {
-		return -ENXIO;
-	}
-
-	mali_pmu_power_up_all(pmu);
-
-	return 0;
-}
-#endif
 
 static int mali_os_thaw(struct device *device)
 {
 	int ret = 0;
 
 	MALI_DEBUG_PRINT(4, ("mali_os_thaw() called\n"));
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	enable_clock();
-	mali_pmu_powerup();
-#endif
 
 	if (NULL != device->driver &&
 	    NULL != device->driver->pm &&
@@ -91,17 +67,7 @@
 	return ret;
 }
 
-static int mali_os_restore(struct device *device)
-{
-	MALI_DEBUG_PRINT(4, ("mali_os_thaw() called\n"));
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	mali_dev_restore();
-#endif
-	return mali_os_resume(device);
-}
-
 #ifdef CONFIG_PM_RUNTIME
-#if 0
 static int mali_runtime_suspend(struct device *device)
 {
 	int ret = 0;
@@ -143,7 +109,6 @@
 	return 0;
 }
 #endif
-#endif
 
 static struct dev_pm_ops mali_gpu_device_type_pm_ops =
 {
@@ -151,8 +116,7 @@
 	.resume = mali_os_resume,
 	.freeze = mali_os_freeze,
 	.thaw = mali_os_thaw,
-	.restore = mali_os_restore,
-#if 0//def CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM_RUNTIME
 	.runtime_suspend = mali_runtime_suspend,
 	.runtime_resume = mali_runtime_resume,
 	.runtime_idle = mali_runtime_idle,
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mali_scaling.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mali_scaling.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mali_scaling.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mali_scaling.h	2016-04-04 16:25:32.938527000 +0300
@@ -106,7 +106,6 @@
 
 /* for frequency reporter in DS-5 streamline. */
 u32 get_current_frequency(void);
-void mali_dev_restore(void);
 
 extern int mali_pm_statue;
 #endif /* __ARM_CORE_SCALING_H__ */
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/platform_g9tv.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/platform_g9tv.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/platform_g9tv.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/platform_g9tv.c	2016-04-04 16:25:32.948527000 +0300
@@ -0,0 +1,417 @@
+/*
+ * platform.c
+ *
+ * clock source setting and resource config
+ *
+ *  Created on: Dec 4, 2013
+ *      Author: amlogic
+ */
+
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/pm.h>
+#include <linux/of.h>
+#include <linux/module.h>            /* kernel module definitions */
+#include <linux/ioport.h>            /* request_mem_region */
+#include <linux/slab.h>
+#include <mach/register.h>
+#include <mach/irqs.h>
+#include <mach/io.h>
+#include <asm/io.h>
+#include <linux/mali/mali_utgard.h>
+#include <linux/gpu_cooling.h>
+#include <linux/gpucore_cooling.h>
+#include <common/mali_kernel_common.h>
+#include <common/mali_osk_profiling.h>
+#include <common/mali_pmu.h>
+
+#include "meson_main.h"
+
+/*
+ *    For Meson 8 M2.
+ *
+ */
+
+#define CFG_PP 6
+#define CFG_CLOCK 3
+#define CFG_MIN_PP 1
+#define CFG_MIN_CLOCK 0
+
+/* fclk is 2550Mhz. */
+#define FCLK_DEV3 (6 << 9)		/*	850   Mhz  */
+#define FCLK_DEV4 (5 << 9)		/*	637.5 Mhz  */
+#define FCLK_DEV5 (7 << 9)		/*	510   Mhz  */
+#define FCLK_DEV7 (4 << 9)		/*	364.3 Mhz  */
+
+static u32 mali_dvfs_clk[] = {
+	FCLK_DEV7 | 1,     /* 182.1 Mhz */
+	FCLK_DEV4 | 1,     /* 318.7 Mhz */
+	FCLK_DEV3 | 1,     /* 425 Mhz */
+	FCLK_DEV5 | 0,     /* 510 Mhz */
+	FCLK_DEV4 | 0,     /* 637.5 Mhz */
+};
+
+static u32 mali_dvfs_clk_sample[] = {
+	182,     /* 182.1 Mhz */
+	319,     /* 318.7 Mhz */
+	425,     /* 425 Mhz */
+	510,     /* 510 Mhz */
+	637,     /* 637.5 Mhz */
+};
+
+static mali_dvfs_threshold_table mali_dvfs_table[]={
+		{ 0, 0, 3,  70, 180}, /* for 182.1  */
+		{ 1, 1, 3, 108, 205}, /* for 318.7  */
+		{ 2, 2, 3, 150, 215}, /* for 425.0  */
+		{ 3, 3, 3, 170, 253}, /* for 510.0  */
+		{ 4, 4, 3, 230, 256},  /* for 637.5  */
+		{ 0, 0, 3,   0,   0}
+};
+
+static void mali_plat_preheat(void);
+static mali_plat_info_t mali_plat_data = {
+	.cfg_pp = CFG_PP,  /* number of pp. */
+	.cfg_min_pp = CFG_MIN_PP,
+	.turbo_clock = 4, /* reserved clock src. */
+	.def_clock = 2, /* gpu clock used most of time.*/
+	.cfg_clock = CFG_CLOCK, /* max gpu clock. */
+	.cfg_min_clock = CFG_MIN_CLOCK,
+
+	.sc_mpp = 3, /* number of pp used most of time.*/
+	.bst_gpu = 210, /* threshold for boosting gpu. */
+	.bst_pp = 160, /* threshold for boosting PP. */
+
+	.clk = mali_dvfs_clk, /* clock source table. */
+	.clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
+	.clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
+	.have_switch = 1,
+
+	.dvfs_table = mali_dvfs_table, /* DVFS table. */
+	.dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
+
+	.scale_info = {
+		CFG_MIN_PP, /* minpp */
+		CFG_PP, /* maxpp, should be same as cfg_pp */
+		CFG_MIN_CLOCK, /* minclk */
+		CFG_CLOCK, /* maxclk should be same as cfg_clock */
+	},
+
+	.limit_on = 1,
+	.plat_preheat = mali_plat_preheat,
+};
+
+static void mali_plat_preheat(void)
+{
+	u32 pre_fs;
+	u32 clk, pp;
+
+	if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
+		return;
+
+	get_mali_rt_clkpp(&clk, &pp);
+	pre_fs = mali_plat_data.def_clock + 1;
+	if (clk < pre_fs)
+		clk = pre_fs;
+	if (pp < mali_plat_data.sc_mpp)
+		pp = mali_plat_data.sc_mpp;
+	set_mali_rt_clkpp(clk, pp, 1);
+}
+
+mali_plat_info_t* get_mali_plat_data(void) {
+	return &mali_plat_data;
+}
+
+int get_mali_freq_level(int freq)
+{
+	int i = 0, level = -1;
+	int mali_freq_num;
+
+	if(freq < 0)
+		return level;
+	mali_freq_num = mali_plat_data.dvfs_table_size - 1;
+	if(freq <= mali_plat_data.clk_sample[0])
+		level = mali_freq_num-1;
+	if(freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
+		level = 0;
+	for(i=0; i<mali_freq_num - 1 ;i++) {
+		if(freq >= mali_plat_data.clk_sample[i] && freq<=mali_plat_data.clk_sample[i + 1]) {
+			level = i;
+			level = mali_freq_num-level - 1;
+		}
+	}
+	return level;
+}
+
+unsigned int get_mali_max_level(void)
+{
+	return mali_plat_data.dvfs_table_size - 1;
+}
+
+static struct resource mali_gpu_resources[] =
+{
+	MALI_GPU_RESOURCES_MALI450_MP6_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU,
+				INT_MALI_PP0, INT_MALI_PP0_MMU,
+				INT_MALI_PP1, INT_MALI_PP1_MMU,
+				INT_MALI_PP2, INT_MALI_PP2_MMU,
+				INT_MALI_PP4, INT_MALI_PP4_MMU,
+				INT_MALI_PP5, INT_MALI_PP5_MMU,
+				INT_MALI_PP6, INT_MALI_PP6_MMU,
+				INT_MALI_PP)
+};
+
+static void set_limit_mali_freq(u32 idx)
+{
+	if (mali_plat_data.limit_on == 0)
+		return;
+	if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
+		return;
+	mali_plat_data.scale_info.maxclk= idx;
+	revise_mali_rt();
+}
+
+static u32 get_limit_mali_freq(void)
+{
+	return mali_plat_data.scale_info.maxclk;
+}
+
+static u32 set_limit_pp_num(u32 num)
+{
+	u32 ret = -1;
+	if (mali_plat_data.limit_on == 0)
+		goto quit;
+	if (num > mali_plat_data.cfg_pp ||
+				num < mali_plat_data.scale_info.minpp)
+		goto quit;
+	mali_plat_data.scale_info.maxpp = num;
+	revise_mali_rt();
+	ret = 0;
+quit:
+	return ret;
+}
+
+#ifdef CONFIG_AM_VDEC_H264_4K2K
+static u32 grd_pp_bk = CFG_PP;
+static void mali_4k2k_enter(void)
+{
+	if (mali_plat_data.limit_on == 0)
+		return;
+	grd_pp_bk = mali_plat_data.scale_info.maxpp;
+	set_limit_pp_num(mali_plat_data.scale_info.minpp);
+}
+
+static void mali_4k2k_exit(void)
+{
+	if (mali_plat_data.limit_on == 0)
+		return;
+	set_limit_pp_num(grd_pp_bk);
+}
+
+void vh264_4k2k_register_module_callback(void(*enter_func)(void), void(*remove_func)(void));
+#endif /* CONFIG_AM_VDEC_H264_4K2K */
+
+void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
+int mali_meson_init_start(struct platform_device* ptr_plt_dev)
+{
+	struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
+
+	/* for mali platform data. */
+	pdev->utilization_interval = 300,
+	pdev->utilization_callback = mali_gpu_utilization_callback,
+
+	/* for resource data. */
+	ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
+	ptr_plt_dev->resource = mali_gpu_resources;
+	return mali_clock_init(&mali_plat_data);
+}
+
+int mali_meson_init_finish(struct platform_device* ptr_plt_dev)
+{
+#ifdef CONFIG_GPU_THERMAL
+	int err;
+	struct gpufreq_cooling_device *gcdev = NULL;
+	struct gpucore_cooling_device *gccdev = NULL;
+#endif
+	if (mali_core_scaling_init(&mali_plat_data) < 0)
+		return -1;
+
+#ifdef CONFIG_GPU_THERMAL
+	gcdev = gpufreq_cooling_alloc();
+	register_gpu_freq_info(get_current_frequency);
+	if(IS_ERR(gcdev))
+		printk("malloc gpu cooling buffer error!!\n");
+	else if(!gcdev)
+		printk("system does not enable thermal driver\n");
+	else {
+		gcdev->get_gpu_freq_level = get_mali_freq_level;
+		gcdev->get_gpu_max_level = get_mali_max_level;
+		gcdev->set_gpu_freq_idx = set_limit_mali_freq;
+		gcdev->get_gpu_current_max_level = get_limit_mali_freq;
+		err = gpufreq_cooling_register(gcdev);
+		if(err < 0)
+			printk("register GPU  cooling error\n");
+		printk("gpu cooling register okay with err=%d\n",err);
+	}
+
+	gccdev=gpucore_cooling_alloc();
+	if(IS_ERR(gccdev))
+		printk("malloc gpu core cooling buffer error!!\n");
+	else if(!gccdev)
+		printk("system does not enable thermal driver\n");
+	else {
+		gccdev->max_gpu_core_num=mali_plat_data.cfg_pp;
+		gccdev->set_max_pp_num=set_limit_pp_num;
+		err = (int)gpucore_cooling_register(gccdev);
+		if(err < 0)
+			printk("register GPU  cooling error\n");
+		printk("gpu core cooling register okay with err=%d\n",err);
+	}
+#endif
+#ifdef CONFIG_AM_VDEC_H264_4K2K
+	vh264_4k2k_register_module_callback(mali_4k2k_enter, mali_4k2k_exit);
+#endif /* CONFIG_AM_VDEC_H264_4K2K */
+	return 0;
+}
+
+int mali_meson_uninit(struct platform_device* ptr_plt_dev)
+{
+	return 0;
+}
+
+static int mali_cri_light_suspend(size_t param)
+{
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->runtime_suspend)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_suspend(device);
+	}
+	mali_pmu_power_down_all(pmu);
+	return ret;
+}
+
+static int mali_cri_light_resume(size_t param)
+{
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	mali_pmu_power_up_all(pmu);
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->runtime_resume)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_resume(device);
+	}
+	return ret;
+}
+
+static int mali_cri_deep_suspend(size_t param)
+{
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->suspend)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->suspend(device);
+	}
+	mali_pmu_power_down_all(pmu);
+	return ret;
+}
+
+static int mali_cri_deep_resume(size_t param)
+{
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	mali_pmu_power_up_all(pmu);
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->resume)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->resume(device);
+	}
+	return ret;
+
+}
+
+int mali_light_suspend(struct device *device)
+{
+	int ret = 0;
+#ifdef CONFIG_MALI400_PROFILING
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+					MALI_PROFILING_EVENT_CHANNEL_GPU |
+					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+					0, 0,	0,	0,	0);
+#endif
+
+	/* clock scaling. Kasin..*/
+	ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
+
+	return ret;
+}
+
+int mali_light_resume(struct device *device)
+{
+	int ret = 0;
+
+	ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
+#ifdef CONFIG_MALI400_PROFILING
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+					MALI_PROFILING_EVENT_CHANNEL_GPU |
+					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+					get_current_frequency(), 0,	0,	0,	0);
+#endif
+	return ret;
+}
+
+int mali_deep_suspend(struct device *device)
+{
+	int ret = 0;
+	enable_clock();
+	flush_scaling_job();
+
+	/* clock scaling off. Kasin... */
+	ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
+	disable_clock();
+	return ret;
+}
+
+int mali_deep_resume(struct device *device)
+{
+	int ret = 0;
+
+	/* clock scaling up. Kasin.. */
+	enable_clock();
+	ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
+	return ret;
+
+}
+
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m6tvd.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m6tvd.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m6tvd.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m6tvd.c	2016-04-04 16:25:32.948527000 +0300
@@ -192,6 +192,3 @@
 
 }
 
-void mali_post_init(void)
-{
-}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m8b.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m8b.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m8b.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m8b.c	2016-04-04 16:25:32.968527000 +0300
@@ -38,431 +38,325 @@
 #define CFG_MIN_CLOCK 4
 
 /* fclk is 2550Mhz. */
-#define FCLK_DEV3 (6 << 9)      /*  850   Mhz  */
-#define FCLK_DEV4 (5 << 9)      /*  637.5 Mhz  */
-#define FCLK_DEV5 (7 << 9)      /*  510   Mhz  */
-#define FCLK_DEV7 (4 << 9)      /*  364.3 Mhz  */
+#define FCLK_DEV3 (6 << 9)		/*	850   Mhz  */
+#define FCLK_DEV4 (5 << 9)		/*	637.5 Mhz  */
+#define FCLK_DEV5 (7 << 9)		/*	510   Mhz  */
+#define FCLK_DEV7 (4 << 9)		/*	364.3 Mhz  */
 
 static u32 mali_dvfs_clk[] = {
-    FCLK_DEV5 | 1,     /* 255 Mhz */
-    FCLK_DEV7 | 0,     /* 364 Mhz */
-    FCLK_DEV3 | 1,     /* 425 Mhz */
-    FCLK_DEV5 | 0,     /* 510 Mhz */
-    FCLK_DEV4 | 0,     /* 637.5 Mhz */
+	FCLK_DEV5 | 1,     /* 255 Mhz */
+	FCLK_DEV7 | 0,     /* 364 Mhz */
+	FCLK_DEV3 | 1,     /* 425 Mhz */
+	FCLK_DEV5 | 0,     /* 510 Mhz */
+	FCLK_DEV4 | 0,     /* 637.5 Mhz */
 };
 
 static u32 mali_dvfs_clk_sample[] = {
-    255,     /* 182.1 Mhz */
-    364,     /* 318.7 Mhz */
-    425,     /* 425 Mhz */
-    510,     /* 510 Mhz */
-    637,     /* 637.5 Mhz */
+	255,     /* 182.1 Mhz */
+	364,     /* 318.7 Mhz */
+	425,     /* 425 Mhz */
+	510,     /* 510 Mhz */
+	637,     /* 637.5 Mhz */
 };
 
-//////////////////////////////////////
-//for dvfs
-struct mali_gpu_clk_item  meson_gpu_clk[]  = {
-    {255,  1150},   /* 182.1 Mhz, 1150mV */
-    {364,  1150},   /* 318.7 Mhz */
-    {425,  1150},   /* 425 Mhz */
-    {510,  1150},   /* 510 Mhz */
-    {637,  1150},   /* 637.5 Mhz */
-};
-struct mali_gpu_clock meson_gpu_clk_info = {
-    .item = meson_gpu_clk,
-    .num_of_steps = ARRAY_SIZE(meson_gpu_clk),
-};
-static int cur_gpu_clk_index = 0;
-//////////////////////////////////////
-
 static mali_dvfs_threshold_table mali_dvfs_table[]={
-    { 0, 0, 5, 30 , 180}, /* for 255  */
-    { 1, 1, 5, 152, 205}, /* for 364  */
-    { 2, 2, 5, 180, 212}, /* for 425  */
-    { 3, 3, 5, 205, 236}, /* for 510  */
-    { 4, 4, 5, 230, 255}, /* for 637  */
-    { 0, 0, 5,   0,   0}
+		{ 0, 0, 5, 0  , 180}, /* for 255  */
+		{ 1, 1, 5, 152, 205}, /* for 364  */
+		{ 2, 2, 5, 180, 212}, /* for 425  */
+		{ 3, 3, 5, 205, 236}, /* for 510  */
+		{ 4, 4, 5, 230, 256}, /* for 637  */
+		{ 0, 0, 5,   0,   0}
 };
 
 static void mali_plat_preheat(void);
 static mali_plat_info_t mali_plat_data = {
-    .cfg_pp = CFG_PP,  /* number of pp. */
-    .cfg_min_pp = CFG_MIN_PP,
-    .turbo_clock = 4, /* reserved clock src. */
-    .def_clock = 2, /* gpu clock used most of time.*/
-    .cfg_clock = CFG_CLOCK, /* max gpu clock. */
-    .cfg_clock_bkup = CFG_CLOCK,
-    .cfg_min_clock = CFG_MIN_CLOCK,
+	.cfg_pp = CFG_PP,  /* number of pp. */
+	.cfg_min_pp = CFG_MIN_PP,
+	.turbo_clock = 4, /* reserved clock src. */
+	.def_clock = 2, /* gpu clock used most of time.*/
+	.cfg_clock = CFG_CLOCK, /* max gpu clock. */
+	.cfg_clock_bkup = CFG_CLOCK,
+	.cfg_min_clock = CFG_MIN_CLOCK,
 
-    .sc_mpp = 2, /* number of pp used most of time.*/
+	.sc_mpp = 2, /* number of pp used most of time.*/
 	.bst_gpu = 1, /* threshold for boosting gpu. */
 	.bst_pp = 1, /* threshold for boosting PP. */
 
-    .clk = mali_dvfs_clk, /* clock source table. */
-    .clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
-    .clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
-    .have_switch = 1,
-
-    .dvfs_table = mali_dvfs_table, /* DVFS table. */
-    .dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
-
-    .scale_info = {
-        CFG_MIN_PP, /* minpp */
-        CFG_PP, /* maxpp, should be same as cfg_pp */
-        CFG_MIN_CLOCK, /* minclk */
-        CFG_CLOCK, /* maxclk should be same as cfg_clock */
-    },
+	.clk = mali_dvfs_clk, /* clock source table. */
+	.clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
+	.clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
+	.have_switch = 1,
+
+	.dvfs_table = mali_dvfs_table, /* DVFS table. */
+	.dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
+
+	.scale_info = {
+		CFG_MIN_PP, /* minpp */
+		CFG_PP, /* maxpp, should be same as cfg_pp */
+		CFG_MIN_CLOCK, /* minclk */
+		CFG_CLOCK, /* maxclk should be same as cfg_clock */
+	},
 
-    .limit_on = 1,
-    .plat_preheat = mali_plat_preheat,
+	.limit_on = 0,
+	.plat_preheat = mali_plat_preheat,
 };
 
 static void mali_plat_preheat(void)
 {
-#ifndef CONFIG_MALI_DVFS
-    u32 pre_fs;
-    u32 clk, pp;
-
-    if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
-        return;
-
-    get_mali_rt_clkpp(&clk, &pp);
-    pre_fs = mali_plat_data.def_clock + 1;
-    if (clk < pre_fs)
-        clk = pre_fs;
-    if (pp < mali_plat_data.sc_mpp)
-        pp = mali_plat_data.sc_mpp;
-    set_mali_rt_clkpp(clk, pp, 1);
-#endif
+	u32 pre_fs;
+	u32 clk, pp;
+
+	if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
+		return;
+
+	get_mali_rt_clkpp(&clk, &pp);
+	pre_fs = mali_plat_data.def_clock + 1;
+	if (clk < pre_fs)
+		clk = pre_fs;
+	if (pp < mali_plat_data.sc_mpp)
+		pp = mali_plat_data.sc_mpp;
+	set_mali_rt_clkpp(clk, pp, 1);
 }
 
 mali_plat_info_t* get_mali_plat_data(void) {
-    return &mali_plat_data;
+	return &mali_plat_data;
 }
 
 int get_mali_freq_level(int freq)
 {
-    int i = 0, level = -1;
-    int mali_freq_num;
+	int i = 0, level = -1;
+	int mali_freq_num;
 
-    if (freq < 0)
-        return level;
-    mali_freq_num = mali_plat_data.dvfs_table_size - 1;
-    if (freq <= mali_plat_data.clk_sample[0])
-        level = mali_freq_num-1;
-    if (freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
-        level = 0;
-    for (i=0; i<mali_freq_num - 1 ;i++) {
-        if (freq >= mali_plat_data.clk_sample[i] && freq <= mali_plat_data.clk_sample[i + 1]) {
-            level = i;
-            level = mali_freq_num-level - 1;
-        }
-    }
-    return level;
+	if(freq < 0)
+		return level;
+	mali_freq_num = mali_plat_data.dvfs_table_size - 1;
+	if(freq <= mali_plat_data.clk_sample[0])
+		level = mali_freq_num-1;
+	if(freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
+		level = 0;
+	for(i=0; i<mali_freq_num - 1 ;i++) {
+		if(freq >= mali_plat_data.clk_sample[i] && freq<=mali_plat_data.clk_sample[i + 1]) {
+			level = i;
+			level = mali_freq_num-level - 1;
+		}
+	}
+	return level;
 }
 
 unsigned int get_mali_max_level(void)
 {
-    return mali_plat_data.dvfs_table_size - 1;
+	return mali_plat_data.dvfs_table_size - 1;
 }
 
 static struct resource mali_gpu_resources[] =
 {
-    MALI_GPU_RESOURCES_MALI450_MP2_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU,
-            INT_MALI_PP0, INT_MALI_PP0_MMU,
-            INT_MALI_PP1, INT_MALI_PP1_MMU,
-            INT_MALI_PP)
+	MALI_GPU_RESOURCES_MALI450_MP2_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU, 
+				INT_MALI_PP0, INT_MALI_PP0_MMU,
+				INT_MALI_PP1, INT_MALI_PP1_MMU,
+				INT_MALI_PP)
 };
 
 static void set_limit_mali_freq(u32 idx)
 {
-    if (mali_plat_data.limit_on == 0)
-        return;
-    if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
-        return;
-    mali_plat_data.scale_info.maxclk= idx;
-
-    revise_mali_rt();
+	if (mali_plat_data.limit_on == 0)
+		return;
+	if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
+		return;
+	mali_plat_data.scale_info.maxclk= idx;
+	revise_mali_rt();
 }
 
 static u32 get_limit_mali_freq(void)
 {
-    return mali_plat_data.scale_info.maxclk;
-}
-
-static u32 set_limit_pp_num(u32 num)
-{
-    u32 ret = -1;
-    if (mali_plat_data.limit_on == 0)
-        goto quit;
-    if (num > mali_plat_data.cfg_pp ||
-            num < mali_plat_data.scale_info.minpp)
-        goto quit;
-    mali_plat_data.scale_info.maxpp = num;
-    revise_mali_rt();
-    ret = 0;
-quit:
-    return ret;
+	return mali_plat_data.scale_info.maxclk;
 }
 
 void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
-
-#if 0
-struct mali_gpu_clk_item {
-    unsigned int clock; /* unit(MHz) */
-    unsigned int vol;
-};
-
-struct mali_gpu_clock {
-    struct mali_gpu_clk_item *item;
-    unsigned int num_of_steps;
-};
-#endif
-
-/* Function that platfrom report it's clock info which driver can set, needed when CONFIG_MALI_DVFS enabled */
-void meson_platform_get_clock_info(struct mali_gpu_clock **data) {
-    *data = &meson_gpu_clk_info;
-}
-
-/* Function that get the current clock info, needed when CONFIG_MALI_DVFS enabled */
-int meson_platform_get_freq(void) {
-    printk("get cur_gpu_clk_index =%d\n", cur_gpu_clk_index);
-    return  cur_gpu_clk_index;
-}
-
-/* Fuction that platform callback for freq setting, needed when CONFIG_MALI_DVFS enabled */
-int meson_platform_set_freq(int setting_clock_step) {
-
-    if (cur_gpu_clk_index == setting_clock_step) {
-        return 0;
-    }
-
-    mali_clock_set(setting_clock_step);
-
-    cur_gpu_clk_index = setting_clock_step;
-    printk("set cur_gpu_clk_index =%d\n", cur_gpu_clk_index);
-
-    return 0;
-}
 int mali_meson_init_start(struct platform_device* ptr_plt_dev)
 {
-    struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
+	struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
 
+	/* for mali platform data. */
+	pdev->utilization_callback = mali_gpu_utilization_callback,
 
-    /* for resource data. */
-    ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
-    ptr_plt_dev->resource = mali_gpu_resources;
-
-    /*for dvfs*/
-#ifndef CONFIG_MALI_DVFS
-    /* for mali platform data. */
-    pdev->control_interval = 200;
-    pdev->utilization_callback = mali_gpu_utilization_callback;
-#else
-    pdev->get_clock_info = meson_platform_get_clock_info;
-    pdev->get_freq = meson_platform_get_freq;
-    pdev->set_freq = meson_platform_set_freq;
-#endif
-
-    return mali_clock_init(&mali_plat_data);
+	/* for resource data. */
+	ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
+	ptr_plt_dev->resource = mali_gpu_resources;
+	return mali_clock_init(&mali_plat_data);
 }
 
 int mali_meson_init_finish(struct platform_device* ptr_plt_dev)
 {
-#ifndef CONFIG_MALI_DVFS
-    if (mali_core_scaling_init(&mali_plat_data) < 0)
-        return -1;
+#ifdef CONFIG_GPU_THERMAL
+	int err;
+	struct gpufreq_cooling_device *gcdev = NULL;
+#endif
+	if (mali_core_scaling_init(&mali_plat_data) < 0)
+		return -1;
+
+#ifdef CONFIG_GPU_THERMAL
+	gcdev = gpufreq_cooling_alloc();
+	if(IS_ERR(gcdev))
+		printk("malloc gpu cooling buffer error!!\n");
+	else if(!gcdev)
+		printk("system does not enable thermal driver\n");
+	else {
+		gcdev->get_gpu_freq_level = get_mali_freq_level;
+		gcdev->get_gpu_max_level = get_mali_max_level;
+		gcdev->set_gpu_freq_idx = set_limit_mali_freq;
+		gcdev->get_gpu_current_max_level = get_limit_mali_freq;
+		err = gpufreq_cooling_register(gcdev);
+		if(err < 0)
+			printk("register GPU  cooling error\n");
+		printk("gpu cooling register okay with err=%d\n",err);
+	}
+
 #endif
-    return 0;
+	return 0;
 }
 
 int mali_meson_uninit(struct platform_device* ptr_plt_dev)
 {
-    return 0;
+	return 0;
 }
 
 static int mali_cri_light_suspend(size_t param)
 {
-    int ret;
-    struct device *device;
-    struct mali_pmu_core *pmu;
-
-    ret = 0;
-    mali_pm_statue = 1;
-    device = (struct device *)param;
-    pmu = mali_pmu_get_global_pmu_core();
-
-    if (NULL != device->driver &&
-            NULL != device->driver->pm &&
-            NULL != device->driver->pm->runtime_suspend)
-    {
-        /* Need to notify Mali driver about this event */
-        ret = device->driver->pm->runtime_suspend(device);
-    }
-    mali_pmu_power_down_all(pmu);
-    return ret;
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	mali_pm_statue = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->runtime_suspend)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_suspend(device);
+	}
+	//mali_pmu_power_down_all(pmu);
+	return ret;
 }
 
 static int mali_cri_light_resume(size_t param)
 {
-    int ret;
-    struct device *device;
-    struct mali_pmu_core *pmu;
-
-    ret = 0;
-    device = (struct device *)param;
-    pmu = mali_pmu_get_global_pmu_core();
-
-    mali_pmu_power_up_all(pmu);
-    if (NULL != device->driver &&
-            NULL != device->driver->pm &&
-            NULL != device->driver->pm->runtime_resume)
-    {
-        /* Need to notify Mali driver about this event */
-        ret = device->driver->pm->runtime_resume(device);
-    }
-    mali_pm_statue = 0;
-    return ret;
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	//mali_pmu_power_up_all(pmu);
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->runtime_resume)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_resume(device);
+	}
+	mali_pm_statue = 1;
+	return ret;
 }
 
 static int mali_cri_deep_suspend(size_t param)
 {
-    int ret;
-    struct device *device;
-    struct mali_pmu_core *pmu;
-
-    ret = 0;
-    device = (struct device *)param;
-    pmu = mali_pmu_get_global_pmu_core();
-
-    if (NULL != device->driver &&
-            NULL != device->driver->pm &&
-            NULL != device->driver->pm->suspend)
-    {
-        /* Need to notify Mali driver about this event */
-        ret = device->driver->pm->suspend(device);
-    }
-    mali_pmu_power_down_all(pmu);
-    return ret;
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->suspend)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->suspend(device);
+	}
+	mali_pmu_power_down_all(pmu);
+	return ret;
 }
 
 static int mali_cri_deep_resume(size_t param)
 {
-    int ret;
-    struct device *device;
-    struct mali_pmu_core *pmu;
-
-    ret = 0;
-    device = (struct device *)param;
-    pmu = mali_pmu_get_global_pmu_core();
-
-    mali_pmu_power_up_all(pmu);
-    if (NULL != device->driver &&
-            NULL != device->driver->pm &&
-            NULL != device->driver->pm->resume)
-    {
-        /* Need to notify Mali driver about this event */
-        ret = device->driver->pm->resume(device);
-    }
-    return ret;
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	mali_pmu_power_up_all(pmu);
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->resume)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->resume(device);
+	}
+	return ret;
 
 }
 
 int mali_light_suspend(struct device *device)
 {
-    int ret = 0;
+	int ret = 0;
 #ifdef CONFIG_MALI400_PROFILING
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-            MALI_PROFILING_EVENT_CHANNEL_GPU |
-            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-            0, 0, 0, 0, 0);
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+					MALI_PROFILING_EVENT_CHANNEL_GPU |
+					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+					0, 0,	0,	0,	0);
 #endif
 
-    /* clock scaling. Kasin..*/
-    ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
-    disable_clock();
-    return ret;
+	/* clock scaling. Kasin..*/
+	ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
+	disable_clock();
+	return ret;
 }
 
 int mali_light_resume(struct device *device)
 {
-    int ret = 0;
-    enable_clock();
-    ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
+	int ret = 0;
+	enable_clock();
+	ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
 #ifdef CONFIG_MALI400_PROFILING
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-            MALI_PROFILING_EVENT_CHANNEL_GPU |
-            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-            get_current_frequency(), 0, 0, 0, 0);
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+					MALI_PROFILING_EVENT_CHANNEL_GPU |
+					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+					get_current_frequency(), 0,	0,	0,	0);
 #endif
-    return ret;
+	return ret;
 }
 
 int mali_deep_suspend(struct device *device)
 {
-    int ret = 0;
-    struct mali_pmu_core *pmu;
-
-    mali_pm_statue = 1;
-    pmu = mali_pmu_get_global_pmu_core();
-    enable_clock();
-#ifndef CONFIG_MALI_DVFS
-    flush_scaling_job();
-#endif
-
-    /* clock scaling off. Kasin... */
-    ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
-    disable_clock();
-    return ret;
+	int ret = 0;
+	enable_clock();
+	flush_scaling_job();
+
+	/* clock scaling off. Kasin... */
+	ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
+	disable_clock();
+	return ret;
 }
 
 int mali_deep_resume(struct device *device)
 {
-    int ret = 0;
+	int ret = 0;
 
-    /* clock scaling up. Kasin.. */
-    enable_clock();
-    ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
-    mali_pm_statue = 0;
-    return ret;
-}
+	/* clock scaling up. Kasin.. */
+	enable_clock();
+	ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
+	return ret;
 
-void mali_post_init(void)
-{
-#ifdef CONFIG_GPU_THERMAL
-    int err;
-    struct gpufreq_cooling_device *gcdev = NULL;
-    struct gpucore_cooling_device *gccdev = NULL;
-
-    gcdev = gpufreq_cooling_alloc();
-    register_gpu_freq_info(get_current_frequency);
-    if (IS_ERR(gcdev))
-        printk("malloc gpu cooling buffer error!!\n");
-    else if (!gcdev)
-        printk("system does not enable thermal driver\n");
-    else {
-        gcdev->get_gpu_freq_level = get_mali_freq_level;
-        gcdev->get_gpu_max_level = get_mali_max_level;
-        gcdev->set_gpu_freq_idx = set_limit_mali_freq;
-        gcdev->get_gpu_current_max_level = get_limit_mali_freq;
-        err = gpufreq_cooling_register(gcdev);
-        if (err < 0)
-            printk("register GPU  cooling error\n");
-        printk("gpu cooling register okay with err=%d\n",err);
-    }
-
-    gccdev = gpucore_cooling_alloc();
-    if (IS_ERR(gccdev))
-        printk("malloc gpu core cooling buffer error!!\n");
-    else if (!gccdev)
-        printk("system does not enable thermal driver\n");
-    else {
-        gccdev->max_gpu_core_num=mali_plat_data.cfg_pp;
-        gccdev->set_max_pp_num=set_limit_pp_num;
-        err = (int)gpucore_cooling_register(gccdev);
-        if (err < 0)
-            printk("register GPU  cooling error\n");
-        printk("gpu core cooling register okay with err=%d\n",err);
-    }
-#endif
 }
+
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m8.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m8.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m8.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/platform_m8.c	2016-04-04 16:25:32.958527000 +0300
@@ -38,441 +38,391 @@
 #define CFG_MIN_CLOCK 0
 
 /* fclk is 2550Mhz. */
-#define FCLK_DEV3 (6 << 9)      /*  850   Mhz  */
-#define FCLK_DEV4 (5 << 9)      /*  637.5 Mhz  */
-#define FCLK_DEV5 (7 << 9)      /*  510   Mhz  */
-#define FCLK_DEV7 (4 << 9)      /*  364.3 Mhz  */
+#define FCLK_DEV3 (6 << 9)		/*	850   Mhz  */
+#define FCLK_DEV4 (5 << 9)		/*	637.5 Mhz  */
+#define FCLK_DEV5 (7 << 9)		/*	510   Mhz  */
+#define FCLK_DEV7 (4 << 9)		/*	364.3 Mhz  */
 
 static u32 mali_dvfs_clk[] = {
-    FCLK_DEV7 | 1,     /* 182.1 Mhz */
-    FCLK_DEV4 | 1,     /* 318.7 Mhz */
-    FCLK_DEV3 | 1,     /* 425 Mhz */
-    FCLK_DEV5 | 0,     /* 510 Mhz */
-    FCLK_DEV4 | 0,     /* 637.5 Mhz */
+	FCLK_DEV7 | 1,     /* 182.1 Mhz */
+	FCLK_DEV4 | 1,     /* 318.7 Mhz */
+	FCLK_DEV3 | 1,     /* 425 Mhz */
+	FCLK_DEV5 | 0,     /* 510 Mhz */
+	FCLK_DEV4 | 0,     /* 637.5 Mhz */
 };
 
 static u32 mali_dvfs_clk_sample[] = {
-    182,     /* 182.1 Mhz */
-    319,     /* 318.7 Mhz */
-    425,     /* 425 Mhz */
-    510,     /* 510 Mhz */
-    637,     /* 637.5 Mhz */
+	182,     /* 182.1 Mhz */
+	319,     /* 318.7 Mhz */
+	425,     /* 425 Mhz */
+	510,     /* 510 Mhz */
+	637,     /* 637.5 Mhz */
 };
-//////////////////////////////////////
-//for dvfs
-struct mali_gpu_clk_item  meson_gpu_clk[]  = {
-    {182,  1150},   /* 182.1 Mhz, 1150mV */
-    {319,  1150},   /* 318.7 Mhz */
-    {425,  1150},   /* 425 Mhz */
-    {510,  1150},   /* 510 Mhz */
-    {637,  1150},   /* 637.5 Mhz */
-};
-struct mali_gpu_clock meson_gpu_clk_info = {
-    .item = meson_gpu_clk,
-    .num_of_steps = ARRAY_SIZE(meson_gpu_clk),
-};
-static int cur_gpu_clk_index = 0;
-//////////////////////////////////////
+
 static mali_dvfs_threshold_table mali_dvfs_table[]={
-    { 0, 0, 3,  30,  80}, /* for 182.1  */
-    { 1, 1, 3,  40, 205}, /* for 318.7  */
-    { 2, 2, 3, 150, 215}, /* for 425.0  */
-    { 3, 3, 3, 170, 253}, /* for 510.0  */
-    { 4, 4, 3, 230, 255},  /* for 637.5  */
-    { 0, 0, 3,   0,   0}
+		{ 0, 0, 3,  70, 180}, /* for 182.1  */
+		{ 1, 1, 3, 108, 205}, /* for 318.7  */
+		{ 2, 2, 3, 150, 215}, /* for 425.0  */
+		{ 3, 3, 3, 170, 253}, /* for 510.0  */
+		{ 4, 4, 3, 230, 256},  /* for 637.5  */
+		{ 0, 0, 3,   0,   0}
 };
 
 static void mali_plat_preheat(void);
 static mali_plat_info_t mali_plat_data = {
-    .cfg_pp = CFG_PP,  /* number of pp. */
-    .cfg_min_pp = CFG_MIN_PP,
-    .turbo_clock = 4, /* reserved clock src. */
-    .def_clock = 2, /* gpu clock used most of time.*/
-    .cfg_clock = CFG_CLOCK, /* max gpu clock. */
-    .cfg_clock_bkup = CFG_CLOCK,
-    .cfg_min_clock = CFG_MIN_CLOCK,
-
-    .sc_mpp = 3, /* number of pp used most of time.*/
-    .bst_gpu = 210, /* threshold for boosting gpu. */
-    .bst_pp = 160, /* threshold for boosting PP. */
-
-    .clk = mali_dvfs_clk, /* clock source table. */
-    .clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
-    .clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
-    .have_switch = 1,
-
-    .dvfs_table = mali_dvfs_table, /* DVFS table. */
-    .dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
-
-    .scale_info = {
-        CFG_MIN_PP, /* minpp */
-        CFG_PP, /* maxpp, should be same as cfg_pp */
-        CFG_MIN_CLOCK, /* minclk */
-        CFG_CLOCK, /* maxclk should be same as cfg_clock */
-    },
+	.cfg_pp = CFG_PP,  /* number of pp. */
+	.cfg_min_pp = CFG_MIN_PP,
+	.turbo_clock = 4, /* reserved clock src. */
+	.def_clock = 2, /* gpu clock used most of time.*/
+	.cfg_clock = CFG_CLOCK, /* max gpu clock. */
+	.cfg_clock_bkup = CFG_CLOCK,
+	.cfg_min_clock = CFG_MIN_CLOCK,
+
+	.sc_mpp = 3, /* number of pp used most of time.*/
+	.bst_gpu = 210, /* threshold for boosting gpu. */
+	.bst_pp = 160, /* threshold for boosting PP. */
+
+	.clk = mali_dvfs_clk, /* clock source table. */
+	.clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
+	.clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
+	.have_switch = 1,
+
+	.dvfs_table = mali_dvfs_table, /* DVFS table. */
+	.dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
+
+	.scale_info = {
+		CFG_MIN_PP, /* minpp */
+		CFG_PP, /* maxpp, should be same as cfg_pp */
+		CFG_MIN_CLOCK, /* minclk */
+		CFG_CLOCK, /* maxclk should be same as cfg_clock */
+	},
 
-    .limit_on = 1,
-    .plat_preheat = mali_plat_preheat,
+	.limit_on = 1,
+	.plat_preheat = mali_plat_preheat,
 };
 
 static void mali_plat_preheat(void)
 {
-#ifndef CONFIG_MALI_DVFS
-    u32 pre_fs;
-    u32 clk, pp;
-
-    if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
-        return;
-
-    get_mali_rt_clkpp(&clk, &pp);
-    pre_fs = mali_plat_data.def_clock + 1;
-    if (clk < pre_fs)
-        clk = pre_fs;
-    if (pp < mali_plat_data.sc_mpp)
-        pp = mali_plat_data.sc_mpp;
-    set_mali_rt_clkpp(clk, pp, 1);
-#endif
+	u32 pre_fs;
+	u32 clk, pp;
+
+	if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
+		return;
+
+	get_mali_rt_clkpp(&clk, &pp);
+	pre_fs = mali_plat_data.def_clock + 1;
+	if (clk < pre_fs)
+		clk = pre_fs;
+	if (pp < mali_plat_data.sc_mpp)
+		pp = mali_plat_data.sc_mpp;
+	set_mali_rt_clkpp(clk, pp, 1);
 }
 
 mali_plat_info_t* get_mali_plat_data(void) {
-    return &mali_plat_data;
+	return &mali_plat_data;
 }
 
 int get_mali_freq_level(int freq)
 {
-    int i = 0, level = -1;
-    int mali_freq_num;
-
-    if (freq < 0)
-        return level;
+	int i = 0, level = -1;
+	int mali_freq_num;
 
-    mali_freq_num = mali_plat_data.dvfs_table_size - 1;
-    if (freq <= mali_plat_data.clk_sample[0])
-        level = mali_freq_num-1;
-    if (freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
-        level = 0;
-    for (i=0; i<mali_freq_num - 1 ;i++) {
-        if (freq >= mali_plat_data.clk_sample[i] && freq <= mali_plat_data.clk_sample[i + 1]) {
-            level = i;
-            level = mali_freq_num-level - 1;
-        }
-    }
-    return level;
+	if(freq < 0)
+		return level;
+	mali_freq_num = mali_plat_data.dvfs_table_size - 1;
+	if(freq <= mali_plat_data.clk_sample[0])
+		level = mali_freq_num-1;
+	if(freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
+		level = 0;
+	for(i=0; i<mali_freq_num - 1 ;i++) {
+		if(freq >= mali_plat_data.clk_sample[i] && freq<=mali_plat_data.clk_sample[i + 1]) {
+			level = i;
+			level = mali_freq_num-level - 1;
+		}
+	}
+	return level;
 }
 
 unsigned int get_mali_max_level(void)
 {
-    return mali_plat_data.dvfs_table_size - 1;
+	return mali_plat_data.dvfs_table_size - 1;
 }
 
 static struct resource mali_gpu_resources[] =
 {
-    MALI_GPU_RESOURCES_MALI450_MP6_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU,
-            INT_MALI_PP0, INT_MALI_PP0_MMU,
-            INT_MALI_PP1, INT_MALI_PP1_MMU,
-            INT_MALI_PP2, INT_MALI_PP2_MMU,
-            INT_MALI_PP4, INT_MALI_PP4_MMU,
-            INT_MALI_PP5, INT_MALI_PP5_MMU,
-            INT_MALI_PP6, INT_MALI_PP6_MMU,
-            INT_MALI_PP)
+	MALI_GPU_RESOURCES_MALI450_MP6_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU,
+				INT_MALI_PP0, INT_MALI_PP0_MMU,
+				INT_MALI_PP1, INT_MALI_PP1_MMU,
+				INT_MALI_PP2, INT_MALI_PP2_MMU,
+				INT_MALI_PP4, INT_MALI_PP4_MMU,
+				INT_MALI_PP5, INT_MALI_PP5_MMU,
+				INT_MALI_PP6, INT_MALI_PP6_MMU,
+				INT_MALI_PP)
 };
 
 static void set_limit_mali_freq(u32 idx)
 {
-    if (mali_plat_data.limit_on == 0)
-        return;
-    if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
-        return;
-    mali_plat_data.scale_info.maxclk= idx;
-    revise_mali_rt();
+	if (mali_plat_data.limit_on == 0)
+		return;
+	if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
+		return;
+	mali_plat_data.scale_info.maxclk= idx;
+	revise_mali_rt();
 }
 
 static u32 get_limit_mali_freq(void)
 {
-    return mali_plat_data.scale_info.maxclk;
+	return mali_plat_data.scale_info.maxclk;
 }
 
 static u32 set_limit_pp_num(u32 num)
 {
-    u32 ret = -1;
-    if (mali_plat_data.limit_on == 0)
-        goto quit;
-    if (num > mali_plat_data.cfg_pp ||
-            num < mali_plat_data.scale_info.minpp)
-        goto quit;
-    mali_plat_data.scale_info.maxpp = num;
-    revise_mali_rt();
-    ret = 0;
+	u32 ret = -1;
+	if (mali_plat_data.limit_on == 0)
+		goto quit;
+	if (num > mali_plat_data.cfg_pp ||
+				num < mali_plat_data.scale_info.minpp)
+		goto quit;
+	mali_plat_data.scale_info.maxpp = num;
+	revise_mali_rt();
+	ret = 0;
 quit:
-    return ret;
+	return ret;
 }
 
-void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
-
-#if 0
-struct mali_gpu_clk_item {
-    unsigned int clock; /* unit(MHz) */
-    unsigned int vol;
-};
-
-struct mali_gpu_clock {
-    struct mali_gpu_clk_item *item;
-    unsigned int num_of_steps;
-};
-#endif
-
-/* Function that platfrom report it's clock info which driver can set, needed when CONFIG_MALI_DVFS enabled */
-void meson_platform_get_clock_info(struct mali_gpu_clock **data) {
-    *data = &meson_gpu_clk_info;
+#ifdef CONFIG_AM_VDEC_H264_4K2K
+static u32 grd_pp_bk = CFG_PP;
+static void mali_4k2k_enter(void)
+{
+	if (mali_plat_data.limit_on == 0)
+		return;
+	grd_pp_bk = mali_plat_data.scale_info.maxpp;
+	set_limit_pp_num(mali_plat_data.scale_info.minpp);
 }
 
-/* Function that get the current clock info, needed when CONFIG_MALI_DVFS enabled */
-int meson_platform_get_freq(void) {
-    printk("get cur_gpu_clk_index =%d\n", cur_gpu_clk_index);
-    return  cur_gpu_clk_index;
+static void mali_4k2k_exit(void)
+{
+	if (mali_plat_data.limit_on == 0)
+		return;
+	set_limit_pp_num(grd_pp_bk);
 }
 
-/* Fuction that platform callback for freq setting, needed when CONFIG_MALI_DVFS enabled */
-int meson_platform_set_freq(int setting_clock_step) {
-
-    if (cur_gpu_clk_index == setting_clock_step) {
-        return 0;
-    }
-
-    mali_clock_set(setting_clock_step);
-
-    cur_gpu_clk_index = setting_clock_step;
-    printk("set cur_gpu_clk_index =%d\n", cur_gpu_clk_index);
-
-    return 0;
-}
+void vh264_4k2k_register_module_callback(void(*enter_func)(void), void(*remove_func)(void));
+#endif /* CONFIG_AM_VDEC_H264_4K2K */
 
+void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
 int mali_meson_init_start(struct platform_device* ptr_plt_dev)
 {
-    struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
+	struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
 
-    /* chip mark detect. */
-#ifdef IS_MESON_M8_CPU
-    if (IS_MESON_M8_CPU) {
-        mali_plat_data.have_switch = 0;
-    }
-#endif
+	/* chip mark detect. */
 
-    /* for resource data. */
-    ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
-    ptr_plt_dev->resource = mali_gpu_resources;
-
-    /*for dvfs*/
-#ifndef CONFIG_MALI_DVFS
-    /* for mali platform data. */
-    pdev->control_interval = 300;
-    pdev->utilization_callback = mali_gpu_utilization_callback;
-#else
-    pdev->get_clock_info = meson_platform_get_clock_info;
-    pdev->get_freq = meson_platform_get_freq;
-    pdev->set_freq = meson_platform_set_freq;
+#ifdef IS_MESON_M8_CPU
+	if(IS_MESON_M8_CPU) {
+		mali_plat_data.have_switch = 0;
+	}
 #endif
 
-    return mali_clock_init(&mali_plat_data);
+	/* for mali platform data. */
+	pdev->utilization_interval = 300,
+	pdev->utilization_callback = mali_gpu_utilization_callback,
+
+	/* for resource data. */
+	ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
+	ptr_plt_dev->resource = mali_gpu_resources;
+	return mali_clock_init(&mali_plat_data);
 }
 
 int mali_meson_init_finish(struct platform_device* ptr_plt_dev)
 {
-#ifndef CONFIG_MALI_DVFS
-    if (mali_core_scaling_init(&mali_plat_data) < 0)
-        return -1;
-#else
-    printk("disable meson own dvfs\n");
+#ifdef CONFIG_GPU_THERMAL
+	int err;
+	struct gpufreq_cooling_device *gcdev = NULL;
+	struct gpucore_cooling_device *gccdev = NULL;
+#endif
+	if (mali_core_scaling_init(&mali_plat_data) < 0)
+		return -1;
+
+#ifdef CONFIG_GPU_THERMAL
+	gcdev = gpufreq_cooling_alloc();
+	register_gpu_freq_info(get_current_frequency);
+	if(IS_ERR(gcdev))
+		printk("malloc gpu cooling buffer error!!\n");
+	else if(!gcdev)
+		printk("system does not enable thermal driver\n");
+	else {
+		gcdev->get_gpu_freq_level = get_mali_freq_level;
+		gcdev->get_gpu_max_level = get_mali_max_level;
+		gcdev->set_gpu_freq_idx = set_limit_mali_freq;
+		gcdev->get_gpu_current_max_level = get_limit_mali_freq;
+		err = gpufreq_cooling_register(gcdev);
+		if(err < 0)
+			printk("register GPU  cooling error\n");
+		printk("gpu cooling register okay with err=%d\n",err);
+	}
+
+	gccdev=gpucore_cooling_alloc();
+	if(IS_ERR(gccdev))
+		printk("malloc gpu core cooling buffer error!!\n");
+	else if(!gccdev)
+		printk("system does not enable thermal driver\n");
+	else {
+		gccdev->max_gpu_core_num=mali_plat_data.cfg_pp;
+		gccdev->set_max_pp_num=set_limit_pp_num;
+		err = (int)gpucore_cooling_register(gccdev);
+		if(err < 0)
+			printk("register GPU  cooling error\n");
+		printk("gpu core cooling register okay with err=%d\n",err);
+	}
 #endif
-    return 0;
+#ifdef CONFIG_AM_VDEC_H264_4K2K
+	vh264_4k2k_register_module_callback(mali_4k2k_enter, mali_4k2k_exit);
+#endif /* CONFIG_AM_VDEC_H264_4K2K */
+	return 0;
 }
 
 int mali_meson_uninit(struct platform_device* ptr_plt_dev)
 {
-    return 0;
+	return 0;
 }
 
 static int mali_cri_light_suspend(size_t param)
 {
-    int ret;
-    struct device *device;
-    struct mali_pmu_core *pmu;
-
-    ret = 0;
-    mali_pm_statue = 1;
-    device = (struct device *)param;
-    pmu = mali_pmu_get_global_pmu_core();
-
-    if (NULL != device->driver &&
-            NULL != device->driver->pm &&
-            NULL != device->driver->pm->runtime_suspend)
-    {
-        /* Need to notify Mali driver about this event */
-        ret = device->driver->pm->runtime_suspend(device);
-    }
-    mali_pmu_power_down_all(pmu);
-    return ret;
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	mali_pm_statue = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->runtime_suspend)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_suspend(device);
+	}
+	mali_pmu_power_down_all(pmu);
+	return ret;
 }
 
 static int mali_cri_light_resume(size_t param)
 {
-    int ret;
-    struct device *device;
-    struct mali_pmu_core *pmu;
-
-    ret = 0;
-    device = (struct device *)param;
-    pmu = mali_pmu_get_global_pmu_core();
-
-    mali_pmu_power_up_all(pmu);
-    if (NULL != device->driver &&
-            NULL != device->driver->pm &&
-            NULL != device->driver->pm->runtime_resume)
-    {
-        /* Need to notify Mali driver about this event */
-        ret = device->driver->pm->runtime_resume(device);
-    }
-    mali_pm_statue = 0;
-    return ret;
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	mali_pmu_power_up_all(pmu);
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->runtime_resume)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_resume(device);
+	}
+	mali_pm_statue = 1;
+	return ret;
 }
 
 static int mali_cri_deep_suspend(size_t param)
 {
-    int ret;
-    struct device *device;
-    struct mali_pmu_core *pmu;
-
-    ret = 0;
-    device = (struct device *)param;
-    pmu = mali_pmu_get_global_pmu_core();
-
-    if (NULL != device->driver &&
-            NULL != device->driver->pm &&
-            NULL != device->driver->pm->suspend)
-    {
-        /* Need to notify Mali driver about this event */
-        ret = device->driver->pm->suspend(device);
-    }
-    mali_pmu_power_down_all(pmu);
-    return ret;
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->suspend)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->suspend(device);
+	}
+	mali_pmu_power_down_all(pmu);
+	return ret;
 }
 
 static int mali_cri_deep_resume(size_t param)
 {
-    int ret;
-    struct device *device;
-    struct mali_pmu_core *pmu;
-
-    ret = 0;
-    device = (struct device *)param;
-    pmu = mali_pmu_get_global_pmu_core();
-
-    mali_pmu_power_up_all(pmu);
-    if (NULL != device->driver &&
-            NULL != device->driver->pm &&
-            NULL != device->driver->pm->resume)
-    {
-        /* Need to notify Mali driver about this event */
-        ret = device->driver->pm->resume(device);
-    }
-    return ret;
+	int ret;
+	struct device *device;
+	struct mali_pmu_core *pmu;
+
+	ret = 0;
+	device = (struct device *)param;
+	pmu = mali_pmu_get_global_pmu_core();
+
+	mali_pmu_power_up_all(pmu);
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->resume)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->resume(device);
+	}
+	return ret;
 
 }
 
 int mali_light_suspend(struct device *device)
 {
-    int ret = 0;
+	int ret = 0;
 #ifdef CONFIG_MALI400_PROFILING
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-            MALI_PROFILING_EVENT_CHANNEL_GPU |
-            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-            0, 0, 0, 0, 0);
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+					MALI_PROFILING_EVENT_CHANNEL_GPU |
+					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+					0, 0,	0,	0,	0);
 #endif
 
-    /* clock scaling. Kasin..*/
-    ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
-    disable_clock();
-    return ret;
+	/* clock scaling. Kasin..*/
+	ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
+	disable_clock();
+	return ret;
 }
 
 int mali_light_resume(struct device *device)
 {
-    int ret = 0;
-    enable_clock();
-    ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
+	int ret = 0;
+	enable_clock();
+	ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
 #ifdef CONFIG_MALI400_PROFILING
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-            MALI_PROFILING_EVENT_CHANNEL_GPU |
-            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-            get_current_frequency(), 0, 0, 0, 0);
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+					MALI_PROFILING_EVENT_CHANNEL_GPU |
+					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+					get_current_frequency(), 0,	0,	0,	0);
 #endif
-    return ret;
+	return ret;
 }
 
 int mali_deep_suspend(struct device *device)
 {
-    int ret = 0;
-
-    mali_pm_statue = 1;
-    enable_clock();
-#ifndef CONFIG_MALI_DVFS
-    flush_scaling_job();
-#endif
-
-    /* clock scaling off. Kasin... */
-    ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
-    disable_clock();
-    return ret;
+	int ret = 0;
+	enable_clock();
+	flush_scaling_job();
+
+	/* clock scaling off. Kasin... */
+	ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
+	disable_clock();
+	return ret;
 }
 
 int mali_deep_resume(struct device *device)
 {
-    int ret = 0;
+	int ret = 0;
 
-    /* clock scaling up. Kasin.. */
-    enable_clock();
-    ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
-    mali_pm_statue = 0;
-    return ret;
+	/* clock scaling up. Kasin.. */
+	enable_clock();
+	ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
+	return ret;
 
 }
 
-void mali_post_init(void)
-{
-#ifdef CONFIG_GPU_THERMAL
-    int err;
-    struct gpufreq_cooling_device *gcdev = NULL;
-    struct gpucore_cooling_device *gccdev = NULL;
-
-    gcdev = gpufreq_cooling_alloc();
-    register_gpu_freq_info(get_current_frequency);
-    if (IS_ERR(gcdev))
-        printk("malloc gpu cooling buffer error!!\n");
-    else if (!gcdev)
-        printk("system does not enable thermal driver\n");
-    else {
-        gcdev->get_gpu_freq_level = get_mali_freq_level;
-        gcdev->get_gpu_max_level = get_mali_max_level;
-        gcdev->set_gpu_freq_idx = set_limit_mali_freq;
-        gcdev->get_gpu_current_max_level = get_limit_mali_freq;
-        err = gpufreq_cooling_register(gcdev);
-        if (err < 0)
-            printk("register GPU  cooling error\n");
-        printk("gpu cooling register okay with err=%d\n",err);
-    }
-
-    gccdev = gpucore_cooling_alloc();
-    if (IS_ERR(gccdev))
-        printk("malloc gpu core cooling buffer error!!\n");
-    else if (!gccdev)
-        printk("system does not enable thermal driver\n");
-    else {
-        gccdev->max_gpu_core_num=mali_plat_data.cfg_pp;
-        gccdev->set_max_pp_num=set_limit_pp_num;
-        err = (int)gpucore_cooling_register(gccdev);
-        if (err < 0)
-            printk("register GPU  cooling error\n");
-        printk("gpu core cooling register okay with err=%d\n",err);
-    }
-#endif
-}
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/scaling.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/scaling.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_m450/scaling.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_m450/scaling.c	2016-04-04 16:25:32.988527000 +0300
@@ -17,439 +17,372 @@
 #include <linux/module.h>
 #include <linux/workqueue.h>
 #include <linux/mali/mali_utgard.h>
-#include <mali_kernel_common.h>
-#include <mali_osk_profiling.h>
+#include "mali_kernel_common.h"
+#include "common/mali_osk_profiling.h"
+#include "common/mali_kernel_utilization.h"
+#include "common/mali_pp_scheduler.h"
 
 #include <meson_main.h>
 
 #define LOG_MALI_SCALING 0
 
-
-static int currentStep;
-#ifndef CONFIG_MALI_DVFS
 static int num_cores_enabled;
+static int currentStep;
 static int lastStep;
 static struct work_struct wq_work;
 static mali_plat_info_t* pmali_plat = NULL;
-#endif
 static int  scaling_mode = MALI_PP_FS_SCALING;
 
-
-static unsigned scaling_dbg_level = 0;
-module_param(scaling_dbg_level, uint, 0644);
-MODULE_PARM_DESC(scaling_dbg_level , "scaling debug level");
-
-#define scalingdbg(level, fmt, arg...)                      \
-    do {                                                    \
-        if (scaling_dbg_level >= (level))                   \
-        printk(fmt , ## arg);                           \
-    } while (0)
-
-#ifndef CONFIG_MALI_DVFS
 static void do_scaling(struct work_struct *work)
 {
-    mali_dvfs_threshold_table * pdvfs = pmali_plat->dvfs_table;
-    int err = mali_perf_set_num_pp_cores(num_cores_enabled);
-    scalingdbg(1, "set pp cores to %d\n", num_cores_enabled);
-    MALI_DEBUG_ASSERT(0 == err);
-    MALI_IGNORE(err);
-    if (pdvfs[currentStep].freq_index != pdvfs[lastStep].freq_index) {
-        mali_dev_pause();
-        mali_clock_set(pdvfs[currentStep].freq_index);
-        mali_dev_resume();
-        lastStep = currentStep;
-    }
+	mali_dvfs_threshold_table * pdvfs = pmali_plat->dvfs_table;
+	int err = mali_perf_set_num_pp_cores(num_cores_enabled);
+	MALI_DEBUG_ASSERT(0 == err);
+	MALI_IGNORE(err);
+	if (pdvfs[currentStep].freq_index != pdvfs[lastStep].freq_index) {
+		mali_dev_pause();
+		mali_clock_set(pdvfs[currentStep].freq_index);
+		mali_dev_resume();
+		lastStep = currentStep;
+	}
 #ifdef CONFIG_MALI400_PROFILING
-    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-            MALI_PROFILING_EVENT_CHANNEL_GPU |
-            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-            get_current_frequency(),
-            0,	0,	0,	0);
+	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+					MALI_PROFILING_EVENT_CHANNEL_GPU |
+					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+					get_current_frequency(),
+					0,	0,	0,	0);
 #endif
 }
-#endif
 
 u32 revise_set_clk(u32 val, u32 flush)
 {
-    u32 ret = 0;
-#ifndef CONFIG_MALI_DVFS
-    mali_scale_info_t* pinfo;
-
-    pinfo = &pmali_plat->scale_info;
-
-    if (val < pinfo->minclk)
-        val = pinfo->minclk;
-    else if (val >  pinfo->maxclk)
-        val =  pinfo->maxclk;
-
-    if (val != currentStep) {
-        currentStep = val;
-        if (flush)
-            schedule_work(&wq_work);
-        else
-            ret = 1;
-    }
-#endif
-    return ret;
+	mali_scale_info_t* pinfo;
+	u32 ret = 0;
+
+	pinfo = &pmali_plat->scale_info;
+
+	if (val < pinfo->minclk)
+		val = pinfo->minclk;
+	else if (val >  pinfo->maxclk)
+		val =  pinfo->maxclk;
+
+	if (val != currentStep) {
+		currentStep = val;
+		if (flush)
+			schedule_work(&wq_work);
+		else
+			ret = 1;
+	}
+
+	return ret;
 }
 
 void get_mali_rt_clkpp(u32* clk, u32* pp)
 {
-#ifndef CONFIG_MALI_DVFS
-    *clk = currentStep;
-    *pp = num_cores_enabled;
-#endif
+	*clk = currentStep;
+	*pp = num_cores_enabled;
 }
 
 u32 set_mali_rt_clkpp(u32 clk, u32 pp, u32 flush)
 {
-    u32 ret = 0;
-#ifndef CONFIG_MALI_DVFS
-    mali_scale_info_t* pinfo;
-    u32 flush_work = 0;
-
-    pinfo = &pmali_plat->scale_info;
-    if (clk < pinfo->minclk)
-        clk = pinfo->minclk;
-    else if (clk >  pinfo->maxclk)
-        clk =  pinfo->maxclk;
-
-    if (clk != currentStep) {
-        currentStep = clk;
-        if (flush)
-            flush_work++;
-        else
-            ret = 1;
-    }
-    if (pp < pinfo->minpp)
-        pp = pinfo->minpp;
-    else if (pp > pinfo->maxpp)
-        pp = pinfo->maxpp;
-
-    if (pp != num_cores_enabled) {
-        num_cores_enabled = pp;
-        if (flush)
-            flush_work++;
-        else
-            ret = 1;
-    }
-
-    if (flush_work)
-        schedule_work(&wq_work);
-#endif
-    return ret;
+	mali_scale_info_t* pinfo;
+	u32 ret = 0;
+	u32 flush_work = 0;
+
+	pinfo = &pmali_plat->scale_info;
+	if (clk < pinfo->minclk)
+		clk = pinfo->minclk;
+	else if (clk >  pinfo->maxclk)
+		clk =  pinfo->maxclk;
+
+	if (clk != currentStep) {
+		currentStep = clk;
+		if (flush)
+			flush_work++;
+		else
+			ret = 1;
+	}
+	if (pp < pinfo->minpp)
+		pp = pinfo->minpp;
+	else if (pp > pinfo->maxpp)
+		pp = pinfo->maxpp;
+
+	if (pp != num_cores_enabled) {
+		num_cores_enabled = pp;
+		if (flush)
+			flush_work++;
+		else
+			ret = 1;
+	}
+
+	if (flush_work)
+		schedule_work(&wq_work);
+	return ret;
 }
 
 void revise_mali_rt(void)
 {
-#ifndef CONFIG_MALI_DVFS
-    set_mali_rt_clkpp(currentStep, num_cores_enabled, 1);
-#endif
+	set_mali_rt_clkpp(currentStep, num_cores_enabled, 1);
 }
 
 void flush_scaling_job(void)
 {
-#ifndef CONFIG_MALI_DVFS
-    cancel_work_sync(&wq_work);
-#endif
+	cancel_work_sync(&wq_work);
 }
 
-#ifndef CONFIG_MALI_DVFS
 static u32 enable_one_core(void)
 {
-    scalingdbg(2, "meson:     one more pp, curent has %d pp cores\n",  num_cores_enabled + 1);
-    return set_mali_rt_clkpp(currentStep, num_cores_enabled + 1, 0);
+	return set_mali_rt_clkpp(currentStep, num_cores_enabled + 1, 0);
 }
 
 static u32 disable_one_core(void)
 {
-    scalingdbg(2, "meson: disable one pp, current has %d pp cores\n",  num_cores_enabled - 1);
-    return set_mali_rt_clkpp(currentStep, num_cores_enabled - 1, 0);
+	return set_mali_rt_clkpp(currentStep, num_cores_enabled - 1, 0);
 }
 
 static u32 enable_max_num_cores(void)
 {
-    return set_mali_rt_clkpp(currentStep, pmali_plat->scale_info.maxpp, 0);
+	return set_mali_rt_clkpp(currentStep, pmali_plat->scale_info.maxpp, 0);
 }
 
 static u32 enable_pp_cores(u32 val)
 {
-    scalingdbg(2, "meson: enable %d pp cores\n", val);
-    return set_mali_rt_clkpp(currentStep, val, 0);
+	return set_mali_rt_clkpp(currentStep, val, 0);
 }
-#endif
 
 int mali_core_scaling_init(mali_plat_info_t *mali_plat)
 {
-#ifndef CONFIG_MALI_DVFS
-    if (mali_plat == NULL) {
-        scalingdbg(2, " Mali platform data is NULL!!!\n");
-        return -1;
-    }
-
-    pmali_plat = mali_plat;
-    num_cores_enabled = pmali_plat->sc_mpp;
-
-    currentStep = pmali_plat->def_clock;
-    lastStep = currentStep;
-    INIT_WORK(&wq_work, do_scaling);
-#endif
-    return 0;
-    /* NOTE: Mali is not fully initialized at this point. */
+	if (mali_plat == NULL) {
+		printk(" Mali platform data is NULL!!!\n");
+		return -1;
+	}
+
+	pmali_plat = mali_plat;
+	num_cores_enabled = pmali_plat->sc_mpp;
+
+	currentStep = pmali_plat->def_clock;
+	lastStep = currentStep;
+	INIT_WORK(&wq_work, do_scaling);
+
+	return 0;
+	/* NOTE: Mali is not fully initialized at this point. */
 }
 
 void mali_core_scaling_term(void)
 {
-#ifndef CONFIG_MALI_DVFS
-    flush_scheduled_work();
-#endif
+	flush_scheduled_work();
 }
 
-#ifndef CONFIG_MALI_DVFS
 static u32 mali_threshold [] = {
-    102, /* 40% */
-    128, /* 50% */
-    230, /* 90% */
+	102, /* 40% */
+	128, /* 50% */
+	230, /* 90% */
 };
-#endif
 
 void mali_pp_scaling_update(struct mali_gpu_utilization_data *data)
 {
-#ifndef CONFIG_MALI_DVFS
-    int ret = 0;
+	int ret = 0;
 
-    if (mali_threshold[2] < data->utilization_pp)
-        ret = enable_max_num_cores();
-    else if (mali_threshold[1]< data->utilization_pp)
-        ret = enable_one_core();
-    else if (0 < data->utilization_pp)
-        ret = disable_one_core();
-    if (ret == 1)
-        schedule_work(&wq_work);
-#endif
+	if (mali_threshold[2] < data->utilization_pp)
+		ret = enable_max_num_cores();
+	else if (mali_threshold[1]< data->utilization_pp)
+		ret = enable_one_core();
+	else if (0 < data->utilization_pp)
+		ret = disable_one_core();
+	if (ret == 1)
+		schedule_work(&wq_work);
 }
 
 #if LOG_MALI_SCALING
 void trace_utilization(struct mali_gpu_utilization_data *data, u32 current_idx, u32 next,
-        u32 current_pp, u32 next_pp)
+	u32 current_pp, u32 next_pp)
 {
-    char direction;
-    if (next > current_idx)
-        direction = '>';
-    else if ((current_idx > pmali_plat->scale_info.minpp) && (next < current_idx))
-        direction = '<';
-    else
-        direction = '~';
-
-    scalingdbg(2, "[SCALING]%c (%3d-->%3d)@%3d{%3d - %3d}. pp:(%d-->%d)\n",
-            direction,
-            get_mali_freq(current_idx),
-            get_mali_freq(next),
-            data->utilization_gpu,
-            pmali_plat->dvfs_table[current_idx].downthreshold,
-            pmali_plat->dvfs_table[current_idx].upthreshold,
-            current_pp, next_pp);
+	char direction;
+	if (next > current_idx)
+		direction = '>';
+	else if ((current_idx > pmali_plat->scale_info.minpp) && (next < current_idx))
+		direction = '<';
+	else
+		direction = '~';
+
+	printk("[SCALING]%c (%3d-->%3d)@%3d{%3d - %3d}. pp:(%d-->%d)\n",
+				direction,
+				get_mali_freq(current_idx),
+				get_mali_freq(next),
+				data->utilization_gpu,
+				pmali_plat->dvfs_table[current_idx].downthreshold,
+				pmali_plat->dvfs_table[current_idx].upthreshold,
+				current_pp, next_pp);
 }
 #endif
 
-#ifndef CONFIG_MALI_DVFS
 static int mali_stay_count = 0;
 static void mali_decide_next_status(struct mali_gpu_utilization_data *data, int* next_fs_idx,
-        int* pp_change_flag)
+								int* pp_change_flag)
 {
-    u32 utilization, mali_up_limit, decided_fs_idx;
-    u32 ld_left, ld_right;
-    u32 ld_up, ld_down;
-    u32 change_mode;
+	u32 utilization, mali_up_limit, decided_fs_idx;
+	u32 ld_left, ld_right;
+	u32 ld_up, ld_down;
+	char change_mode;
 
-    *pp_change_flag = 0;
-    change_mode = 0;
+	*pp_change_flag = 0;
+	change_mode = 0;
 	utilization = 255;
 
-    mali_up_limit = (scaling_mode ==  MALI_TURBO_MODE) ?
-        pmali_plat->turbo_clock : pmali_plat->scale_info.maxclk;
-    decided_fs_idx = currentStep;
-
-    ld_up = pmali_plat->dvfs_table[currentStep].upthreshold;
-    ld_down = pmali_plat->dvfs_table[currentStep].downthreshold;
-
-    scalingdbg(2, "utilization=%d,  ld_up=%d\n ", utilization,  ld_up);
-    if (utilization >= ld_up) { /* go up */
-
-        scalingdbg(2, "currentStep=%d,  mali_up_limit=%d\n ", currentStep, mali_up_limit);
-        if (currentStep < mali_up_limit) {
-            change_mode = 1;
-            if ((currentStep < pmali_plat->def_clock) && (utilization > pmali_plat->bst_gpu))
-                decided_fs_idx = pmali_plat->def_clock;
-            else
-                decided_fs_idx++;
-        }
-        if ((data->utilization_pp >= ld_up) &&
-                (num_cores_enabled < pmali_plat->scale_info.maxpp)) {
-            if ((num_cores_enabled < pmali_plat->sc_mpp) && (data->utilization_pp >= pmali_plat->bst_pp)) {
-                *pp_change_flag = 1;
-                change_mode = 1;
-            } else if (change_mode == 0) {
-                *pp_change_flag = 2;
-                change_mode = 1;
-            }
-        }
-#if LOG_MALI_SCALING
-        scalingdbg(2, "[nexting..] [LD:%d]-> FS[CRNT:%d LMT:%d NEXT:%d] PP[NUM:%d LMT:%d MD:%d][F:%d]\n",
-                data->utilization_pp, currentStep, mali_up_limit, decided_fs_idx,
-                num_cores_enabled, pmali_plat->scale_info.maxpp, *pp_change_flag, change_mode);
-#endif
-    } else if (utilization <= ld_down) { /* go down */
-        if (mali_stay_count > 0) {
-            *next_fs_idx = decided_fs_idx;
-            mali_stay_count--;
-            return;
-        }
-
-        if (num_cores_enabled > pmali_plat->sc_mpp) {
-            change_mode = 1;
-            if (data->utilization_pp <= ld_down) {
-                ld_left = data->utilization_pp * num_cores_enabled;
-                ld_right = (pmali_plat->dvfs_table[currentStep].upthreshold) *
-                    (num_cores_enabled - 1);
-                if (ld_left < ld_right) {
-                    change_mode = 2;
-                }
-            }
-        } else if (currentStep > pmali_plat->scale_info.minclk) {
-            change_mode = 1;
-        } else if (num_cores_enabled > 1) { /* decrease PPS */
-            if (data->utilization_pp <= ld_down) {
-                ld_left = data->utilization_pp * num_cores_enabled;
-                ld_right = (pmali_plat->dvfs_table[currentStep].upthreshold) *
-                    (num_cores_enabled - 1);
-                scalingdbg(2, "ld_left=%d, ld_right=%d\n", ld_left, ld_right);
-                if (ld_left < ld_right) {
-                    change_mode = 2;
-                }
-            }
-        }
-
-        if (change_mode == 1) {
-            decided_fs_idx--;
-        } else if (change_mode == 2) { /* decrease PPS */
-            *pp_change_flag = -1;
-        }
-    }
-    if (change_mode)
-        mali_stay_count = pmali_plat->dvfs_table[decided_fs_idx].keep_count;
-    *next_fs_idx = decided_fs_idx;
+	mali_up_limit = (scaling_mode ==  MALI_TURBO_MODE) ?
+				pmali_plat->turbo_clock : pmali_plat->scale_info.maxclk;
+	decided_fs_idx = currentStep;
+
+	ld_up = pmali_plat->dvfs_table[currentStep].upthreshold;
+	ld_down = pmali_plat->dvfs_table[currentStep].downthreshold;
+	if (utilization >= ld_up) { /* go up */
+		if (currentStep < mali_up_limit) {
+			change_mode = 1;
+			if ((currentStep < pmali_plat->def_clock) && (utilization > pmali_plat->bst_gpu))
+				decided_fs_idx = pmali_plat->def_clock;
+			else
+				decided_fs_idx++;
+		}
+		if ((data->utilization_pp > ld_up) &&
+				(num_cores_enabled < pmali_plat->scale_info.maxpp)) {
+			if ((num_cores_enabled < pmali_plat->sc_mpp) && (data->utilization_pp >= pmali_plat->bst_pp)) {
+				*pp_change_flag = 1;
+				change_mode = 1;
+			} else if (change_mode == 0) {
+				*pp_change_flag = 2;
+				change_mode = 1;
+			}
+		}
+	} else if (utilization <= ld_down) { /* go down */
+		if (mali_stay_count > 0) {
+			*next_fs_idx = decided_fs_idx;
+			mali_stay_count--;
+			return;
+		}
+
+		if (num_cores_enabled > pmali_plat->sc_mpp) {
+			change_mode = 1;
+			if (data->utilization_pp <= ld_down) {
+				ld_left = data->utilization_pp * num_cores_enabled;
+				ld_right = (pmali_plat->dvfs_table[currentStep].upthreshold) *
+								(num_cores_enabled - 1);
+				if (ld_left < ld_right) {
+					change_mode = 2;
+				}
+			}
+		} else if (currentStep > pmali_plat->scale_info.minpp) {
+			change_mode = 1;
+		} else if (num_cores_enabled > 1) { /* decrease PPS */
+			if (data->utilization_pp <= ld_down) {
+				ld_left = data->utilization_pp * num_cores_enabled;
+				ld_right = (pmali_plat->dvfs_table[currentStep].upthreshold) *
+								(num_cores_enabled - 1);
+				if (ld_left < ld_right) {
+					change_mode = 2;
+				}
+			}
+		}
+
+		if (change_mode == 1) {
+			decided_fs_idx--;
+		} else if (change_mode == 2) { /* decrease PPS */
+			*pp_change_flag = -1;
+		}
+	}
+	if (change_mode)
+		mali_stay_count = pmali_plat->dvfs_table[decided_fs_idx].keep_count;
+	*next_fs_idx = decided_fs_idx;
 }
-#endif
 
 void mali_pp_fs_scaling_update(struct mali_gpu_utilization_data *data)
 {
-#ifndef CONFIG_MALI_DVFS
-    int ret = 0;
-    int pp_change_flag = 0;
-    u32 next_idx = 0;
+	int ret = 0;
+	int pp_change_flag = 0;
+	u32 next_idx = 0;
 
 #if LOG_MALI_SCALING
-    u32 last_pp = num_cores_enabled;
+	u32 last_pp = num_cores_enabled;
 #endif
-    mali_decide_next_status(data, &next_idx, &pp_change_flag);
+	mali_decide_next_status(data, &next_idx, &pp_change_flag);
 
-    if (pp_change_flag == 1)
-        ret = enable_pp_cores(pmali_plat->sc_mpp);
-    else if (pp_change_flag == 2)
-        ret = enable_one_core();
-    else if (pp_change_flag == -1) {
-        ret = disable_one_core();
-    }
+	if (pp_change_flag == 1)
+		ret = enable_pp_cores(pmali_plat->sc_mpp);
+	else if (pp_change_flag == 2)
+		ret = enable_one_core();
+	else if (pp_change_flag == -1) {
+		ret = disable_one_core();
+	}
 
 #if LOG_MALI_SCALING
-    if (pp_change_flag || (next_idx != currentStep))
-        trace_utilization(data, currentStep, next_idx, last_pp, num_cores_enabled);
+	if (pp_change_flag || (next_idx != currentStep))
+		trace_utilization(data, currentStep, next_idx, last_pp, num_cores_enabled);
 #endif
 
-    if (next_idx != currentStep) {
-        ret = 1;
-        currentStep = next_idx;
-    }
+	if (next_idx != currentStep) {
+		ret = 1;
+		currentStep = next_idx;
+	}
 
-    if (ret == 1)
-        schedule_work(&wq_work);
+	if (ret == 1)
+		schedule_work(&wq_work);
 #ifdef CONFIG_MALI400_PROFILING
-    else
-        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-                MALI_PROFILING_EVENT_CHANNEL_GPU |
-                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-                get_current_frequency(),
-                0,	0,	0,	0);
-#endif
+	else
+		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+						MALI_PROFILING_EVENT_CHANNEL_GPU |
+						MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+						get_current_frequency(),
+						0,	0,	0,	0);
 #endif
 }
 
 u32 get_mali_schel_mode(void)
 {
-    return scaling_mode;
+	return scaling_mode;
 }
 
 void set_mali_schel_mode(u32 mode)
 {
-#ifndef CONFIG_MALI_DVFS
-    MALI_DEBUG_ASSERT(mode < MALI_SCALING_MODE_MAX);
-    if (mode >= MALI_SCALING_MODE_MAX)
-        return;
+	MALI_DEBUG_ASSERT(mode < MALI_SCALING_MODE_MAX);
+	if (mode >= MALI_SCALING_MODE_MAX)
+		return;
 	scaling_mode = MALI_TURBO_MODE;
 
-    /* set default performance range. */
-    pmali_plat->scale_info.minclk = pmali_plat->cfg_min_clock;
-    pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
-    pmali_plat->scale_info.minpp = pmali_plat->cfg_min_pp;
-    pmali_plat->scale_info.maxpp = pmali_plat->cfg_pp;
-
-    /* set current status and tune max freq */
-    if (scaling_mode == MALI_PP_FS_SCALING) {
-        pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
-        enable_pp_cores(pmali_plat->sc_mpp);
-    } else if (scaling_mode == MALI_SCALING_DISABLE) {
-        pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
-        enable_max_num_cores();
-    } else if (scaling_mode == MALI_TURBO_MODE) {
-        pmali_plat->scale_info.maxclk = pmali_plat->turbo_clock;
-        enable_max_num_cores();
-    }
-    currentStep = pmali_plat->scale_info.maxclk;
-    schedule_work(&wq_work);
-#endif
+	/* set default performance range. */
+	pmali_plat->scale_info.minclk = pmali_plat->cfg_min_clock;
+	pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
+	pmali_plat->scale_info.minpp = pmali_plat->cfg_min_pp;
+	pmali_plat->scale_info.maxpp = pmali_plat->cfg_pp;
+
+	/* set current status and tune max freq */
+	if (scaling_mode == MALI_PP_FS_SCALING) {
+		pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
+		enable_pp_cores(pmali_plat->sc_mpp);
+	} else if (scaling_mode == MALI_SCALING_DISABLE) {
+		pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
+		enable_max_num_cores();
+	} else if (scaling_mode == MALI_TURBO_MODE) {
+		pmali_plat->scale_info.maxclk = pmali_plat->turbo_clock;
+		enable_max_num_cores();
+	}
+	currentStep = pmali_plat->scale_info.maxclk;
+	schedule_work(&wq_work);
 }
 
 u32 get_current_frequency(void)
 {
-    return get_mali_freq(currentStep);
+	return get_mali_freq(currentStep);
 }
 
 void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data)
 {
-#ifndef CONFIG_MALI_DVFS
-    if (mali_pm_statue)
-        return;
-
-    switch (scaling_mode) {
-        case MALI_PP_FS_SCALING:
-            mali_pp_fs_scaling_update(data);
-            break;
-        case MALI_PP_SCALING:
-            mali_pp_scaling_update(data);
-            break;
-        default:
-            break;
-    }
-#endif
-}
-
-void mali_dev_restore(void)
-{
-#ifndef CONFIG_MALI_DVFS
-    mali_dvfs_threshold_table * pdvfs = pmali_plat->dvfs_table;
-
-    //mali_perf_set_num_pp_cores(num_cores_enabled);
-    mali_clock_set(pdvfs[currentStep].freq_index);
-#endif
+	switch (scaling_mode) {
+	case MALI_PP_FS_SCALING:
+		mali_pp_fs_scaling_update(data);
+		break;
+	case MALI_PP_SCALING:
+		mali_pp_scaling_update(data);
+		break;
+	default:
+		break;
+	}
 }
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_main.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_main.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_main.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_main.c	2016-04-04 16:25:32.998527000 +0300
@@ -27,20 +27,16 @@
 #include "common/mali_pmu.h"
 #include "common/mali_osk_profiling.h"
 
-int mali_pm_statue = 0;
-u32 mali_gp_reset_fail = 0;
-module_param(mali_gp_reset_fail, int, S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH); /* rw-rw-r-- */
-MODULE_PARM_DESC(mali_gp_reset_fail, "times of failed to reset GP");
-u32 mali_core_timeout = 0;
-module_param(mali_core_timeout, int, S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH); /* rw-rw-r-- */
-MODULE_PARM_DESC(mali_core_timeout, "times of failed to reset GP");
+int mali_pm_statue = 1;
 
 static struct mali_gpu_device_data mali_gpu_data =
 {
 	.shared_mem_size = 1024 * 1024 * 1024,
+	.fb_start = 0x06100000,
+	.fb_size = 0x01800000,
 	.max_job_runtime = 60000, /* 60 seconds */
 	.pmu_switch_delay = 0xFFFF, /* do not have to be this high on FPGA, but it is good for testing to have a delay */
-	.pmu_domain_config = { 0 },
+	.pmu_domain_config = {0x1, 0x2, 0x4, 0x4, 0x4, 0x8, 0x8, 0x8, 0x8, 0x1, 0x2, 0x8},
 };
 
 static void mali_platform_device_release(struct device *device);
@@ -66,8 +62,6 @@
 
 void mali_pdev_post_init(struct platform_device* pdev)
 {
-	mali_gp_reset_fail = 0;
-	mali_core_timeout = 0;
 #ifdef CONFIG_PM_RUNTIME
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 	pm_runtime_set_autosuspend_delay(&(pdev->dev), 1000);
@@ -124,4 +118,3 @@
 	MALI_DEBUG_PRINT(4, ("mali_platform_device_release() called\n"));
 }
 
-
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_main.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_main.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/meson_main.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/meson_main.h	2016-04-04 16:25:33.008527000 +0300
@@ -18,7 +18,6 @@
 #include "mali_clock.h"
 
 extern struct device_type mali_pm_device;
-extern int mali_pm_statue;
 
 u32 set_max_mali_freq(u32 idx);
 u32 get_max_mali_freq(void);
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mpgpu.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mpgpu.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/platform/mpgpu.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/platform/mpgpu.c	2016-04-04 16:25:33.018527000 +0300
@@ -29,16 +29,19 @@
 #include <common/mali_pmu.h>
 #include "meson_main.h"
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 static ssize_t domain_stat_read(struct class *class,
 			struct class_attribute *attr, char *buf)
 {
 	unsigned int val;
-
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	val = readl((u32 *)(IO_AOBUS_BASE + 0xf0)) & 0xff;
+#else
+	val = 0xffffffff;
+#endif
 	return sprintf(buf, "%x\n", val>>4);
 }
 
+#if MESON_CPU_TYPE > MESON_CPU_TYPE_MESON6TVD
 #define PREHEAT_CMD "preheat"
 #define PLL2_CMD "mpl2"  /* mpl2 [11] or [0xxxxxxx] */
 #define SCMPP_CMD "scmpp"  /* scmpp [number of pp your want in most of time]. */
@@ -301,7 +304,11 @@
 	return count;
 }
 
+#endif
+
+
 static struct class_attribute mali_class_attrs[] = {
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	__ATTR(domain_stat,	0644, domain_stat_read, NULL),
 	__ATTR(mpgpucmd,	0644, NULL,		mpgpu_write),
 	__ATTR(scale_mode,	0644, scale_mode_read,  scale_mode_write),
@@ -311,16 +318,15 @@
 	__ATTR(max_pp,		0644, max_pp_read,	max_pp_write),
 	__ATTR(cur_freq,	0644, freq_read,	freq_write),
 	__ATTR(cur_pp,		0644, current_pp_read,	current_pp_write),
+#endif
 };
 
 static struct class mpgpu_class = {
 	.name = "mpgpu",
 };
-#endif
 
 int mpgpu_class_init(void)
 {
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	int ret = 0;
 	int i;
 	int attr_num =  ARRAY_SIZE(mali_class_attrs);
@@ -337,15 +343,10 @@
 		}
 	}
 	return ret;
-#else
-        return 0;
-#endif
 }
 
 void  mpgpu_class_exit(void)
 {
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	class_unregister(&mpgpu_class);
-#endif
 }
 
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/regs/mali_200_regs.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/regs/mali_200_regs.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/regs/mali_200_regs.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/regs/mali_200_regs.h	2016-04-04 16:25:33.028527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/regs/mali_gp_regs.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/regs/mali_gp_regs.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/regs/mali_gp_regs.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/regs/mali_gp_regs.h	2016-04-04 16:25:33.038527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/timestamp-arm11-cc/mali_timestamp.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/timestamp-arm11-cc/mali_timestamp.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/timestamp-arm11-cc/mali_timestamp.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/timestamp-arm11-cc/mali_timestamp.c	2016-04-04 16:25:33.048527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011, 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2011, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/timestamp-arm11-cc/mali_timestamp.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/timestamp-arm11-cc/mali_timestamp.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/timestamp-arm11-cc/mali_timestamp.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/timestamp-arm11-cc/mali_timestamp.h	2016-04-04 16:25:33.058527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2011, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/timestamp-default/mali_timestamp.c linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/timestamp-default/mali_timestamp.c
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/timestamp-default/mali_timestamp.c	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/timestamp-default/mali_timestamp.c	2016-04-04 16:25:33.068527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011, 2013, 2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2011, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
diff -NaurZ linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/timestamp-default/mali_timestamp.h linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/timestamp-default/mali_timestamp.h
--- linux-amlogic-3.10-cf51189/drivers/amlogic/gpu/mali/timestamp-default/mali_timestamp.h	2016-03-17 14:47:20.000000000 +0300
+++ linux-amlogic-3.10-cf51189-mali/drivers/amlogic/gpu/mali/timestamp-default/mali_timestamp.h	2016-04-04 16:25:33.078527000 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ * Copyright (C) 2010-2011, 2013-2014 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
